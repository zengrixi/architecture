// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>
#include <vector>
#include <list>
#include <WinSock2.h>
#include <map>
#pragma  comment(lib, "ws2_32.lib")

#pragma warning(disable : 4996)

int main()
{	
	//一：前面学习的总结
	//核心架构浓缩总结实现的功能：
	//（1）服务器按照包头包体格式正确的接收客户端发送过来的数据包；
	//（2）根据手动的包的不同来执行不同的业务处理逻辑；
	//（3）把业务处理产生的结果数据包返回客户端；

	//咱们用到的主要技术
	//（1）epoll高并发通讯技术
	//（2）线程池技术来处理业务逻辑
	//（3）线程之间的同步技术包括互斥量、信号量
	//其他技术：信号，日志打印，fork()子进程，守护进程

	//借鉴了哪些官方nginx的精华代码
	//（1）master进程，多个worker子进程——进程框架；
	  //nginx：热更新，worker子进程挂了master能够重新启动worker；重载配置文件
	  //【卷1讲解的主要是框架——包括通讯框架、包括业务逻辑处理框架，这才是我们本门课程的核心和精粹】
	//（2）借鉴了epoll的一些实现代码；官方nginx用的ET【边缘触发模式】，咱们本项目中用的是水平触发模式LT
	//（3）借鉴了接收数据包，以及发送数据包的核心代码；
	//官方nginx对我们项目的实现帮助不小，咱们借鉴的都是nginx中最核心，最值得借鉴的优秀代码；

	//哪些内容我们没有借鉴官方nginx呢？
	//（1）比如epoll技术中我们采用LT模式来书写网络数据的接收和发送；
	//（2）自己写一套线程池来处理业务逻辑，调用适当的业务逻辑处理函数，直至处理完毕把数据发送回客户端；
	//（3）连接池 中 连接的 延迟 回收，以及专门处理数据发送的发送线程；
	//上面三条都是咱们这门课程的核心精粹代码；
	//只要学懂，最低都是一个高级程序员，在一个十几个人的小公司，做一个服务器开发主程序都没有问题；
	//良心与责任同行：扶上马，送一程，能送多远，老师会尽力；
	//目前为止：
	//a)咱们服务器代码有没有什么瑕疵bug，导致比如说客户端发送恶意数据包能够把我们服务器攻击死呢？
	//b)有没有代码能够进一步完善，写的更好； 提出问题，解决问题：

	//二：心跳包概念：注意面试可能考
	//c/s程序：都有责任把心跳包机制在程序代码中实现好，以确保程序能良好的工作以及应付意外的情形发生；
	//（2.1）什么叫心跳包以及如何使用
	//心跳包其实就是 一个普通的数据包；
	//一般每个几十秒，最长一般也就是1分钟【10秒-60秒之间】，有客户端主动发送给服务器；服务器收到之后，一般会给客户端返回一个心跳包；
	//三路握手，tcp连接建立之后，才存在发送心跳包的问题—— 如果c不给s发心跳包，服务器会怎样；
	//约定 30秒发送 一次； 服务器可能会在90秒或者100秒内，主动关闭该客户端的socket连接；
	//作为一个好的客户端程序，如果你发送了心跳包给服务器，但是在90或者100秒之内，你[客户端]没有收到服务器回应的心跳包，那么
	  //你就应该主动关闭与服务器端的链接，并且如果业务需要重连，客户端程序在关闭这个连接后还要重新主动再次尝试连接服务器端；
	   //客户端程序 也有必要提示使用者 与服务器的连接已经断开；
	//（2.2）为什么引入心跳包
	//常规客户端关闭，服务器端能感知到；
	//有一种特殊情况，连接断开c/s都感知不到；

	//tcp本身keepalive机制；不重点研究，大家可以自己百度，因为检测时间不好控制，所以不适合我们；
	//c /s程序运行在不同的两个物理电脑上；tcp已经建立；
	//拔掉c /s程序的网线； 拔掉网线导致服务器感知不到客户端断开，这个事实，大家一定要知道；
	//那位了应对拔网线，导致不知道对方是否断开了tcp连接这种事，这就是我们引入心跳包机制的原因；
	//超时没有发送来心跳包，那么就会将对端的socket连接close掉，回收资源；这就是心跳包的作用；
	//其他作用：检测网络延迟等等；大家以后遇到再研究；
	//我们这里讲解心跳包，主要目的就是检测双方的链接是否断开；

	//三：心跳包代码实战
	//（3.1）接收心跳包与返回结果
	//心跳包（ping包）
	//规定消息代码为0；一般心跳包也不需要包体，只有包头就够了；

	//（3.2）处理不发送心跳包的客户端
	//30秒；超过30*3 +10 =100秒，仍旧没收到心跳包，那么服务器端就把tcp断开；
	//增加配置Sock_WaitTimeEnable，Sock_MaxWaitTime
	//修改ReadConf()函数读取配置信息；
	//ngx_c_socket_time.cxx专门存放一些跟时间有关的函数；

	//AddToTimerQueue() :把一个连接的信息加入到时间队列中来；该函数由 ngx_event_accept()函数在连接成功连入时调用；
	//定时器队列：官方nginx，红黑树做定时器，时间轮，老师用multimap来做定时器；

	//谁又来处理时间队列中的数据呢？ 咱们的思路是 创建一个新线程，专门处理事件队列这个事；介绍新线程ServerTimerQueueMonitorThread();
	//GetOverTimeTimer();RemoveFirstTimer();procPingTimeOutChecking();zdClosesocketProc()
	//改造inRecyConnectQueue()；ServerRecyConnectionThread();clearAllFromTimerQueue（）

	//（3.3）测试代码的书写

	
}

