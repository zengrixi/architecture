// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>

using namespace std;
#pragma warning(disable : 4996)

int main()
{
	//一：守护进程功能的实现
	//三章二节  
	   //(1)拦截掉SIGHUP，那么终端窗口关闭，进程就不会跟着关闭
	   //(2)守护进程，三章七节，一运行就在后台，不会占着终端。
	//创建守护进程ngx_daemon（）；
	//调用ngx_daemon（）的时机： worker()子进程创建之前；
	//ps -eo pid,ppid,sid,tty,pgrp,comm,stat,cmd | grep -E 'bash|PID|nginx'
	//(1)一个master,4个worker进程，状态S，表示休眠状态，但没有+,+号表示位于前台进程组，没有+说明我们这几个进程不在前台进程组；
	//(2)master进程的ppid是1【老祖宗进程init】，其他几个worker进程的父进程都是master；
	//(3)tt这列都为？，表示他们都脱离了终端，不与具体的终端挂钩了
	//(4)他们的进程组PGRP都相同；
	
	//结论：
	//1)守护进程如果通过键盘执行可执行文件来启动，那虽然守护进程与具体终端是脱钩的，但是依旧可以往标准错误上输出内容，这个终端对应的屏幕上可以看到输入的内容；
	//2)但是如果这个nginx守护进程你不是通过终端启动，你可能开机就启动，那么这个nginx守护进程就完全无法往任何屏幕上显示信息了，这个时候，要排错就要靠日志文件了；

	//二：信号处理函数的进一步完善
	//（2.1）避免子进程被杀掉时变成僵尸进程
	//父进程要处理SIGCHILD信号并在信号处理函数中调用waitpid()来解决僵尸进程的问题；
	//信号处理函数中的代码，要坚持一些书写原则：
	//a)代码尽可能简单，尽可能快速的执行完毕返回；
	//b)用一些全局量做一些标记；尽可能不调用函数；
	//c)不要在信号处理函数中执行太复杂的代码以免阻塞其他信号的到来，甚至阻塞整个程序执行流程；
	   	  

}


