// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>
#include <vector>
#include <list>
#include <WinSock2.h>
#pragma  comment(lib, "ws2_32.lib")

using namespace std;
#pragma warning(disable : 4996)


int main()
{	
	//一：线程池代码调整及补充说明
	//支撑线程池的运作主要靠两个函数：pthread_cond_signal(&m_pthreadCond);  触发
	  //pthread_cond_wait(&m_pthreadCond, &m_pthreadMutex);   等待
	//《Unix环境高级编程》  11章 线程，11.6.6: 条件变量：m_pthreadCond:
	     //条件变量，是线程可用的另一种同步机制，条件变量给多个线程提供了一个会合的场所，条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生；
	//a)条件本身【while ( (pThreadPoolObj->m_MsgRecvQueue.size() == 0) && m_shutdown == false)】 是由互斥量保护的。
	    //线程在改变条件状态之前必须首先锁住互斥量，其他线程在获取到互斥量之前不会觉察到这种改变，因为互斥量必须在锁定以后才能计算条件；
	//c++11，也有条件变量的说法   my_cond.wait(....),   my_cond.notify_one(...)
	//大家如果有兴趣可以用c++11多线程开发技术实现 自己的跨平台的线程池代码；
	//b)传递给pthread_cond_wait的互斥量m_pthreadMutex对条件【 while ( (pThreadPoolObj->m_MsgRecvQueue.size() == 0) && m_shutdown == false)】进行保护的，
	   //调用者把锁住的互斥量传递给函数pthread_cond_wait，函数 然后自动把调用线程 放在 等待条件的 线程列表 上，对互斥量解锁，
	     //这就关闭了 条件检查 和 线程进入休眠状态等待条件改变  这两个操作之间的时间通道，
	           //这样线程就不会错过条件的任何变化。pthread_cond_wait返回时，互斥量再次被锁定；

	//二：线程池实现具体业务之准备代码
	//（2.1）一个简单的crc32校验算法介绍
	//CCRC32类：主要目的是对收发的数据包进行一个简单的校验，以确保数据包中的内容没有被篡改过；
	//Get_CRC()：给你一段buffer，也就是一段内存，然后给你这段内存长度，该函数计算出一个数字来(CRC32值)返回来；

	//（2.2）引入新的CSocket子类
	//真正项目中要把CSocekt类当成父类使用，具体业务逻辑代码应该放在CSocket的子类中；
	//threadRecvProcFunc()收到消息之后的处理函数；

	//（2.3）设计模式题外话
	//有很多人善于，乐于：抽象；把一个一个小功能封装成一个一个类；往设计模式上套 进行所谓的面向对象程序设计；
	//最能体现面向对象的 多态【虚函数】；
	//写程序：每个人有每个人的喜好；老师最喜欢的就是简单粗暴有效的程序设计方式，完全不喜欢动不动就封装一个类的这种写法；
	//a)类太多，别人理解起来就非常困难，另外类太多，对程序效率影响很大；
	//b)几十万，上百万上代码，里边很多部件需要灵活调整，经常变动，不稳定的部分，才需要抽象出来，用虚函数，通过设计模式来灵活解决；
	//不要乱用设计模式，不要乱封装；

	//（2.4）消息的具体设计
	//为了能够根据客户端发送过来的消息代码 迅速定位到要执行的函数，我们就把客户端发送过来的 消息代码直接当做 一个数组的下标来用；
	//最终认识：咱们的服务器开发工作【业务逻辑】，主要集中在三个文件中：ngx_logiccomm.h，ngx_c_slogic.cxx，ngx_c_slogic.h

	//三：threadRecvProcFunc()函数讲解

	//四：整体测试工作的开展
	//服务器开发工作，公司 配备专门客户端开发人员来开发客户端工作；
	//c/s配合工作，配合指定通讯协议；协议的制定一般是  服务器程序员来主导；
	//(1)确定通讯格式是 包头+包体，包头固定多少个字节，这种规则是服务器端 来制定并在开发一个项目之前，要明确的 和客户端交代好；
	   //要求客户端给服务器发送数据包时严格遵循这种格式；
	//(2)注册，登录，都属于具体的业务逻辑 命令；这种命令一般都是由服务器牵头来制定；

	//（4.1）不做背锅侠
	//服务器开发难度往往比客户端大很多，责任也重很多；要求也高得多；
	//讲清楚：服务器端要负责通讯协议的制定工作，以免跟客户端推诿扯皮
	//服务器有能力站在客户端的角度去制定各种通讯协议；
	//商量，共同指定协议和数据结构；共同制定协议；

	//（4.2）客户端测试代码的调整
	//服务器端有责任把crc32算法给到客户端；

}


