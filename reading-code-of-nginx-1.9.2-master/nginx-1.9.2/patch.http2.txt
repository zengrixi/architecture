# HG changeset patch
# User Valentin Bartenev <vbart@nginx.com>
# Date 1441991586 -10800
#      Fri Sep 11 20:13:06 2015 +0300
# Node ID 461095b235effd921ca3c99abd3eb1332028a229
# Parent  5cb7e2eed2031e32d2e5422caf9402758c38a6ad
HTTP/2 implementation.

diff -r 5cb7e2eed203 -r 461095b235ef auto/make
--- a/auto/make	Tue Aug 18 18:16:17 2015 +0300
+++ b/auto/make	Fri Sep 11 20:13:06 2015 +0300
@@ -7,7 +7,7 @@ echo "creating $NGX_MAKEFILE"
 
 mkdir -p $NGX_OBJS/src/core $NGX_OBJS/src/event $NGX_OBJS/src/event/modules \
          $NGX_OBJS/src/os/unix $NGX_OBJS/src/os/win32 \
-         $NGX_OBJS/src/http $NGX_OBJS/src/http/modules \
+         $NGX_OBJS/src/http $NGX_OBJS/src/http/v2 $NGX_OBJS/src/http/modules \
          $NGX_OBJS/src/http/modules/perl \
          $NGX_OBJS/src/mail \
          $NGX_OBJS/src/stream \
diff -r 5cb7e2eed203 -r 461095b235ef auto/modules
--- a/auto/modules	Tue Aug 18 18:16:17 2015 +0300
+++ b/auto/modules	Fri Sep 11 20:13:06 2015 +0300
@@ -94,7 +94,7 @@ fi
 #     ngx_http_write_filter
 #     ngx_http_header_filter
 #     ngx_http_chunked_filter
-#     ngx_http_spdy_filter
+#     ngx_http_v2_filter
 #     ngx_http_range_header_filter
 #     ngx_http_gzip_filter
 #     ngx_http_postpone_filter
@@ -115,8 +115,8 @@ HTTP_FILTER_MODULES="$HTTP_WRITE_FILTER_
                      $HTTP_HEADER_FILTER_MODULE \
                      $HTTP_CHUNKED_FILTER_MODULE"
 
-if [ $HTTP_SPDY = YES ]; then
-    HTTP_FILTER_MODULES="$HTTP_FILTER_MODULES $HTTP_SPDY_FILTER_MODULE"
+if [ $HTTP_V2 = YES ]; then
+    HTTP_FILTER_MODULES="$HTTP_FILTER_MODULES $HTTP_V2_FILTER_MODULE"
 fi
 
 HTTP_FILTER_MODULES="$HTTP_FILTER_MODULES $HTTP_RANGE_HEADER_FILTER_MODULE"
@@ -180,12 +180,12 @@ if [ $HTTP_USERID = YES ]; then
 fi
 
 
-if [ $HTTP_SPDY = YES ]; then
-    have=NGX_HTTP_SPDY . auto/have
-    USE_ZLIB=YES
-    HTTP_MODULES="$HTTP_MODULES $HTTP_SPDY_MODULE"
-    HTTP_DEPS="$HTTP_DEPS $HTTP_SPDY_DEPS"
-    HTTP_SRCS="$HTTP_SRCS $HTTP_SPDY_SRCS"
+if [ $HTTP_V2 = YES ]; then
+    have=NGX_HTTP_V2 . auto/have
+    HTTP_MODULES="$HTTP_MODULES $HTTP_V2_MODULE"
+    HTTP_INCS="$HTTP_INCS $HTTP_V2_INCS"
+    HTTP_DEPS="$HTTP_DEPS $HTTP_V2_DEPS"
+    HTTP_SRCS="$HTTP_SRCS $HTTP_V2_SRCS"
 fi
 
 HTTP_MODULES="$HTTP_MODULES $HTTP_STATIC_MODULE"
diff -r 5cb7e2eed203 -r 461095b235ef auto/options
--- a/auto/options	Tue Aug 18 18:16:17 2015 +0300
+++ b/auto/options	Fri Sep 11 20:13:06 2015 +0300
@@ -58,7 +58,7 @@ HTTP_CACHE=YES
 HTTP_CHARSET=YES
 HTTP_GZIP=YES
 HTTP_SSL=NO
-HTTP_SPDY=NO
+HTTP_V2=NO
 HTTP_SSI=YES
 HTTP_POSTPONE=NO
 HTTP_REALIP=NO
@@ -210,7 +210,7 @@ do
         --http-scgi-temp-path=*)         NGX_HTTP_SCGI_TEMP_PATH="$value" ;;
 
         --with-http_ssl_module)          HTTP_SSL=YES               ;;
-        --with-http_spdy_module)         HTTP_SPDY=YES              ;;
+        --with-http_v2_module)           HTTP_V2=YES                ;;
         --with-http_realip_module)       HTTP_REALIP=YES            ;;
         --with-http_addition_module)     HTTP_ADDITION=YES          ;;
         --with-http_xslt_module)         HTTP_XSLT=YES              ;;
@@ -378,7 +378,7 @@ cat << END
   --with-ipv6                        enable IPv6 support
 
   --with-http_ssl_module             enable ngx_http_ssl_module
-  --with-http_spdy_module            enable ngx_http_spdy_module
+  --with-http_v2_module              enable ngx_http_v2_module
   --with-http_realip_module          enable ngx_http_realip_module
   --with-http_addition_module        enable ngx_http_addition_module
   --with-http_xslt_module            enable ngx_http_xslt_module
diff -r 5cb7e2eed203 -r 461095b235ef auto/sources
--- a/auto/sources	Tue Aug 18 18:16:17 2015 +0300
+++ b/auto/sources	Fri Sep 11 20:13:06 2015 +0300
@@ -317,13 +317,17 @@ HTTP_POSTPONE_FILTER_SRCS=src/http/ngx_h
 HTTP_FILE_CACHE_SRCS=src/http/ngx_http_file_cache.c
 
 
-HTTP_SPDY_MODULE=ngx_http_spdy_module
-HTTP_SPDY_FILTER_MODULE=ngx_http_spdy_filter_module
-HTTP_SPDY_DEPS="src/http/ngx_http_spdy.h \
-                src/http/ngx_http_spdy_module.h"
-HTTP_SPDY_SRCS="src/http/ngx_http_spdy.c \
-                src/http/ngx_http_spdy_module.c \
-                src/http/ngx_http_spdy_filter_module.c"
+HTTP_V2_MODULE=ngx_http_v2_module
+HTTP_V2_FILTER_MODULE=ngx_http_v2_filter_module
+HTTP_V2_INCS="src/http/v2"
+HTTP_V2_DEPS="src/http/v2/ngx_http_v2.h \
+              src/http/v2/ngx_http_v2_module.h"
+HTTP_V2_SRCS="src/http/v2/ngx_http_v2.c \
+              src/http/v2/ngx_http_v2_table.c \
+              src/http/v2/ngx_http_v2_huff_decode.c \
+              src/http/v2/ngx_http_v2_huff_encode.c \
+              src/http/v2/ngx_http_v2_module.c \
+              src/http/v2/ngx_http_v2_filter_module.c"
 
 
 HTTP_CHARSET_FILTER_MODULE=ngx_http_charset_filter_module
diff -r 5cb7e2eed203 -r 461095b235ef src/core/ngx_connection.h
--- a/src/core/ngx_connection.h	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/core/ngx_connection.h	Fri Sep 11 20:13:06 2015 +0300
@@ -118,7 +118,7 @@ typedef enum {
 
 #define NGX_LOWLEVEL_BUFFERED  0x0f
 #define NGX_SSL_BUFFERED       0x01
-#define NGX_SPDY_BUFFERED      0x02
+#define NGX_HTTP_V2_BUFFERED   0x02
 
 
 struct ngx_connection_s {
diff -r 5cb7e2eed203 -r 461095b235ef src/http/modules/ngx_http_ssl_module.c
--- a/src/http/modules/ngx_http_ssl_module.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/modules/ngx_http_ssl_module.c	Fri Sep 11 20:13:06 2015 +0300
@@ -326,10 +326,10 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t 
 #if (NGX_DEBUG)
     unsigned int            i;
 #endif
-#if (NGX_HTTP_SPDY)
+#if (NGX_HTTP_V2)
     ngx_http_connection_t  *hc;
 #endif
-#if (NGX_HTTP_SPDY || NGX_DEBUG)
+#if (NGX_HTTP_V2 || NGX_DEBUG)
     ngx_connection_t       *c;
 
     c = ngx_ssl_get_connection(ssl_conn);
@@ -342,12 +342,13 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t 
     }
 #endif
 
-#if (NGX_HTTP_SPDY)
+#if (NGX_HTTP_V2)
     hc = c->data;
 
-    if (hc->addr_conf->spdy) {
-        srv = (unsigned char *) NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
-        srvlen = sizeof(NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
+    if (hc->addr_conf->http2) {
+        srv =
+           (unsigned char *) NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
+        srvlen = sizeof(NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
 
     } else
 #endif
@@ -378,22 +379,23 @@ static int
 ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,
     const unsigned char **out, unsigned int *outlen, void *arg)
 {
-#if (NGX_HTTP_SPDY || NGX_DEBUG)
+#if (NGX_HTTP_V2 || NGX_DEBUG)
     ngx_connection_t  *c;
 
     c = ngx_ssl_get_connection(ssl_conn);
     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "SSL NPN advertised");
 #endif
 
-#if (NGX_HTTP_SPDY)
+#if (NGX_HTTP_V2)
     {
     ngx_http_connection_t  *hc;
 
     hc = c->data;
 
-    if (hc->addr_conf->spdy) {
-        *out = (unsigned char *) NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
-        *outlen = sizeof(NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
+    if (hc->addr_conf->http2) {
+        *out =
+            (unsigned char *) NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
+        *outlen = sizeof(NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
 
         return SSL_TLSEXT_ERR_OK;
     }
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http.c
--- a/src/http/ngx_http.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http.c	Fri Sep 11 20:13:06 2015 +0300
@@ -1233,8 +1233,8 @@ ngx_http_add_addresses(ngx_conf_t *cf, n
 #if (NGX_HTTP_SSL)
     ngx_uint_t             ssl;
 #endif
-#if (NGX_HTTP_SPDY)
-    ngx_uint_t             spdy;
+#if (NGX_HTTP_V2)
+    ngx_uint_t             http2;
 #endif
 
     /*
@@ -1290,8 +1290,8 @@ ngx_http_add_addresses(ngx_conf_t *cf, n
 #if (NGX_HTTP_SSL)
         ssl = lsopt->ssl || addr[i].opt.ssl;
 #endif
-#if (NGX_HTTP_SPDY)
-        spdy = lsopt->spdy || addr[i].opt.spdy;
+#if (NGX_HTTP_V2)
+        http2 = lsopt->http2 || addr[i].opt.http2;
 #endif
 
         if (lsopt->set) {
@@ -1324,8 +1324,8 @@ ngx_http_add_addresses(ngx_conf_t *cf, n
 #if (NGX_HTTP_SSL)
         addr[i].opt.ssl = ssl;
 #endif
-#if (NGX_HTTP_SPDY)
-        addr[i].opt.spdy = spdy;
+#if (NGX_HTTP_V2)
+        addr[i].opt.http2 = http2;
 #endif
 
         return NGX_OK;
@@ -1357,14 +1357,17 @@ ngx_http_add_address(ngx_conf_t *cf, ngx
         }
     }
 
-#if (NGX_HTTP_SPDY && NGX_HTTP_SSL                                            \
+#if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \
      && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \
      && !defined TLSEXT_TYPE_next_proto_neg)
-    if (lsopt->spdy && lsopt->ssl) {
+
+    if (lsopt->http2 && lsopt->ssl) {
         ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
-                           "nginx was built without OpenSSL ALPN or NPN "
-                           "support, SPDY is not enabled for %s", lsopt->addr);
+                           "nginx was built with OpenSSL that lacks ALPN "
+                           "and NPN support, HTTP/2 is not enabled for %s",
+                           lsopt->addr);
     }
+
 #endif
 
     addr = ngx_array_push(&port->addrs);
@@ -1856,8 +1859,8 @@ ngx_http_add_addrs(ngx_conf_t *cf, ngx_h
 #if (NGX_HTTP_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
 #endif
-#if (NGX_HTTP_SPDY)
-        addrs[i].conf.spdy = addr[i].opt.spdy;
+#if (NGX_HTTP_V2)
+        addrs[i].conf.http2 = addr[i].opt.http2;
 #endif
         addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
 
@@ -1921,8 +1924,8 @@ ngx_http_add_addrs6(ngx_conf_t *cf, ngx_
 #if (NGX_HTTP_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
 #endif
-#if (NGX_HTTP_SPDY)
-        addrs6[i].conf.spdy = addr[i].opt.spdy;
+#if (NGX_HTTP_V2)
+        addrs6[i].conf.http2 = addr[i].opt.http2;
 #endif
 
         if (addr[i].hash.buckets == NULL
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http.h
--- a/src/http/ngx_http.h	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http.h	Fri Sep 11 20:13:06 2015 +0300
@@ -20,8 +20,8 @@ typedef struct ngx_http_file_cache_s  ng
 typedef struct ngx_http_log_ctx_s     ngx_http_log_ctx_t;
 typedef struct ngx_http_chunked_s     ngx_http_chunked_t;
 
-#if (NGX_HTTP_SPDY)
-typedef struct ngx_http_spdy_stream_s  ngx_http_spdy_stream_t;
+#if (NGX_HTTP_V2)
+typedef struct ngx_http_v2_stream_s   ngx_http_v2_stream_t;
 #endif
 
 typedef ngx_int_t (*ngx_http_header_handler_pt)(ngx_http_request_t *r,
@@ -38,8 +38,8 @@ typedef u_char *(*ngx_http_log_handler_p
 #include <ngx_http_upstream_round_robin.h>
 #include <ngx_http_core_module.h>
 
-#if (NGX_HTTP_SPDY)
-#include <ngx_http_spdy.h>
+#if (NGX_HTTP_V2)
+#include <ngx_http_v2.h>
 #endif
 #if (NGX_HTTP_CACHE)
 #include <ngx_http_cache.h>
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_core_module.c
--- a/src/http/ngx_http_core_module.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_core_module.c	Fri Sep 11 20:13:06 2015 +0300
@@ -2132,13 +2132,6 @@ ngx_http_gzip_ok(ngx_http_request_t *r)
         return NGX_DECLINED;
     }
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
-        r->gzip_ok = 1;
-        return NGX_OK;
-    }
-#endif
-
     ae = r->headers_in.accept_encoding;
     if (ae == NULL) {
         return NGX_DECLINED;
@@ -2473,8 +2466,8 @@ ngx_http_subrequest(ngx_http_request_t *
 
     sr->request_body = r->request_body;
 
-#if (NGX_HTTP_SPDY)
-    sr->spdy_stream = r->spdy_stream;
+#if (NGX_HTTP_V2)
+    sr->stream = r->stream;
 #endif
 
     sr->method = NGX_HTTP_GET;
@@ -4195,18 +4188,26 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx
 #endif
         }
 
-        if (ngx_strcmp(value[n].data, "spdy") == 0) {
-#if (NGX_HTTP_SPDY)
-            lsopt.spdy = 1;
+        if (ngx_strcmp(value[n].data, "http2") == 0) {
+#if (NGX_HTTP_V2)
+            lsopt.http2 = 1;
             continue;
 #else
             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
-                               "the \"spdy\" parameter requires "
-                               "ngx_http_spdy_module");
+                               "the \"http2\" parameter requires "
+                               "ngx_http_v2_module");
             return NGX_CONF_ERROR;
 #endif
         }
 
+        if (ngx_strcmp(value[n].data, "spdy") == 0) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid parameter \"spdy\": "
+                               "the SPDY module was deprecated, "
+                               "use the HTTP/2 module instead");
+            return NGX_CONF_ERROR;
+        }
+
         if (ngx_strncmp(value[n].data, "so_keepalive=", 13) == 0) {
 
             if (ngx_strcmp(&value[n].data[13], "on") == 0) {
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_core_module.h
--- a/src/http/ngx_http_core_module.h	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_core_module.h	Fri Sep 11 20:13:06 2015 +0300
@@ -79,8 +79,8 @@ typedef struct {
 #if (NGX_HTTP_SSL)
     unsigned                   ssl:1;
 #endif
-#if (NGX_HTTP_SPDY)
-    unsigned                   spdy:1;
+#if (NGX_HTTP_V2)
+    unsigned                   http2:1;
 #endif
 #if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)
     unsigned                   ipv6only:1;
@@ -248,8 +248,8 @@ struct ngx_http_addr_conf_s {
 #if (NGX_HTTP_SSL)
     unsigned                   ssl:1;
 #endif
-#if (NGX_HTTP_SPDY)
-    unsigned                   spdy:1;
+#if (NGX_HTTP_V2)
+    unsigned                   http2:1;
 #endif
     unsigned                   proxy_protocol:1;
 };
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_request.c
--- a/src/http/ngx_http_request.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_request.c	Fri Sep 11 20:13:06 2015 +0300
@@ -312,9 +312,9 @@ ngx_http_init_connection(ngx_connection_
     rev->handler = ngx_http_wait_request_handler;
     c->write->handler = ngx_http_empty_handler;
 
-#if (NGX_HTTP_SPDY)
-    if (hc->addr_conf->spdy) {
-        rev->handler = ngx_http_spdy_init;
+#if (NGX_HTTP_V2)
+    if (hc->addr_conf->http2) {
+        rev->handler = ngx_http_v2_init;
     }
 #endif
 
@@ -764,13 +764,12 @@ ngx_http_ssl_handshake_handler(ngx_conne
 
         c->ssl->no_wait_shutdown = 1;
 
-#if (NGX_HTTP_SPDY                                                            \
+#if (NGX_HTTP_V2                                                              \
      && (defined TLSEXT_TYPE_application_layer_protocol_negotiation           \
          || defined TLSEXT_TYPE_next_proto_neg))
         {
-        unsigned int             len;
-        const unsigned char     *data;
-        static const ngx_str_t   spdy = ngx_string(NGX_SPDY_NPN_NEGOTIATED);
+        unsigned int          len;
+        const unsigned char  *data;
 
 #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation
         SSL_get0_alpn_selected(c->ssl->connection, &data, &len);
@@ -785,8 +784,8 @@ ngx_http_ssl_handshake_handler(ngx_conne
         SSL_get0_next_proto_negotiated(c->ssl->connection, &data, &len);
 #endif
 
-        if (len == spdy.len && ngx_strncmp(data, spdy.data, spdy.len) == 0) {
-            ngx_http_spdy_init(c->read);
+        if (len == 2 && data[0] == 'h' && data[1] == '2') {
+            ngx_http_v2_init(c->read);
             return;
         }
         }
@@ -2500,8 +2499,8 @@ ngx_http_finalize_connection(ngx_http_re
 {
     ngx_http_core_loc_conf_t  *clcf;
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+    if (r->stream) {
         ngx_http_close_request(r, 0);
         return;
     }
@@ -2566,8 +2565,8 @@ ngx_http_set_write_handler(ngx_http_requ
                                 ngx_http_test_reading;
     r->write_event_handler = ngx_http_writer;
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+    if (r->stream) {
         return NGX_OK;
     }
 #endif
@@ -2657,8 +2656,8 @@ ngx_http_writer(ngx_http_request_t *r)
 
     if (r->buffered || r->postponed || (r == r->main && c->buffered)) {
 
-#if (NGX_HTTP_SPDY)
-        if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+        if (r->stream) {
             return;
         }
 #endif
@@ -2725,9 +2724,9 @@ ngx_http_test_reading(ngx_http_request_t
 
     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "http test reading");
 
-#if (NGX_HTTP_SPDY)
-
-    if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+
+    if (r->stream) {
         if (c->error) {
             err = 0;
             goto closed;
@@ -3400,9 +3399,9 @@ ngx_http_close_request(ngx_http_request_
         return;
     }
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
-        ngx_http_spdy_close_stream(r->spdy_stream, rc);
+#if (NGX_HTTP_V2)
+    if (r->stream) {
+        ngx_http_v2_close_stream(r->stream, rc);
         return;
     }
 #endif
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_request.h
--- a/src/http/ngx_http_request.h	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_request.h	Fri Sep 11 20:13:06 2015 +0300
@@ -23,6 +23,7 @@
 #define NGX_HTTP_VERSION_9                 9
 #define NGX_HTTP_VERSION_10                1000
 #define NGX_HTTP_VERSION_11                1001
+#define NGX_HTTP_VERSION_20                2000
 
 #define NGX_HTTP_UNKNOWN                   0x0001
 #define NGX_HTTP_GET                       0x0002
@@ -431,8 +432,8 @@ struct ngx_http_request_s {
     ngx_uint_t                        err_status;
 
     ngx_http_connection_t            *http_connection;
-#if (NGX_HTTP_SPDY)
-    ngx_http_spdy_stream_t           *spdy_stream;
+#if (NGX_HTTP_V2)
+    ngx_http_v2_stream_t             *stream;
 #endif
 
     ngx_http_log_handler_pt           log_handler;
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_request_body.c
--- a/src/http/ngx_http_request_body.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_request_body.c	Fri Sep 11 20:13:06 2015 +0300
@@ -40,10 +40,10 @@ ngx_http_read_client_request_body(ngx_ht
 
     r->main->count++;
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream && r == r->main) {
+#if (NGX_HTTP_V2)
+    if (r->stream && r == r->main) {
         r->request_body_no_buffering = 0;
-        rc = ngx_http_spdy_read_request_body(r, post_handler);
+        rc = ngx_http_v2_read_request_body(r, post_handler);
         goto done;
     }
 #endif
@@ -570,9 +570,9 @@ ngx_http_discard_request_body(ngx_http_r
     ngx_int_t     rc;
     ngx_event_t  *rev;
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream && r == r->main) {
-        r->spdy_stream->skip_data = NGX_SPDY_DATA_DISCARD;
+#if (NGX_HTTP_V2)
+    if (r->stream && r == r->main) {
+        r->stream->skip_data = NGX_HTTP_V2_DATA_DISCARD;
         return NGX_OK;
     }
 #endif
diff -r 5cb7e2eed203 -r 461095b235ef src/http/ngx_http_upstream.c
--- a/src/http/ngx_http_upstream.c	Tue Aug 18 18:16:17 2015 +0300
+++ b/src/http/ngx_http_upstream.c	Fri Sep 11 20:13:06 2015 +0300
@@ -475,8 +475,8 @@ ngx_http_upstream_init(ngx_http_request_
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
                    "http init upstream, client timer: %d", c->read->timer_set);
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+    if (r->stream) {
         ngx_http_upstream_init_request(r);
         return;
     }
@@ -1148,8 +1148,8 @@ ngx_http_upstream_check_broken_connectio
         return;
     }
 
-#if (NGX_HTTP_SPDY)
-    if (r->spdy_stream) {
+#if (NGX_HTTP_V2)
+    if (r->stream) {
         return;
     }
 #endif
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,3964 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <ngx_http_v2_module.h>
+
+
+/* errors */
+#define NGX_HTTP_V2_NO_ERROR                     0x0
+#define NGX_HTTP_V2_PROTOCOL_ERROR               0x1
+#define NGX_HTTP_V2_INTERNAL_ERROR               0x2
+#define NGX_HTTP_V2_FLOW_CTRL_ERROR              0x3
+#define NGX_HTTP_V2_SETTINGS_TIMEOUT             0x4
+#define NGX_HTTP_V2_STREAM_CLOSED                0x5
+#define NGX_HTTP_V2_SIZE_ERROR                   0x6
+#define NGX_HTTP_V2_REFUSED_STREAM               0x7
+#define NGX_HTTP_V2_CANCEL                       0x8
+#define NGX_HTTP_V2_COMP_ERROR                   0x9
+#define NGX_HTTP_V2_CONNECT_ERROR                0xa
+#define NGX_HTTP_V2_ENHANCE_YOUR_CALM            0xb
+#define NGX_HTTP_V2_INADEQUATE_SECURITY          0xc
+#define NGX_HTTP_V2_HTTP_1_1_REQUIRED            0xd
+
+/* frame sizes */
+#define NGX_HTTP_V2_RST_STREAM_SIZE              4
+#define NGX_HTTP_V2_PRIORITY_SIZE                5
+#define NGX_HTTP_V2_PING_SIZE                    8
+#define NGX_HTTP_V2_GOAWAY_SIZE                  8
+#define NGX_HTTP_V2_WINDOW_UPDATE_SIZE           4
+
+#define NGX_HTTP_V2_STREAM_ID_SIZE               4
+
+#define NGX_HTTP_V2_SETTINGS_PARAM_SIZE          6
+
+/* settings fields */
+#define NGX_HTTP_V2_HEADER_TABLE_SIZE_SETTING    0x1
+#define NGX_HTTP_V2_MAX_STREAMS_SETTING          0x3
+#define NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING     0x4
+#define NGX_HTTP_V2_MAX_FRAME_SIZE_SETTING       0x5
+
+#define NGX_HTTP_V2_FRAME_BUFFER_SIZE            24
+
+#define NGX_HTTP_V2_DEFAULT_FRAME_SIZE           (1 << 14)
+
+#define NGX_HTTP_V2_MAX_WINDOW                   ((1U << 31) - 1)
+#define NGX_HTTP_V2_DEFAULT_WINDOW               65535
+
+#define NGX_HTTP_V2_ROOT                         (void *) -1
+
+
+static void ngx_http_v2_read_handler(ngx_event_t *rev);
+static void ngx_http_v2_write_handler(ngx_event_t *wev);
+static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);
+
+static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_head(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_header_block(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_field_raw(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_field_skip(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_priority(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_rst_stream(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_settings_params(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_push_promise(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_window_update(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_continuation(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_complete(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_skip_padded(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_skip(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_skip_headers(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+static u_char *ngx_http_v2_state_save(ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end, ngx_http_v2_handler_pt handler);
+static u_char *ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t err);
+
+static ngx_int_t ngx_http_v2_parse_int(ngx_http_v2_connection_t *h2c,
+    u_char **pos, u_char *end, ngx_uint_t prefix);
+
+static ngx_http_v2_stream_t *ngx_http_v2_create_stream(
+    ngx_http_v2_connection_t *h2c);
+static ngx_http_v2_node_t *ngx_http_v2_get_node_by_id(
+    ngx_http_v2_connection_t *h2c, ngx_uint_t sid, ngx_uint_t alloc);
+static ngx_http_v2_node_t *ngx_http_v2_get_closed_node(
+    ngx_http_v2_connection_t *h2c);
+#define ngx_http_v2_index_size(h2scf)  (h2scf->streams_index_mask + 1)
+#define ngx_http_v2_index(h2scf, sid)  ((sid >> 1) & h2scf->streams_index_mask)
+
+static ngx_int_t ngx_http_v2_send_settings(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t ack);
+static ngx_int_t ngx_http_v2_settings_frame_handler(
+    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);
+static ngx_int_t ngx_http_v2_send_window_update(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t sid, size_t window);
+static ngx_int_t ngx_http_v2_send_rst_stream(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t sid, ngx_uint_t status);
+
+static ngx_http_v2_out_frame_t *ngx_http_v2_get_frame(
+    ngx_http_v2_connection_t *h2c, size_t length, ngx_uint_t type,
+    u_char flags, ngx_uint_t sid);
+static ngx_int_t ngx_http_v2_frame_handler(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame);
+
+static ngx_int_t ngx_http_v2_validate_header(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_pseudo_header(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_parse_path(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_parse_method(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_parse_scheme(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_parse_authority(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_construct_request_line(ngx_http_request_t *r);
+static ngx_int_t ngx_http_v2_cookie(ngx_http_request_t *r,
+    ngx_http_v2_header_t *header);
+static ngx_int_t ngx_http_v2_construct_cookie_header(ngx_http_request_t *r);
+static void ngx_http_v2_run_request(ngx_http_request_t *r);
+static ngx_int_t ngx_http_v2_init_request_body(ngx_http_request_t *r);
+
+static ngx_int_t ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream, ngx_uint_t status);
+static void ngx_http_v2_close_stream_handler(ngx_event_t *ev);
+static void ngx_http_v2_handle_connection_handler(ngx_event_t *rev);
+static void ngx_http_v2_idle_handler(ngx_event_t *rev);
+static void ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t status);
+
+static ngx_int_t ngx_http_v2_adjust_windows(ngx_http_v2_connection_t *h2c,
+    ssize_t delta);
+static void ngx_http_v2_set_dependency(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_node_t *node, ngx_uint_t depend, ngx_uint_t exclusive);
+static void ngx_http_v2_node_children_update(ngx_http_v2_node_t *node);
+
+static void ngx_http_v2_pool_cleanup(void *data);
+
+
+static ngx_http_v2_handler_pt ngx_http_v2_frame_states[] = {
+    ngx_http_v2_state_data,
+    ngx_http_v2_state_headers,
+    ngx_http_v2_state_priority,
+    ngx_http_v2_state_rst_stream,
+    ngx_http_v2_state_settings,
+    ngx_http_v2_state_push_promise,
+    ngx_http_v2_state_ping,
+    ngx_http_v2_state_goaway,
+    ngx_http_v2_state_window_update,
+    ngx_http_v2_state_continuation
+};
+
+#define NGX_HTTP_V2_FRAME_STATES                                              \
+    (sizeof(ngx_http_v2_frame_states) / sizeof(ngx_http_v2_handler_pt))
+
+
+void
+ngx_http_v2_init(ngx_event_t *rev)
+{
+    ngx_connection_t          *c;
+    ngx_pool_cleanup_t        *cln;
+    ngx_http_connection_t     *hc;
+    ngx_http_v2_srv_conf_t    *h2scf;
+    ngx_http_v2_main_conf_t   *h2mcf;
+    ngx_http_v2_connection_t  *h2c;
+
+    c = rev->data;
+    hc = c->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "init http2 connection");
+
+    c->log->action = "processing HTTP/2 connection";
+
+    h2mcf = ngx_http_get_module_main_conf(hc->conf_ctx, ngx_http_v2_module);
+
+    if (h2mcf->recv_buffer == NULL) {
+        h2mcf->recv_buffer = ngx_palloc(ngx_cycle->pool,
+                                        h2mcf->recv_buffer_size);
+        if (h2mcf->recv_buffer == NULL) {
+            ngx_http_close_connection(c);
+            return;
+        }
+    }
+
+    h2c = ngx_pcalloc(c->pool, sizeof(ngx_http_v2_connection_t));
+    if (h2c == NULL) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    h2c->connection = c;
+    h2c->http_connection = hc;
+
+    h2c->send_window = NGX_HTTP_V2_DEFAULT_WINDOW;
+    h2c->recv_window = NGX_HTTP_V2_MAX_WINDOW;
+
+    h2c->init_window = NGX_HTTP_V2_DEFAULT_WINDOW;
+
+    h2c->frame_size = NGX_HTTP_V2_DEFAULT_FRAME_SIZE;
+
+    h2scf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_v2_module);
+
+    h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);
+    if (h2c->pool == NULL) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    cln = ngx_pool_cleanup_add(c->pool, sizeof(ngx_pool_cleanup_file_t));
+    if (cln == NULL) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    cln->handler = ngx_http_v2_pool_cleanup;
+    cln->data = h2c;
+
+    h2c->streams_index = ngx_pcalloc(c->pool, ngx_http_v2_index_size(h2scf)
+                                              * sizeof(ngx_http_v2_node_t *));
+    if (h2c->streams_index == NULL) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    if (ngx_http_v2_send_settings(h2c, 0) == NGX_ERROR) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    if (ngx_http_v2_send_window_update(h2c, 0, NGX_HTTP_V2_MAX_WINDOW
+                                               - NGX_HTTP_V2_DEFAULT_WINDOW)
+        == NGX_ERROR)
+    {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    h2c->state.handler = hc->proxy_protocol ? ngx_http_v2_state_proxy_protocol
+                                            : ngx_http_v2_state_preface;
+
+    ngx_queue_init(&h2c->waiting);
+    ngx_queue_init(&h2c->posted);
+    ngx_queue_init(&h2c->dependencies);
+    ngx_queue_init(&h2c->closed);
+
+    c->data = h2c;
+
+    rev->handler = ngx_http_v2_read_handler;
+    c->write->handler = ngx_http_v2_write_handler;
+
+    ngx_http_v2_read_handler(rev);
+}
+
+
+static void
+ngx_http_v2_read_handler(ngx_event_t *rev)
+{
+    u_char                    *p, *end;
+    size_t                     available;
+    ssize_t                    n;
+    ngx_connection_t          *c;
+    ngx_http_v2_main_conf_t   *h2mcf;
+    ngx_http_v2_connection_t  *h2c;
+
+    c = rev->data;
+    h2c = c->data;
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
+        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "http2 read handler");
+
+    h2c->blocked = 1;
+
+    h2mcf = ngx_http_get_module_main_conf(h2c->http_connection->conf_ctx,
+                                          ngx_http_v2_module);
+
+    available = h2mcf->recv_buffer_size - 2 * NGX_HTTP_V2_STATE_BUFFER_SIZE;
+
+    do {
+        p = h2mcf->recv_buffer;
+
+        ngx_memcpy(p, h2c->state.buffer, NGX_HTTP_V2_STATE_BUFFER_SIZE);
+        end = p + h2c->state.buffer_used;
+
+        n = c->recv(c, end, available);
+
+        if (n == NGX_AGAIN) {
+            break;
+        }
+
+        if (n == 0 && (h2c->state.incomplete || h2c->processing)) {
+            ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                          "client prematurely closed connection");
+        }
+
+        if (n == 0 || n == NGX_ERROR) {
+            c->error = 1;
+            ngx_http_v2_finalize_connection(h2c, 0);
+            return;
+        }
+
+        end += n;
+
+        h2c->state.buffer_used = 0;
+        h2c->state.incomplete = 0;
+
+        do {
+            p = h2c->state.handler(h2c, p, end);
+
+            if (p == NULL) {
+                return;
+            }
+
+        } while (p != end);
+
+    } while (rev->ready);
+
+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+        return;
+    }
+
+    if (h2c->last_out && ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {
+        ngx_http_v2_finalize_connection(h2c, 0);
+        return;
+    }
+
+    h2c->blocked = 0;
+
+    if (h2c->processing) {
+        if (rev->timer_set) {
+            ngx_del_timer(rev);
+        }
+
+        return;
+    }
+
+    ngx_http_v2_handle_connection(h2c);
+}
+
+
+static void
+ngx_http_v2_write_handler(ngx_event_t *wev)
+{
+    ngx_int_t                  rc;
+    ngx_queue_t               *q;
+    ngx_connection_t          *c;
+    ngx_http_v2_stream_t      *stream;
+    ngx_http_v2_connection_t  *h2c;
+
+    c = wev->data;
+    h2c = c->data;
+
+    if (wev->timedout) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "http2 write event timed out");
+        c->error = 1;
+        ngx_http_v2_finalize_connection(h2c, 0);
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "http2 write handler");
+
+    h2c->blocked = 1;
+
+    rc = ngx_http_v2_send_output_queue(h2c);
+
+    if (rc == NGX_ERROR) {
+        ngx_http_v2_finalize_connection(h2c, 0);
+        return;
+    }
+
+    while (!ngx_queue_empty(&h2c->posted)) {
+        q = ngx_queue_head(&h2c->posted);
+
+        ngx_queue_remove(q);
+
+        stream = ngx_queue_data(q, ngx_http_v2_stream_t, queue);
+
+        stream->handled = 0;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "run http2 stream %ui", stream->node->id);
+
+        wev = stream->request->connection->write;
+        wev->handler(wev);
+    }
+
+    h2c->blocked = 0;
+
+    if (rc == NGX_AGAIN) {
+        return;
+    }
+
+    ngx_http_v2_handle_connection(h2c);
+}
+
+
+ngx_int_t
+ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c)
+{
+    int                        tcp_nodelay;
+    ngx_chain_t               *cl;
+    ngx_event_t               *wev;
+    ngx_connection_t          *c;
+    ngx_http_v2_out_frame_t   *out, *frame, *fn;
+    ngx_http_core_loc_conf_t  *clcf;
+
+    c = h2c->connection;
+
+    if (c->error) {
+        return NGX_ERROR;
+    }
+
+    wev = c->write;
+
+    if (!wev->ready) {
+        return NGX_OK;
+    }
+
+    cl = NULL;
+    out = NULL;
+
+    for (frame = h2c->last_out; frame; frame = fn) {
+        frame->last->next = cl;
+        cl = frame->first;
+
+        fn = frame->next;
+        frame->next = out;
+        out = frame;
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "http2 frame out: %p sid:%ui bl:%d len:%uz",
+                       out, out->stream ? out->stream->node->id : 0,
+                       out->blocked, out->length);
+    }
+
+    cl = c->send_chain(c, cl, 0);
+
+    if (cl == NGX_CHAIN_ERROR) {
+        goto error;
+    }
+
+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,
+                                        ngx_http_core_module);
+
+    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {
+        goto error;
+    }
+
+    if (c->tcp_nopush == NGX_TCP_NOPUSH_SET) {
+        if (ngx_tcp_push(c->fd) == -1) {
+            ngx_connection_error(c, ngx_socket_errno, ngx_tcp_push_n " failed");
+            goto error;
+        }
+
+        c->tcp_nopush = NGX_TCP_NOPUSH_UNSET;
+        tcp_nodelay = ngx_tcp_nodelay_and_tcp_nopush ? 1 : 0;
+
+    } else {
+        tcp_nodelay = 1;
+    }
+
+    if (tcp_nodelay
+        && clcf->tcp_nodelay
+        && c->tcp_nodelay == NGX_TCP_NODELAY_UNSET)
+    {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "tcp_nodelay");
+
+        if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
+                       (const void *) &tcp_nodelay, sizeof(int))
+            == -1)
+        {
+#if (NGX_SOLARIS)
+            /* Solaris returns EINVAL if a socket has been shut down */
+            c->log_error = NGX_ERROR_IGNORE_EINVAL;
+#endif
+
+            ngx_connection_error(c, ngx_socket_errno,
+                                 "setsockopt(TCP_NODELAY) failed");
+
+            c->log_error = NGX_ERROR_INFO;
+            goto error;
+        }
+
+        c->tcp_nodelay = NGX_TCP_NODELAY_SET;
+    }
+
+    if (cl) {
+        ngx_add_timer(wev, clcf->send_timeout);
+
+    } else {
+        if (wev->timer_set) {
+            ngx_del_timer(wev);
+        }
+    }
+
+    for ( /* void */ ; out; out = fn) {
+        fn = out->next;
+
+        if (out->handler(h2c, out) != NGX_OK) {
+            out->blocked = 1;
+            break;
+        }
+
+        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "http2 frame sent: %p sid:%ui bl:%d len:%uz",
+                       out, out->stream ? out->stream->node->id : 0,
+                       out->blocked, out->length);
+    }
+
+    frame = NULL;
+
+    for ( /* void */ ; out; out = fn) {
+        fn = out->next;
+        out->next = frame;
+        frame = out;
+    }
+
+    h2c->last_out = frame;
+
+    return NGX_OK;
+
+error:
+
+    c->error = 1;
+
+    if (!h2c->blocked) {
+        ngx_post_event(wev, &ngx_posted_events);
+    }
+
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)
+{
+    ngx_connection_t          *c;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    if (h2c->last_out || h2c->processing) {
+        return;
+    }
+
+    c = h2c->connection;
+
+    if (c->error) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    if (c->buffered) {
+        return;
+    }
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+    if (h2c->state.incomplete) {
+        ngx_add_timer(c->read, h2scf->recv_timeout);
+        return;
+    }
+
+    if (ngx_terminate || ngx_exiting) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    ngx_destroy_pool(h2c->pool);
+
+    h2c->pool = NULL;
+    h2c->free_frames = NULL;
+    h2c->free_fake_connections = NULL;
+
+#if (NGX_HTTP_SSL)
+    if (c->ssl) {
+        ngx_ssl_free_buffer(c);
+    }
+#endif
+
+    c->destroyed = 1;
+    c->idle = 1;
+    ngx_reusable_connection(c, 1);
+
+    c->write->handler = ngx_http_empty_handler;
+    c->read->handler = ngx_http_v2_idle_handler;
+
+    if (c->write->timer_set) {
+        ngx_del_timer(c->write);
+    }
+
+    ngx_add_timer(c->read, h2scf->idle_timeout);
+}
+
+
+static u_char *
+ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_log_t  *log;
+
+    log = h2c->connection->log;
+    log->action = "reading PROXY protocol";
+
+    pos = ngx_proxy_protocol_read(h2c->connection, pos, end);
+
+    log->action = "processing HTTP/2 connection";
+
+    if (pos == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    return ngx_http_v2_state_preface(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    static const u_char preface[] = "PRI * HTTP/2.0\r\n";
+
+    if ((size_t) (end - pos) < sizeof(preface) - 1) {
+        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_preface);
+    }
+
+    if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "invalid http2 connection preface \"%*s\"",
+                       sizeof(preface) - 1, pos);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    return ngx_http_v2_state_preface_end(h2c, pos + sizeof(preface) - 1, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    static const u_char preface[] = "\r\nSM\r\n\r\n";
+
+    if ((size_t) (end - pos) < sizeof(preface) - 1) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_preface_end);
+    }
+
+    if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "invalid http2 connection preface \"%*s\"",
+                       sizeof(preface) - 1, pos);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 preface verified");
+
+    return ngx_http_v2_state_head(h2c, pos + sizeof(preface) - 1, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_head(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
+{
+    uint32_t    head;
+    ngx_uint_t  type;
+
+    if (end - pos < NGX_HTTP_V2_FRAME_HEADER_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_head);
+    }
+
+    head = ngx_http_v2_parse_uint32(pos);
+
+    h2c->state.length = ngx_http_v2_parse_length(head);
+    h2c->state.flags = pos[4];
+
+    h2c->state.sid = ngx_http_v2_parse_sid(&pos[5]);
+
+    pos += NGX_HTTP_V2_FRAME_HEADER_SIZE;
+
+    type = ngx_http_v2_parse_type(head);
+
+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "process http2 frame type:%ui f:%Xd l:%uz sid:%ui",
+                   type, h2c->state.flags, h2c->state.length, h2c->state.sid);
+
+    if (type >= NGX_HTTP_V2_FRAME_STATES) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "http2 frame with unknown type %ui", type);
+        return ngx_http_v2_state_skip(h2c, pos, end);
+    }
+
+    return ngx_http_v2_frame_states[type](h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
+{
+    ngx_http_v2_node_t    *node;
+    ngx_http_v2_stream_t  *stream;
+
+    if (h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG) {
+
+        if (h2c->state.length == 0) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client sent padded DATA frame "
+                          "with incorrect length: %uz",
+                          h2c->state.length);
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+        }
+
+        if (end - pos == 0) {
+            return ngx_http_v2_state_save(h2c, pos, end,
+                                          ngx_http_v2_state_data);
+        }
+
+        h2c->state.padding = *pos++;
+        h2c->state.length--;
+
+        if (h2c->state.padding > h2c->state.length) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client sent padded DATA frame "
+                          "with incorrect length: %uz, padding: %uz",
+                          h2c->state.length, h2c->state.padding);
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+        }
+
+        h2c->state.length -= h2c->state.padding;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 DATA frame");
+
+    if (h2c->state.length > h2c->recv_window) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client violated connection flow control: "
+                      "received DATA frame length %uz, available window %uz",
+                      h2c->state.length, h2c->recv_window);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_FLOW_CTRL_ERROR);
+    }
+
+    h2c->recv_window -= h2c->state.length;
+
+    if (h2c->recv_window < NGX_HTTP_V2_MAX_WINDOW / 4) {
+
+        if (ngx_http_v2_send_window_update(h2c, 0, NGX_HTTP_V2_MAX_WINDOW
+                                                   - h2c->recv_window)
+            == NGX_ERROR)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        h2c->recv_window = NGX_HTTP_V2_MAX_WINDOW;
+    }
+
+    node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 0);
+
+    if (node == NULL || node->stream == NULL) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "unknown http2 stream");
+
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    stream = node->stream;
+
+    if (h2c->state.length > stream->recv_window) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client violated flow control for stream %ui: "
+                      "received DATA frame length %uz, available window %uz",
+                      node->id, h2c->state.length, stream->recv_window);
+
+        if (ngx_http_v2_terminate_stream(h2c, stream,
+                                         NGX_HTTP_V2_FLOW_CTRL_ERROR)
+            == NGX_ERROR)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    stream->recv_window -= h2c->state.length;
+
+    if (stream->recv_window < NGX_HTTP_V2_MAX_WINDOW / 4) {
+
+        if (ngx_http_v2_send_window_update(h2c, node->id,
+                                           NGX_HTTP_V2_MAX_WINDOW
+                                           - stream->recv_window)
+            == NGX_ERROR)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        stream->recv_window = NGX_HTTP_V2_MAX_WINDOW;
+    }
+
+    if (stream->in_closed) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent DATA frame for half-closed stream %ui",
+                      node->id);
+
+        if (ngx_http_v2_terminate_stream(h2c, stream,
+                                         NGX_HTTP_V2_STREAM_CLOSED)
+            == NGX_ERROR)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    h2c->state.stream = stream;
+
+    return ngx_http_v2_state_read_data(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t                     size;
+    ssize_t                    n;
+    ngx_buf_t                 *buf;
+    ngx_int_t                  rc;
+    ngx_temp_file_t           *tf;
+    ngx_http_request_t        *r;
+    ngx_http_v2_stream_t      *stream;
+    ngx_http_request_body_t   *rb;
+    ngx_http_core_loc_conf_t  *clcf;
+
+    stream = h2c->state.stream;
+
+    if (stream == NULL) {
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    if (stream->skip_data) {
+        stream->in_closed = h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "skipping http2 DATA frame, reason: %d",
+                       stream->skip_data);
+
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    size = end - pos;
+
+    if (size > h2c->state.length) {
+        size = h2c->state.length;
+    }
+
+    r = stream->request;
+
+    if (r->request_body == NULL
+        && ngx_http_v2_init_request_body(r) != NGX_OK)
+    {
+        stream->skip_data = NGX_HTTP_V2_DATA_INTERNAL_ERROR;
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    rb = r->request_body;
+    tf = rb->temp_file;
+    buf = rb->buf;
+
+    if (size) {
+        rb->rest += size;
+
+        if (r->headers_in.content_length_n != -1
+            && r->headers_in.content_length_n < rb->rest)
+        {
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client intended to send body data "
+                          "larger than declared");
+
+            stream->skip_data = NGX_HTTP_V2_DATA_ERROR;
+            goto error;
+
+        } else {
+            clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+            if (clcf->client_max_body_size
+                && clcf->client_max_body_size < rb->rest)
+            {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                              "client intended to send "
+                              "too large chunked body: %O bytes", rb->rest);
+
+                stream->skip_data = NGX_HTTP_V2_DATA_ERROR;
+                goto error;
+            }
+        }
+
+        h2c->state.length -= size;
+
+        if (tf) {
+            buf->start = pos;
+            buf->pos = pos;
+
+            pos += size;
+
+            buf->end = pos;
+            buf->last = pos;
+
+            n = ngx_write_chain_to_temp_file(tf, rb->bufs);
+
+            /* TODO: n == 0 or not complete and level event */
+
+            if (n == NGX_ERROR) {
+                stream->skip_data = NGX_HTTP_V2_DATA_INTERNAL_ERROR;
+                goto error;
+            }
+
+            tf->offset += n;
+
+        } else {
+            buf->last = ngx_cpymem(buf->last, pos, size);
+            pos += size;
+        }
+
+        r->request_length += size;
+    }
+
+    if (h2c->state.length) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_read_data);
+    }
+
+    if (h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG) {
+        stream->in_closed = 1;
+
+        if (r->headers_in.content_length_n < 0) {
+            r->headers_in.content_length_n = rb->rest;
+
+        } else if (r->headers_in.content_length_n != rb->rest) {
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client prematurely closed stream: "
+                          "only %O out of %O bytes of request body received",
+                          rb->rest, r->headers_in.content_length_n);
+
+            stream->skip_data = NGX_HTTP_V2_DATA_ERROR;
+            goto error;
+        }
+
+        if (tf) {
+            ngx_memzero(buf, sizeof(ngx_buf_t));
+
+            buf->in_file = 1;
+            buf->file_last = tf->file.offset;
+            buf->file = &tf->file;
+
+            rb->buf = NULL;
+        }
+
+        if (rb->post_handler) {
+            r->read_event_handler = ngx_http_block_reading;
+            rb->post_handler(r);
+        }
+    }
+
+    if (h2c->state.padding) {
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+
+error:
+
+    if (rb->post_handler) {
+
+        if (stream->skip_data == NGX_HTTP_V2_DATA_ERROR) {
+            rc = (r->headers_in.content_length_n == -1)
+                 ? NGX_HTTP_REQUEST_ENTITY_TOO_LARGE : NGX_HTTP_BAD_REQUEST;
+
+        } else {
+            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        ngx_http_finalize_request(r, rc);
+    }
+
+    return ngx_http_v2_state_skip_padded(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t                   size;
+    ngx_uint_t               padded, priority, depend, dependency, excl, weight;
+    ngx_http_v2_node_t      *node;
+    ngx_http_v2_stream_t    *stream;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;
+    priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG;
+
+    size = 0;
+
+    if (padded) {
+        size++;
+    }
+
+    if (priority) {
+        size += sizeof(uint32_t) + 1;
+    }
+
+    if (h2c->state.length < size) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent HEADERS frame with incorrect length %uz",
+                      h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (h2c->state.length == size) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent HEADERS frame with empty header block");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if ((size_t) (end - pos) < size) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_headers);
+    }
+
+    h2c->state.length -= size;
+
+    if (padded) {
+        h2c->state.padding = *pos++;
+
+        if (h2c->state.padding > h2c->state.length) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client sent padded HEADERS frame "
+                          "with incorrect length: %uz, padding: %uz",
+                          h2c->state.length, h2c->state.padding);
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+        }
+
+        h2c->state.length -= h2c->state.padding;
+    }
+
+    depend = 0;
+    excl = 0;
+    weight = 16;
+
+    if (priority) {
+        dependency = ngx_http_v2_parse_uint32(pos);
+
+        depend = dependency & 0x7fffffff;
+        excl = dependency >> 31;
+        weight = pos[4] + 1;
+
+        pos += sizeof(uint32_t) + 1;
+    }
+
+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 HEADERS frame sid:%ui on %ui excl:%ui weight:%ui",
+                   h2c->state.sid, depend, excl, weight);
+
+    if (h2c->state.sid % 2 == 0 || h2c->state.sid <= h2c->last_sid) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent HEADERS frame with incorrect identifier "
+                      "%ui, the last was %ui", h2c->state.sid, h2c->last_sid);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    h2c->last_sid = h2c->state.sid;
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    h2c->state.header_limit = h2scf->max_header_size;
+
+    if (h2c->processing >= h2scf->concurrent_streams) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "concurrent streams exceeded %ui", h2c->processing);
+
+        if (ngx_http_v2_send_rst_stream(h2c, h2c->state.sid,
+                                        NGX_HTTP_V2_REFUSED_STREAM)
+            != NGX_OK)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        return ngx_http_v2_state_skip_headers(h2c, pos, end);
+    }
+
+    node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 1);
+
+    if (node == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    if (node->parent) {
+        ngx_queue_remove(&node->reuse);
+        h2c->closed_nodes--;
+    }
+
+    stream = ngx_http_v2_create_stream(h2c);
+    if (stream == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    stream->in_closed = h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG;
+    stream->node = node;
+
+    node->stream = stream;
+
+    h2c->state.stream = stream;
+    h2c->state.pool = stream->request->pool;
+
+    if (priority || node->parent == NULL) {
+        node->weight = weight;
+        ngx_http_v2_set_dependency(h2c, node, depend, excl);
+    }
+
+    return ngx_http_v2_state_header_block(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_header_block(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    u_char                   ch;
+    ngx_int_t                value;
+    ngx_uint_t               indexed, size_update, prefix;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    if (end - pos < 1) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_header_block);
+    }
+
+    size_update = 0;
+    indexed = 0;
+
+    ch = *pos;
+
+    if (ch >= (1 << 7)) {
+        /* indexed header field */
+        indexed = 1;
+        prefix = ngx_http_v2_prefix(7);
+
+    } else if (ch >= (1 << 6)) {
+        /* literal header field with incremental indexing */
+        h2c->state.index = 1;
+        prefix = ngx_http_v2_prefix(6);
+
+    } else if (ch >= (1 << 5)) {
+        /* dynamic table size update */
+        size_update = 1;
+        prefix = ngx_http_v2_prefix(5);
+
+    } else if (ch >= (1 << 4)) {
+        /* literal header field never indexed */
+        prefix = ngx_http_v2_prefix(4);
+
+    } else {
+        /* literal header field without indexing */
+        prefix = ngx_http_v2_prefix(3);
+    }
+
+    value = ngx_http_v2_parse_int(h2c, &pos, end, prefix);
+
+    if (value < 0) {
+        if (value == NGX_AGAIN) {
+            return ngx_http_v2_state_save(h2c, pos, end,
+                                          ngx_http_v2_state_header_block);
+        }
+
+        if (value == NGX_DECLINED) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client sent header block with too long %s value",
+                          size_update ? "size update" : "header index");
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+        }
+
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent header block with incorrect length");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (indexed) {
+        if (ngx_http_v2_get_indexed_header(h2c, value, 0) != NGX_OK) {
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+        }
+
+        return ngx_http_v2_state_process_header(h2c, pos, end);
+    }
+
+    if (size_update) {
+        if (ngx_http_v2_table_size(h2c, value) != NGX_OK) {
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+        }
+
+        return ngx_http_v2_state_header_complete(h2c, pos, end);
+    }
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    h2c->state.field_limit = h2scf->max_field_size;
+
+    if (value == 0) {
+        h2c->state.parse_name = 1;
+
+    } else {
+        if (ngx_http_v2_get_indexed_header(h2c, value, 1) != NGX_OK) {
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+        }
+
+        h2c->state.field_limit -= h2c->state.header.name.len;
+    }
+
+    h2c->state.parse_value = 1;
+
+    return ngx_http_v2_state_field_len(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t      alloc;
+    ngx_int_t   len;
+    ngx_uint_t  huff;
+
+    if (h2c->state.length < 1) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent header block with incorrect length");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < 1) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_field_len);
+    }
+
+    huff = *pos >> 7;
+    len = ngx_http_v2_parse_int(h2c, &pos, end, ngx_http_v2_prefix(7));
+
+    if (len < 0) {
+        if (len == NGX_AGAIN) {
+            return ngx_http_v2_state_save(h2c, pos, end,
+                                          ngx_http_v2_state_field_len);
+        }
+
+        if (len == NGX_DECLINED) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                        "client sent header field with too long length value");
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+        }
+
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent header block with incorrect length");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 hpack %s string length: %i",
+                   huff ? "encoded" : "raw", len);
+
+    if ((size_t) len > h2c->state.length) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent header field with incorrect length");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    h2c->state.length -= len;
+
+    if ((size_t) len > h2c->state.field_limit) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent too long header field: "
+                      "%i bytes more than configured limit",
+                      len - h2c->state.field_limit);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);
+    }
+
+    h2c->state.field_limit -= len;
+    h2c->state.field_rest = len;
+
+    if (h2c->state.stream == NULL && !h2c->state.index) {
+        return ngx_http_v2_state_field_skip(h2c, pos, end);
+    }
+
+    alloc = (huff ? len * 8 / 5 : len) + 1;
+
+    h2c->state.field_start = ngx_pnalloc(h2c->state.pool, alloc);
+    if (h2c->state.field_start == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    h2c->state.field_end = h2c->state.field_start;
+
+    if (huff) {
+        return ngx_http_v2_state_field_huff(h2c, pos, end);
+    }
+
+    return ngx_http_v2_state_field_raw(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t  size;
+
+    size = end - pos;
+
+    if (size > h2c->state.field_rest) {
+        size = h2c->state.field_rest;
+    }
+
+    h2c->state.field_rest -= size;
+
+    if (ngx_http_v2_huff_decode(&h2c->state.field_state, pos, size,
+                                &h2c->state.field_end,
+                                h2c->state.field_rest == 0,
+                                h2c->connection->log)
+        != NGX_OK)
+    {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent invalid encoded header field");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);
+    }
+
+    if (h2c->state.field_rest != 0) {
+        return ngx_http_v2_state_save(h2c, end, end,
+                                      ngx_http_v2_state_field_huff);
+    }
+
+    *h2c->state.field_end = '\0';
+
+    return ngx_http_v2_state_process_header(h2c, pos + size, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_field_raw(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t  size;
+
+    size = end - pos;
+
+    if (size > h2c->state.field_rest) {
+        size = h2c->state.field_rest;
+    }
+
+    h2c->state.field_rest -= size;
+
+    h2c->state.field_end = ngx_cpymem(h2c->state.field_end, pos, size);
+
+    if (h2c->state.field_rest) {
+        return ngx_http_v2_state_save(h2c, end, end,
+                                      ngx_http_v2_state_field_raw);
+    }
+
+    *h2c->state.field_end = '\0';
+
+    return ngx_http_v2_state_process_header(h2c, pos + size, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_field_skip(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t  size;
+
+    size = end - pos;
+
+    if (size > h2c->state.field_rest) {
+        size = h2c->state.field_rest;
+    }
+
+    h2c->state.field_rest -= size;
+
+    return ngx_http_v2_state_process_header(h2c, pos + size, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t                      len;
+    ngx_int_t                   rc;
+    ngx_table_elt_t            *h;
+    ngx_http_header_t          *hh;
+    ngx_http_request_t         *r;
+    ngx_http_v2_header_t       *header;
+    ngx_http_core_srv_conf_t   *cscf;
+    ngx_http_core_main_conf_t  *cmcf;
+
+    static ngx_str_t cookie = ngx_string("cookie");
+
+    header = &h2c->state.header;
+
+    if (h2c->state.parse_name) {
+        h2c->state.parse_name = 0;
+
+        header->name.len = h2c->state.field_end - h2c->state.field_start;
+        header->name.data = h2c->state.field_start;
+
+        return ngx_http_v2_state_field_len(h2c, pos, end);
+    }
+
+    if (h2c->state.parse_value) {
+        h2c->state.parse_value = 0;
+
+        header->value.len = h2c->state.field_end - h2c->state.field_start;
+        header->value.data = h2c->state.field_start;
+    }
+
+    len = header->name.len + header->value.len;
+
+    if (len > h2c->state.header_limit) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent too many headers: "
+                      "%i bytes more than configured limit",
+                      len - h2c->state.header_limit);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);
+    }
+
+    h2c->state.header_limit -= len;
+
+    if (h2c->state.index) {
+        if (ngx_http_v2_add_header(h2c, header) != NGX_OK) {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        h2c->state.index = 0;
+    }
+
+    if (h2c->state.stream == NULL) {
+        return ngx_http_v2_state_header_complete(h2c, pos, end);
+    }
+
+    r = h2c->state.stream->request;
+
+    /* TODO Optimization: validate headers while parsing. */
+    if (ngx_http_v2_validate_header(r, header) != NGX_OK) {
+        if (ngx_http_v2_terminate_stream(h2c, h2c->state.stream,
+                                         NGX_HTTP_V2_PROTOCOL_ERROR)
+            == NGX_ERROR)
+        {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        goto error;
+    }
+
+    if (header->name.data[0] == ':') {
+        rc = ngx_http_v2_pseudo_header(r, header);
+
+        if (rc == NGX_OK) {
+            return ngx_http_v2_state_header_complete(h2c, pos, end);
+        }
+
+        if (rc == NGX_ABORT) {
+            goto error;
+        }
+
+        if (rc == NGX_DECLINED) {
+            if (ngx_http_v2_terminate_stream(h2c, h2c->state.stream,
+                                             NGX_HTTP_V2_PROTOCOL_ERROR)
+                == NGX_ERROR)
+            {
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_INTERNAL_ERROR);
+            }
+
+            goto error;
+        }
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    if (r->invalid_header) {
+        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
+
+        if (cscf->ignore_invalid_headers) {
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client sent invalid header: \"%V\"", &header->name);
+
+            return ngx_http_v2_state_header_complete(h2c, pos, end);
+        }
+    }
+
+    if (header->name.len == cookie.len
+        && ngx_memcmp(header->name.data, cookie.data, cookie.len) == 0)
+    {
+        if (ngx_http_v2_cookie(r, header) != NGX_OK) {
+            return ngx_http_v2_connection_error(h2c,
+                                                NGX_HTTP_V2_INTERNAL_ERROR);
+        }
+
+        return ngx_http_v2_state_header_complete(h2c, pos, end);
+    }
+
+    h = ngx_list_push(&r->headers_in.headers);
+    if (h == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    h->key.len = header->name.len;
+    h->key.data = header->name.data;
+
+    /* TODO Optimization: precalculate hash and hadnler for indexed headers. */
+    h->hash = ngx_hash_key(h->key.data, h->key.len);
+
+    h->value.len = header->value.len;
+    h->value.data = header->value.data;
+
+    h->lowcase_key = h->key.data;
+
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    hh = ngx_hash_find(&cmcf->headers_in_hash, h->hash,
+                       h->lowcase_key, h->key.len);
+
+    if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {
+        goto error;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http2 http header: \"%V: %V\"", &h->key, &h->value);
+
+    return ngx_http_v2_state_header_complete(h2c, pos, end);
+
+error:
+
+    h2c->state.stream = NULL;
+    h2c->state.pool = NULL;
+
+    return ngx_http_v2_state_header_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_http_v2_stream_t  *stream;
+
+    if (h2c->state.length) {
+        h2c->state.handler = h2c->state.pool ? ngx_http_v2_state_header_block
+                                             : ngx_http_v2_state_skip_headers;
+        return pos;
+    }
+
+    stream = h2c->state.stream;
+
+    if (stream) {
+        if (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {
+            stream->end_headers = 1;
+            ngx_http_v2_run_request(stream->request);
+
+        } else {
+            stream->header_limit = h2c->state.header_limit;
+        }
+
+    } else if (h2c->state.pool) {
+        ngx_destroy_pool(h2c->state.pool);
+    }
+
+    h2c->state.pool = NULL;
+
+    if (h2c->state.padding) {
+        return ngx_http_v2_state_skip_padded(h2c, pos, end);
+    }
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_priority(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_uint_t           depend, dependency, excl, weight;
+    ngx_http_v2_node_t  *node;
+
+    if (h2c->state.length != NGX_HTTP_V2_PRIORITY_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent PRIORITY frame with incorrect length %uz",
+                      h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < NGX_HTTP_V2_PRIORITY_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_priority);
+    }
+
+    dependency = ngx_http_v2_parse_uint32(pos);
+
+    depend = dependency & 0x7fffffff;
+    excl = dependency >> 31;
+    weight = pos[4] + 1;
+
+    pos += NGX_HTTP_V2_PRIORITY_SIZE;
+
+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 PRIORITY frame sid:%ui on %ui excl:%ui weight:%ui",
+                   h2c->state.sid, depend, excl, weight);
+
+    if (h2c->state.sid == 0) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent PRIORITY frame with incorrect identifier");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    if (depend == h2c->state.sid) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent PRIORITY frame for stream %ui "
+                      "with incorrect dependancy", h2c->state.sid);
+
+        node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 0);
+
+        if (node && node->stream) {
+            if (ngx_http_v2_terminate_stream(h2c, node->stream,
+                                             NGX_HTTP_V2_PROTOCOL_ERROR)
+                == NGX_ERROR)
+            {
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_INTERNAL_ERROR);
+            }
+
+        } else {
+            if (ngx_http_v2_send_rst_stream(h2c, h2c->state.sid,
+                                            NGX_HTTP_V2_PROTOCOL_ERROR)
+                == NGX_ERROR)
+            {
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_INTERNAL_ERROR);
+            }
+        }
+
+        return ngx_http_v2_state_complete(h2c, pos, end);
+    }
+
+    node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 1);
+
+    if (node == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    node->weight = weight;
+
+    if (node->stream == NULL) {
+        if (node->parent == NULL) {
+            h2c->closed_nodes++;
+
+        } else {
+            ngx_queue_remove(&node->reuse);
+        }
+
+        ngx_queue_insert_tail(&h2c->closed, &node->reuse);
+    }
+
+    ngx_http_v2_set_dependency(h2c, node, depend, excl);
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_rst_stream(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_uint_t             status;
+    ngx_event_t           *ev;
+    ngx_connection_t      *fc;
+    ngx_http_v2_node_t    *node;
+    ngx_http_v2_stream_t  *stream;
+
+    if (h2c->state.length != NGX_HTTP_V2_RST_STREAM_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent RST_STREAM frame with incorrect length %uz",
+                      h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < NGX_HTTP_V2_RST_STREAM_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_rst_stream);
+    }
+
+    status = ngx_http_v2_parse_uint32(pos);
+
+    pos += NGX_HTTP_V2_RST_STREAM_SIZE;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 RST_STREAM frame, sid:%ui status:%ui",
+                   h2c->state.sid, status);
+
+    if (h2c->state.sid == 0) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent RST_STREAM frame with incorrect identifier");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 0);
+
+    if (node == NULL || node->stream == NULL) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                        "unknown http2 stream");
+
+        return ngx_http_v2_state_complete(h2c, pos, end);
+    }
+
+    stream = node->stream;
+
+    stream->in_closed = 1;
+    stream->out_closed = 1;
+
+    fc = stream->request->connection;
+    fc->error = 1;
+
+    switch (status) {
+
+    case NGX_HTTP_V2_CANCEL:
+        ngx_log_error(NGX_LOG_INFO, fc->log, 0,
+                      "client canceled stream %ui", h2c->state.sid);
+        break;
+
+    case NGX_HTTP_V2_INTERNAL_ERROR:
+        ngx_log_error(NGX_LOG_INFO, fc->log, 0,
+                      "client terminated stream %ui due to internal error",
+                      h2c->state.sid);
+        break;
+
+    default:
+        ngx_log_error(NGX_LOG_INFO, fc->log, 0,
+                      "client terminated stream %ui with status %ui",
+                      h2c->state.sid, status);
+        break;
+    }
+
+    ev = fc->read;
+    ev->handler(ev);
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {
+
+        if (h2c->state.length != 0) {
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client sent SETTINGS frame with the ACK flag "
+                          "and nonzero length");
+
+            return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+        }
+
+        /* TODO settings acknowledged */
+
+        return ngx_http_v2_state_complete(h2c, pos, end);
+    }
+
+    if (h2c->state.length % NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent SETTINGS frame with incorrect length %uz",
+                      h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    ngx_http_v2_send_settings(h2c, 1);
+
+    return ngx_http_v2_state_settings_params(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_settings_params(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_uint_t  id, value;
+
+    while (h2c->state.length) {
+        if (end - pos < NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {
+            return ngx_http_v2_state_save(h2c, pos, end,
+                                          ngx_http_v2_state_settings_params);
+        }
+
+        h2c->state.length -= NGX_HTTP_V2_SETTINGS_PARAM_SIZE;
+
+        id = ngx_http_v2_parse_uint16(pos);
+        value = ngx_http_v2_parse_uint32(&pos[2]);
+
+        switch (id) {
+
+        case NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING:
+
+            if (value > NGX_HTTP_V2_MAX_WINDOW) {
+                ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                              "client sent SETTINGS frame with incorrect "
+                              "INITIAL_WINDOW_SIZE value %ui", value);
+
+                return ngx_http_v2_connection_error(h2c,
+                                                  NGX_HTTP_V2_FLOW_CTRL_ERROR);
+            }
+
+            if (ngx_http_v2_adjust_windows(h2c, value - h2c->init_window)
+                != NGX_OK)
+            {
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_INTERNAL_ERROR);
+            }
+
+            h2c->init_window = value;
+            break;
+
+        case NGX_HTTP_V2_MAX_FRAME_SIZE_SETTING:
+            if (value > NGX_HTTP_V2_MAX_FRAME_SIZE
+                || value < NGX_HTTP_V2_DEFAULT_FRAME_SIZE)
+            {
+                ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                              "client sent SETTINGS frame with incorrect "
+                              "MAX_FRAME_SIZE value %ui", value);
+
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_PROTOCOL_ERROR);
+            }
+
+            h2c->frame_size = value;
+            break;
+
+        default:
+            break;
+        }
+
+        pos += NGX_HTTP_V2_SETTINGS_PARAM_SIZE;
+    }
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_push_promise(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                  "client sent PUSH_PROMISE frame");
+
+    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+}
+
+
+static u_char *
+ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
+{
+    ngx_buf_t                *buf;
+    ngx_http_v2_out_frame_t  *frame;
+
+    if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent PING frame with incorrect length %uz",
+                      h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < NGX_HTTP_V2_PING_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_ping);
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 PING frame, flags: %ui", h2c->state.flags);
+
+    if (h2c->state.flags & NGX_HTTP_V2_ACK_FLAG) {
+        return ngx_http_v2_state_skip(h2c, pos, end);
+    }
+
+    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_PING_SIZE,
+                                  NGX_HTTP_V2_PING_FRAME,
+                                  NGX_HTTP_V2_ACK_FLAG, 0);
+    if (frame == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    buf = frame->first->buf;
+
+    buf->last = ngx_cpymem(buf->last, pos, NGX_HTTP_V2_PING_SIZE);
+
+    ngx_http_v2_queue_blocked_frame(h2c, frame);
+
+    return ngx_http_v2_state_complete(h2c, pos + NGX_HTTP_V2_PING_SIZE, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+#if (NGX_DEBUG)
+    ngx_uint_t  last_sid, error;
+#endif
+
+    if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent GOAWAY frame "
+                      "with incorrect length %uz", h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < NGX_HTTP_V2_GOAWAY_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);
+    }
+
+#if (NGX_DEBUG)
+    h2c->state.length -= NGX_HTTP_V2_GOAWAY_SIZE;
+
+    last_sid = ngx_http_v2_parse_sid(pos);
+    error = ngx_http_v2_parse_uint32(&pos[4]);
+
+    pos += NGX_HTTP_V2_GOAWAY_SIZE;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 GOAWAY frame: last sid %ui, error %ui",
+                   last_sid, error);
+#endif
+
+    return ngx_http_v2_state_skip(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_window_update(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    size_t                 window;
+    ngx_event_t           *wev;
+    ngx_queue_t           *q;
+    ngx_http_v2_node_t    *node;
+    ngx_http_v2_stream_t  *stream;
+
+    if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent WINDOW_UPDATE frame "
+                      "with incorrect length %uz", h2c->state.length);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (end - pos < NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {
+        return ngx_http_v2_state_save(h2c, pos, end,
+                                      ngx_http_v2_state_window_update);
+    }
+
+    window = ngx_http_v2_parse_window(pos);
+
+    pos += NGX_HTTP_V2_WINDOW_UPDATE_SIZE;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 WINDOW_UPDATE frame sid:%ui window:%uz",
+                   h2c->state.sid, window);
+
+    if (h2c->state.sid) {
+        node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 0);
+
+        if (node == NULL || node->stream == NULL) {
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                           "unknown http2 stream");
+
+            return ngx_http_v2_state_complete(h2c, pos, end);
+        }
+
+        stream = node->stream;
+
+        if (window > (size_t) (NGX_HTTP_V2_MAX_WINDOW - stream->send_window)) {
+
+            ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                          "client violated flow control for stream %ui: "
+                          "received WINDOW_UPDATE frame "
+                          "with window increment %uz "
+                          "not allowed for window %z",
+                          h2c->state.sid, window, stream->send_window);
+
+            if (ngx_http_v2_terminate_stream(h2c, stream,
+                                             NGX_HTTP_V2_FLOW_CTRL_ERROR)
+                == NGX_ERROR)
+            {
+                return ngx_http_v2_connection_error(h2c,
+                                                    NGX_HTTP_V2_INTERNAL_ERROR);
+            }
+
+            return ngx_http_v2_state_complete(h2c, pos, end);
+        }
+
+        stream->send_window += window;
+
+        if (stream->exhausted) {
+            stream->exhausted = 0;
+
+            wev = stream->request->connection->write;
+
+            if (!wev->timer_set) {
+                wev->delayed = 0;
+                wev->handler(wev);
+            }
+        }
+
+        return ngx_http_v2_state_complete(h2c, pos, end);
+    }
+
+    if (window > NGX_HTTP_V2_MAX_WINDOW - h2c->send_window) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client violated connection flow control: "
+                      "received WINDOW_UPDATE frame "
+                      "with window increment %uz "
+                      "not allowed for window %uz",
+                      window, h2c->send_window);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_FLOW_CTRL_ERROR);
+    }
+
+    h2c->send_window += window;
+
+    while (!ngx_queue_empty(&h2c->waiting)) {
+        q = ngx_queue_head(&h2c->waiting);
+
+        ngx_queue_remove(q);
+
+        stream = ngx_queue_data(q, ngx_http_v2_stream_t, queue);
+
+        stream->handled = 0;
+
+        wev = stream->request->connection->write;
+
+        if (!wev->timer_set) {
+            wev->delayed = 0;
+            wev->handler(wev);
+
+            if (h2c->send_window == 0) {
+                break;
+            }
+        }
+    }
+
+    return ngx_http_v2_state_complete(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_continuation(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_http_v2_node_t      *node;
+    ngx_http_v2_stream_t    *stream;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    if (h2c->state.length == 0) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent CONTINUATION with empty header block");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);
+    }
+
+    if (h2c->state.sid == 0) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                   "client sent CONTINUATION frame with incorrect identifier");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 0);
+
+    if (node == NULL || node->stream == NULL) {
+        h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                             ngx_http_v2_module);
+
+        h2c->state.header_limit = h2scf->max_header_size;
+
+        return ngx_http_v2_state_skip_headers(h2c, pos, end);
+    }
+
+    stream = node->stream;
+
+    if (stream->end_headers) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent unexpected CONTINUATION frame");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);
+    }
+
+    h2c->state.stream = stream;
+    h2c->state.header_limit = stream->header_limit;
+    h2c->state.pool = stream->request->pool;
+
+    return ngx_http_v2_state_header_block(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_complete(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 frame complete pos:%p end:%p", pos, end);
+
+    if (pos > end) {
+        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
+                      "receive buffer overrun");
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    h2c->state.stream = NULL;
+    h2c->state.handler = ngx_http_v2_state_head;
+
+    return pos;
+}
+
+
+static u_char *
+ngx_http_v2_state_skip_padded(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    h2c->state.length += h2c->state.padding;
+    h2c->state.padding = 0;
+
+    return ngx_http_v2_state_skip(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_skip(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)
+{
+    size_t  size;
+
+    size = end - pos;
+
+    if (size < h2c->state.length) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                       "http2 frame skip %uz of %uz", size, h2c->state.length);
+
+        h2c->state.length -= size;
+        return ngx_http_v2_state_save(h2c, end, end, ngx_http_v2_state_skip);
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 frame skip %uz", h2c->state.length);
+
+    return ngx_http_v2_state_complete(h2c, pos + h2c->state.length, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_skip_headers(ngx_http_v2_connection_t *h2c, u_char *pos,
+    u_char *end)
+{
+    h2c->state.pool = ngx_create_pool(1024, h2c->connection->log);
+    if (h2c->state.pool == NULL) {
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    return ngx_http_v2_state_header_block(h2c, pos, end);
+}
+
+
+static u_char *
+ngx_http_v2_state_save(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end,
+    ngx_http_v2_handler_pt handler)
+{
+    size_t  size;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 frame state save pos:%p end:%p handler:%p",
+                   pos, end, handler);
+
+    size = end - pos;
+
+    if (size > NGX_HTTP_V2_STATE_BUFFER_SIZE) {
+        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
+                      "state buffer overflow: %uz bytes required", size);
+
+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+    }
+
+    ngx_memcpy(h2c->state.buffer, pos, NGX_HTTP_V2_STATE_BUFFER_SIZE);
+
+    h2c->state.buffer_used = size;
+    h2c->state.handler = handler;
+    h2c->state.incomplete = 1;
+
+    return end;
+}
+
+
+static u_char *
+ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t err)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 state connection error");
+
+    if (err == NGX_HTTP_V2_INTERNAL_ERROR) {
+        ngx_debug_point();
+    }
+
+    if (h2c->state.stream) {
+        h2c->state.stream->out_closed = 1;
+        h2c->state.pool = NULL;
+        ngx_http_v2_close_stream(h2c->state.stream, NGX_HTTP_BAD_REQUEST);
+    }
+
+    ngx_http_v2_finalize_connection(h2c, err);
+
+    return NULL;
+}
+
+
+static ngx_int_t
+ngx_http_v2_parse_int(ngx_http_v2_connection_t *h2c, u_char **pos, u_char *end,
+    ngx_uint_t prefix)
+{
+    u_char      *start, *p;
+    ngx_uint_t   value, octet, shift;
+
+    start = *pos;
+    p = start;
+
+    value = *p++ & prefix;
+
+    if (value != prefix) {
+        if (h2c->state.length == 0) {
+            return NGX_ERROR;
+        }
+
+        h2c->state.length--;
+
+        *pos = p;
+        return value;
+    }
+
+    if (end - p > NGX_HTTP_V2_INT_OCTETS - 1) {
+        end = p + NGX_HTTP_V2_INT_OCTETS - 1;
+    }
+
+    for (shift = 0; p != end; shift += 7) {
+        octet = *p++;
+
+        value += (octet & 0x7f) << shift;
+
+        if (octet < 128) {
+            if ((size_t) (p - start) > h2c->state.length) {
+                return NGX_ERROR;
+            }
+
+            h2c->state.length -= p - start;
+
+            *pos = p;
+            return value;
+        }
+    }
+
+    if ((size_t) (end - start) >= NGX_HTTP_V2_INT_OCTETS) {
+        return NGX_DECLINED;
+    }
+
+    if ((size_t) (end - start) >= h2c->state.length) {
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_v2_send_settings(ngx_http_v2_connection_t *h2c, ngx_uint_t ack)
+{
+    size_t                    len;
+    ngx_buf_t                *buf;
+    ngx_chain_t              *cl;
+    ngx_http_v2_srv_conf_t   *h2scf;
+    ngx_http_v2_out_frame_t  *frame;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 send SETTINGS frame");
+
+    frame = ngx_palloc(h2c->pool, sizeof(ngx_http_v2_out_frame_t));
+    if (frame == NULL) {
+        return NGX_ERROR;
+    }
+
+    cl = ngx_alloc_chain_link(h2c->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    len = ack ? 0 : (sizeof(uint16_t) + sizeof(uint32_t)) * 3;
+
+    buf = ngx_create_temp_buf(h2c->pool, NGX_HTTP_V2_FRAME_HEADER_SIZE + len);
+    if (buf == NULL) {
+        return NGX_ERROR;
+    }
+
+    buf->last_buf = 1;
+
+    cl->buf = buf;
+    cl->next = NULL;
+
+    frame->first = cl;
+    frame->last = cl;
+    frame->handler = ngx_http_v2_settings_frame_handler;
+    frame->stream = NULL;
+#if (NGX_DEBUG)
+    frame->length = len;
+#endif
+    frame->blocked = 0;
+
+    buf->last = ngx_http_v2_write_len_and_type(buf->last, len,
+                                               NGX_HTTP_V2_SETTINGS_FRAME);
+
+    *buf->last++ = ack ? NGX_HTTP_V2_ACK_FLAG : NGX_HTTP_V2_NO_FLAG;
+
+    buf->last = ngx_http_v2_write_sid(buf->last, 0);
+
+    if (!ack) {
+        h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                             ngx_http_v2_module);
+
+        buf->last = ngx_http_v2_write_uint16(buf->last,
+                                             NGX_HTTP_V2_MAX_STREAMS_SETTING);
+        buf->last = ngx_http_v2_write_uint32(buf->last,
+                                             h2scf->concurrent_streams);
+
+        buf->last = ngx_http_v2_write_uint16(buf->last,
+                                         NGX_HTTP_V2_INIT_WINDOW_SIZE_SETTING);
+        buf->last = ngx_http_v2_write_uint32(buf->last,
+                                             NGX_HTTP_V2_MAX_WINDOW);
+
+        buf->last = ngx_http_v2_write_uint16(buf->last,
+                                           NGX_HTTP_V2_MAX_FRAME_SIZE_SETTING);
+        buf->last = ngx_http_v2_write_uint32(buf->last,
+                                             NGX_HTTP_V2_MAX_FRAME_SIZE);
+    }
+
+    ngx_http_v2_queue_blocked_frame(h2c, frame);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_settings_frame_handler(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_buf_t  *buf;
+
+    buf = frame->first->buf;
+
+    if (buf->pos != buf->last) {
+        return NGX_AGAIN;
+    }
+
+    ngx_free_chain(h2c->pool, frame->first);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_send_window_update(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
+    size_t window)
+{
+    ngx_buf_t                *buf;
+    ngx_http_v2_out_frame_t  *frame;
+
+    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_WINDOW_UPDATE_SIZE,
+                                  NGX_HTTP_V2_WINDOW_UPDATE_FRAME,
+                                  NGX_HTTP_V2_NO_FLAG, sid);
+    if (frame == NULL) {
+        return NGX_ERROR;
+    }
+
+    buf = frame->first->buf;
+
+    buf->last = ngx_http_v2_write_uint32(buf->last, window);
+
+    ngx_http_v2_queue_blocked_frame(h2c, frame);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_send_rst_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
+    ngx_uint_t status)
+{
+    ngx_buf_t                *buf;
+    ngx_http_v2_out_frame_t  *frame;
+
+    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_RST_STREAM_SIZE,
+                                  NGX_HTTP_V2_RST_STREAM_FRAME,
+                                  NGX_HTTP_V2_NO_FLAG, sid);
+    if (frame == NULL) {
+        return NGX_ERROR;
+    }
+
+    buf = frame->first->buf;
+
+    buf->last = ngx_http_v2_write_uint32(buf->last, status);
+
+    ngx_http_v2_queue_blocked_frame(h2c, frame);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_send_goaway(ngx_http_v2_connection_t *h2c, ngx_uint_t status)
+{
+    ngx_buf_t                *buf;
+    ngx_http_v2_out_frame_t  *frame;
+
+    frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_GOAWAY_SIZE,
+                                  NGX_HTTP_V2_GOAWAY_FRAME,
+                                  NGX_HTTP_V2_NO_FLAG, 0);
+    if (frame == NULL) {
+        return NGX_ERROR;
+    }
+
+    buf = frame->first->buf;
+
+    buf->last = ngx_http_v2_write_sid(buf->last, h2c->last_sid);
+    buf->last = ngx_http_v2_write_uint32(buf->last, status);
+
+    ngx_http_v2_queue_blocked_frame(h2c, frame);
+
+    return NGX_OK;
+}
+
+
+static ngx_http_v2_out_frame_t *
+ngx_http_v2_get_frame(ngx_http_v2_connection_t *h2c, size_t length,
+    ngx_uint_t type, u_char flags, ngx_uint_t sid)
+{
+    ngx_buf_t                *buf;
+    ngx_pool_t               *pool;
+    ngx_http_v2_out_frame_t  *frame;
+
+    frame = h2c->free_frames;
+
+    if (frame) {
+        h2c->free_frames = frame->next;
+
+        buf = frame->first->buf;
+        buf->pos = buf->start;
+
+        frame->blocked = 0;
+
+    } else {
+        pool = h2c->pool ? h2c->pool : h2c->connection->pool;
+
+        frame = ngx_pcalloc(pool, sizeof(ngx_http_v2_out_frame_t));
+        if (frame == NULL) {
+            return NULL;
+        }
+
+        frame->first = ngx_alloc_chain_link(pool);
+        if (frame->first == NULL) {
+            return NULL;
+        }
+
+        buf = ngx_create_temp_buf(pool, NGX_HTTP_V2_FRAME_BUFFER_SIZE);
+        if (buf == NULL) {
+            return NULL;
+        }
+
+        buf->last_buf = 1;
+
+        frame->first->buf = buf;
+        frame->last = frame->first;
+
+        frame->handler = ngx_http_v2_frame_handler;
+    }
+
+#if (NGX_DEBUG)
+    if (length > NGX_HTTP_V2_FRAME_BUFFER_SIZE - NGX_HTTP_V2_FRAME_HEADER_SIZE)
+    {
+        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
+                      "requested control frame is too large: %uz", length);
+        return NULL;
+    }
+
+    frame->length = length;
+#endif
+
+    buf->last = ngx_http_v2_write_len_and_type(buf->pos, length, type);
+
+    *buf->last++ = flags;
+
+    buf->last = ngx_http_v2_write_sid(buf->last, sid);
+
+    return frame;
+}
+
+
+static ngx_int_t
+ngx_http_v2_frame_handler(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_buf_t  *buf;
+
+    buf = frame->first->buf;
+
+    if (buf->pos != buf->last) {
+        return NGX_AGAIN;
+    }
+
+    frame->next = h2c->free_frames;
+    h2c->free_frames = frame;
+
+    return NGX_OK;
+}
+
+
+static ngx_http_v2_stream_t *
+ngx_http_v2_create_stream(ngx_http_v2_connection_t *h2c)
+{
+    ngx_log_t                 *log;
+    ngx_event_t               *rev, *wev;
+    ngx_connection_t          *fc;
+    ngx_http_log_ctx_t        *ctx;
+    ngx_http_request_t        *r;
+    ngx_http_v2_stream_t      *stream;
+    ngx_http_core_srv_conf_t  *cscf;
+
+    fc = h2c->free_fake_connections;
+
+    if (fc) {
+        h2c->free_fake_connections = fc->data;
+
+        rev = fc->read;
+        wev = fc->write;
+        log = fc->log;
+        ctx = log->data;
+
+    } else {
+        fc = ngx_palloc(h2c->pool, sizeof(ngx_connection_t));
+        if (fc == NULL) {
+            return NULL;
+        }
+
+        rev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
+        if (rev == NULL) {
+            return NULL;
+        }
+
+        wev = ngx_palloc(h2c->pool, sizeof(ngx_event_t));
+        if (wev == NULL) {
+            return NULL;
+        }
+
+        log = ngx_palloc(h2c->pool, sizeof(ngx_log_t));
+        if (log == NULL) {
+            return NULL;
+        }
+
+        ctx = ngx_palloc(h2c->pool, sizeof(ngx_http_log_ctx_t));
+        if (ctx == NULL) {
+            return NULL;
+        }
+
+        ctx->connection = fc;
+        ctx->request = NULL;
+        ctx->current_request = NULL;
+    }
+
+    ngx_memcpy(log, h2c->connection->log, sizeof(ngx_log_t));
+
+    log->data = ctx;
+
+    ngx_memzero(rev, sizeof(ngx_event_t));
+
+    rev->data = fc;
+    rev->ready = 1;
+    rev->handler = ngx_http_v2_close_stream_handler;
+    rev->log = log;
+
+    ngx_memcpy(wev, rev, sizeof(ngx_event_t));
+
+    wev->write = 1;
+
+    ngx_memcpy(fc, h2c->connection, sizeof(ngx_connection_t));
+
+    fc->data = h2c->http_connection;
+    fc->read = rev;
+    fc->write = wev;
+    fc->sent = 0;
+    fc->log = log;
+    fc->buffered = 0;
+    fc->sndlowat = 1;
+    fc->tcp_nodelay = NGX_TCP_NODELAY_DISABLED;
+
+    r = ngx_http_create_request(fc);
+    if (r == NULL) {
+        return NULL;
+    }
+
+    r->http_version = NGX_HTTP_VERSION_20;
+    r->valid_location = 1;
+
+    fc->data = r;
+    h2c->connection->requests++;
+
+    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
+
+    r->header_in = ngx_create_temp_buf(r->pool,
+                                       cscf->client_header_buffer_size);
+    if (r->header_in == NULL) {
+        ngx_http_free_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NULL;
+    }
+
+    if (ngx_list_init(&r->headers_in.headers, r->pool, 20,
+                      sizeof(ngx_table_elt_t))
+        != NGX_OK)
+    {
+        ngx_http_free_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NULL;
+    }
+
+    r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;
+
+    stream = ngx_pcalloc(r->pool, sizeof(ngx_http_v2_stream_t));
+    if (stream == NULL) {
+        ngx_http_free_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NULL;
+    }
+
+    r->stream = stream;
+
+    stream->request = r;
+    stream->connection = h2c;
+
+    stream->send_window = h2c->init_window;
+    stream->recv_window = NGX_HTTP_V2_MAX_WINDOW;
+
+    h2c->processing++;
+
+    return stream;
+}
+
+
+static ngx_http_v2_node_t *
+ngx_http_v2_get_node_by_id(ngx_http_v2_connection_t *h2c, ngx_uint_t sid,
+    ngx_uint_t alloc)
+{
+    ngx_uint_t               index;
+    ngx_http_v2_node_t      *node;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    index = ngx_http_v2_index(h2scf, sid);
+
+    for (node = h2c->streams_index[index]; node; node = node->index) {
+
+        if (node->id == sid) {
+            return node;
+        }
+    }
+
+    if (!alloc) {
+        return NULL;
+    }
+
+    if (h2c->closed_nodes < 32) {
+        node = ngx_pcalloc(h2c->connection->pool, sizeof(ngx_http_v2_node_t));
+        if (node == NULL) {
+            return NULL;
+        }
+
+    } else {
+        node = ngx_http_v2_get_closed_node(h2c);
+    }
+
+    node->id = sid;
+
+    ngx_queue_init(&node->children);
+
+    node->index = h2c->streams_index[index];
+    h2c->streams_index[index] = node;
+
+    return node;
+}
+
+
+static ngx_http_v2_node_t *
+ngx_http_v2_get_closed_node(ngx_http_v2_connection_t *h2c)
+{
+    ngx_uint_t               weight;
+    ngx_queue_t             *q, *children;
+    ngx_http_v2_node_t      *node, **next, *n, *parent, *child;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    h2c->closed_nodes--;
+
+    q = ngx_queue_head(&h2c->closed);
+
+    ngx_queue_remove(q);
+
+    node = ngx_queue_data(q, ngx_http_v2_node_t, reuse);
+
+    next = &h2c->streams_index[ngx_http_v2_index(h2scf, node->id)];
+
+    for ( ;; ) {
+        n = *next;
+
+        if (n == node) {
+            *next = n->index;
+            break;
+        }
+
+        next = &n->index;
+    }
+
+    ngx_queue_remove(&node->queue);
+
+    weight = 0;
+
+    for (q = ngx_queue_head(&node->children);
+         q != ngx_queue_sentinel(&node->children);
+         q = ngx_queue_next(q))
+    {
+        child = ngx_queue_data(q, ngx_http_v2_node_t, queue);
+        weight += child->weight;
+    }
+
+    for (q = ngx_queue_head(&node->children);
+         q != ngx_queue_sentinel(&node->children);
+         q = ngx_queue_next(q))
+    {
+        child = ngx_queue_data(q, ngx_http_v2_node_t, queue);
+        child->weight = node->weight * child->weight / weight;
+    }
+
+    parent = node->parent;
+
+    if (parent == NGX_HTTP_V2_ROOT) {
+        node->rank = 0;
+        node->rel_weight = 1.0;
+
+        children = &h2c->dependencies;
+
+    } else {
+        node->rank = parent->rank;
+        node->rel_weight = parent->rel_weight;
+
+        children = &parent->children;
+    }
+
+    ngx_http_v2_node_children_update(node);
+    ngx_queue_add(children, &node->children);
+
+    ngx_memzero(node, sizeof(ngx_http_v2_node_t));
+
+    return node;
+}
+
+
+static ngx_int_t
+ngx_http_v2_validate_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    u_char                     ch;
+    ngx_uint_t                 i;
+    ngx_http_core_srv_conf_t  *cscf;
+
+    if (header->name.len == 0) {
+        return NGX_ERROR;
+    }
+
+    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
+
+    for (i = (header->name.data[0] == ':'); i != header->name.len; i++) {
+        ch = header->name.data[i];
+
+        if ((ch >= 'a' && ch <= 'z')
+            || (ch == '-')
+            || (ch >= '0' && ch <= '9')
+            || (ch == '_' && cscf->underscores_in_headers))
+        {
+            continue;
+        }
+
+        switch (ch) {
+        case '\0':
+        case LF:
+        case CR:
+        case ':':
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client sent invalid header name: \"%V\"",
+                          &header->name);
+
+            return NGX_ERROR;
+        }
+
+        if (ch >= 'A' && ch <= 'Z') {
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client sent invalid header name: \"%V\"",
+                          &header->name);
+
+            return NGX_ERROR;
+        }
+
+        r->invalid_header = 1;
+    }
+
+    for (i = 0; i != header->value.len; i++) {
+        ch = header->value.data[i];
+
+        switch (ch) {
+        case '\0':
+        case LF:
+        case CR:
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client sent header \"%V\" with "
+                          "invalid value: \"%*s\"",
+                          &header->name, i + 1, &header->value.data);
+
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_pseudo_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    header->name.len--;
+    header->name.data++;
+
+    switch (header->name.len) {
+    case 4:
+        if (ngx_memcmp(header->name.data, "path", sizeof("path") - 1)
+            == 0)
+        {
+            return ngx_http_v2_parse_path(r, header);
+        }
+
+        break;
+
+    case 6:
+        if (ngx_memcmp(header->name.data, "method", sizeof("method") - 1)
+            == 0)
+        {
+            return ngx_http_v2_parse_method(r, header);
+        }
+
+        if (ngx_memcmp(header->name.data, "scheme", sizeof("scheme") - 1)
+            == 0)
+        {
+            return ngx_http_v2_parse_scheme(r, header);
+        }
+
+        break;
+
+    case 9:
+        if (ngx_memcmp(header->name.data, "authority", sizeof("authority") - 1)
+            == 0)
+        {
+            return ngx_http_v2_parse_authority(r, header);
+        }
+
+        break;
+    }
+
+    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                  "client sent unknown pseudo header \"%V\"",
+                  &header->name);
+
+    return NGX_DECLINED;
+}
+
+
+static ngx_int_t
+ngx_http_v2_parse_path(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    if (r->unparsed_uri.len) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent duplicate :path header");
+
+        return NGX_DECLINED;
+    }
+
+    if (header->value.len == 0) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent empty :path header");
+
+        return NGX_DECLINED;
+    }
+
+    r->uri_start = header->value.data;
+    r->uri_end = header->value.data + header->value.len;
+
+    if (ngx_http_parse_uri(r) != NGX_OK) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent invalid :path header: \"%V\"",
+                      &header->value);
+
+        return NGX_DECLINED;
+    }
+
+    if (ngx_http_process_request_uri(r) != NGX_OK) {
+        /*
+         * request has been finalized already
+         * in ngx_http_process_request_uri()
+         */
+        return NGX_ABORT;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_parse_method(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    size_t         k, len;
+    ngx_uint_t     n;
+    const u_char  *p, *m;
+
+    /*
+     * This array takes less than 256 sequential bytes,
+     * and if typical CPU cache line size is 64 bytes,
+     * it is prefetched for 4 load operations.
+     */
+    static const struct {
+        u_char            len;
+        const u_char      method[11];
+        uint32_t          value;
+    } tests[] = {
+        { 3, "GET",       NGX_HTTP_GET },
+        { 4, "POST",      NGX_HTTP_POST },
+        { 4, "HEAD",      NGX_HTTP_HEAD },
+        { 7, "OPTIONS",   NGX_HTTP_OPTIONS },
+        { 8, "PROPFIND",  NGX_HTTP_PROPFIND },
+        { 3, "PUT",       NGX_HTTP_PUT },
+        { 5, "MKCOL",     NGX_HTTP_MKCOL },
+        { 6, "DELETE",    NGX_HTTP_DELETE },
+        { 4, "COPY",      NGX_HTTP_COPY },
+        { 4, "MOVE",      NGX_HTTP_MOVE },
+        { 9, "PROPPATCH", NGX_HTTP_PROPPATCH },
+        { 4, "LOCK",      NGX_HTTP_LOCK },
+        { 6, "UNLOCK",    NGX_HTTP_UNLOCK },
+        { 5, "PATCH",     NGX_HTTP_PATCH },
+        { 5, "TRACE",     NGX_HTTP_TRACE }
+    }, *test;
+
+    if (r->method_name.len) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent duplicate :method header");
+
+        return NGX_DECLINED;
+    }
+
+    if (header->value.len == 0) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent empty :method header");
+
+        return NGX_DECLINED;
+    }
+
+    r->method_name.len = header->value.len;
+    r->method_name.data = header->value.data;
+
+    len = r->method_name.len;
+    n = sizeof(tests) / sizeof(tests[0]);
+    test = tests;
+
+    do {
+        if (len == test->len) {
+            p = r->method_name.data;
+            m = test->method;
+            k = len;
+
+            do {
+                if (*p++ != *m++) {
+                    goto next;
+                }
+            } while (--k);
+
+            r->method = test->value;
+            return NGX_OK;
+        }
+
+    next:
+        test++;
+
+    } while (--n);
+
+    p = r->method_name.data;
+
+    do {
+        if ((*p < 'A' || *p > 'Z') && *p != '_') {
+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                          "client sent invalid method: \"%V\"",
+                          &r->method_name);
+
+            return NGX_DECLINED;
+        }
+
+        p++;
+
+    } while (--len);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_parse_scheme(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    if (r->schema_start) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent duplicate :schema header");
+
+        return NGX_DECLINED;
+    }
+
+    if (header->value.len == 0) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client sent empty :schema header");
+
+        return NGX_DECLINED;
+    }
+
+    r->schema_start = header->value.data;
+    r->schema_end = header->value.data + header->value.len;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_parse_authority(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    ngx_table_elt_t            *h;
+    ngx_http_header_t          *hh;
+    ngx_http_core_main_conf_t  *cmcf;
+
+    static ngx_str_t host = ngx_string("host");
+
+    h = ngx_list_push(&r->headers_in.headers);
+    if (h == NULL) {
+        return NGX_ERROR;
+    }
+
+    h->hash = ngx_hash_key(host.data, host.len);
+
+    h->key.len = host.len;
+    h->key.data = host.data;
+
+    h->value.len = header->value.len;
+    h->value.data = header->value.data;
+
+    h->lowcase_key = host.data;
+
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    hh = ngx_hash_find(&cmcf->headers_in_hash, h->hash,
+                       h->lowcase_key, h->key.len);
+
+    if (hh == NULL) {
+        return NGX_ERROR;
+    }
+
+    if (hh->handler(r, h, hh->offset) != NGX_OK) {
+        /*
+         * request has been finalized already
+         * in ngx_http_process_host()
+         */
+        return NGX_ABORT;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_construct_request_line(ngx_http_request_t *r)
+{
+    u_char  *p;
+
+    static const u_char ending[] = " HTTP/2.0";
+
+    if (r->method_name.len == 0
+        || r->unparsed_uri.len == 0)
+    {
+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
+        return NGX_ERROR;
+    }
+
+    r->request_line.len = r->method_name.len + 1
+                          + r->unparsed_uri.len
+                          + sizeof(ending) - 1;
+
+    p = ngx_pnalloc(r->pool, r->request_line.len + 1);
+    if (p == NULL) {
+        ngx_http_v2_close_stream(r->stream, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NGX_ERROR;
+    }
+
+    r->request_line.data = p;
+
+    p = ngx_cpymem(p, r->method_name.data, r->method_name.len);
+
+    *p++ = ' ';
+
+    p = ngx_cpymem(p, r->unparsed_uri.data, r->unparsed_uri.len);
+
+    ngx_memcpy(p, ending, sizeof(ending));
+
+    /* some modules expect the space character after method name */
+    r->method_name.data = r->request_line.data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http2 http request line: \"%V\"", &r->request_line);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_cookie(ngx_http_request_t *r, ngx_http_v2_header_t *header)
+{
+    ngx_str_t    *val;
+    ngx_array_t  *cookies;
+
+    cookies = r->stream->cookies;
+
+    if (cookies == NULL) {
+        cookies = ngx_array_create(r->pool, 2, sizeof(ngx_str_t));
+        if (cookies == NULL) {
+            return NGX_ERROR;
+        }
+
+        r->stream->cookies = cookies;
+    }
+
+    val = ngx_array_push(cookies);
+    if (val == NULL) {
+        return NGX_ERROR;
+    }
+
+    val->len = header->value.len;
+    val->data = header->value.data;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_construct_cookie_header(ngx_http_request_t *r)
+{
+    u_char                     *buf, *p, *end;
+    size_t                      len;
+    ngx_str_t                  *vals;
+    ngx_uint_t                  i;
+    ngx_array_t                *cookies;
+    ngx_table_elt_t            *h;
+    ngx_http_header_t          *hh;
+    ngx_http_core_main_conf_t  *cmcf;
+
+    static ngx_str_t cookie = ngx_string("cookie");
+
+    cookies = r->stream->cookies;
+
+    if (cookies == NULL) {
+        return NGX_OK;
+    }
+
+    vals = cookies->elts;
+
+    i = 0;
+    len = 0;
+
+    do {
+        len += vals[i].len + 2;
+    } while (++i != cookies->nelts);
+
+    len -= 2;
+
+    buf = ngx_pnalloc(r->pool, len + 1);
+    if (buf == NULL) {
+        ngx_http_v2_close_stream(r->stream, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NGX_ERROR;
+    }
+
+    p = buf;
+    end = buf + len;
+
+    for (i = 0; /* void */ ; i++) {
+
+        p = ngx_cpymem(p, vals[i].data, vals[i].len);
+
+        if (p == end) {
+            *p = '\0';
+            break;
+        }
+
+        *p++ = ';'; *p++ = ' ';
+    }
+
+    h = ngx_list_push(&r->headers_in.headers);
+    if (h == NULL) {
+        ngx_http_v2_close_stream(r->stream, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NGX_ERROR;
+    }
+
+    h->hash = ngx_hash_key(cookie.data, cookie.len);
+
+    h->key.len = cookie.len;
+    h->key.data = cookie.data;
+
+    h->value.len = len;
+    h->value.data = buf;
+
+    h->lowcase_key = cookie.data;
+
+    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
+
+    hh = ngx_hash_find(&cmcf->headers_in_hash, h->hash,
+                       h->lowcase_key, h->key.len);
+
+    if (hh == NULL) {
+        ngx_http_v2_close_stream(r->stream, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return NGX_ERROR;
+    }
+
+    if (hh->handler(r, h, hh->offset) != NGX_OK) {
+        /*
+         * request has been finalized already
+         * in ngx_http_process_multi_header_lines()
+         */
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_v2_run_request(ngx_http_request_t *r)
+{
+    if (ngx_http_v2_construct_request_line(r) != NGX_OK) {
+        return;
+    }
+
+    if (ngx_http_v2_construct_cookie_header(r) != NGX_OK) {
+        return;
+    }
+
+    r->http_state = NGX_HTTP_PROCESS_REQUEST_STATE;
+
+    if (ngx_http_process_request_header(r) != NGX_OK) {
+        return;
+    }
+
+    if (r->headers_in.content_length_n > 0 && r->stream->in_closed) {
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                      "client prematurely closed stream");
+
+        r->stream->skip_data = NGX_HTTP_V2_DATA_ERROR;
+
+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
+        return;
+    }
+
+    ngx_http_process_request(r);
+}
+
+
+static ngx_int_t
+ngx_http_v2_init_request_body(ngx_http_request_t *r)
+{
+    ngx_buf_t                 *buf;
+    ngx_temp_file_t           *tf;
+    ngx_http_request_body_t   *rb;
+    ngx_http_core_loc_conf_t  *clcf;
+
+    rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
+    if (rb == NULL) {
+        return NGX_ERROR;
+    }
+
+    r->request_body = rb;
+
+    if (r->stream->in_closed) {
+        return NGX_OK;
+    }
+
+    rb->rest = r->headers_in.content_length_n;
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (r->request_body_in_file_only
+        || rb->rest > (off_t) clcf->client_body_buffer_size
+        || rb->rest < 0)
+    {
+        tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));
+        if (tf == NULL) {
+            return NGX_ERROR;
+        }
+
+        tf->file.fd = NGX_INVALID_FILE;
+        tf->file.log = r->connection->log;
+        tf->path = clcf->client_body_temp_path;
+        tf->pool = r->pool;
+        tf->warn = "a client request body is buffered to a temporary file";
+        tf->log_level = r->request_body_file_log_level;
+        tf->persistent = r->request_body_in_persistent_file;
+        tf->clean = r->request_body_in_clean_file;
+
+        if (r->request_body_file_group_access) {
+            tf->access = 0660;
+        }
+
+        rb->temp_file = tf;
+
+        if (r->stream->in_closed
+            && ngx_create_temp_file(&tf->file, tf->path, tf->pool,
+                                    tf->persistent, tf->clean, tf->access)
+               != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+
+        buf = ngx_calloc_buf(r->pool);
+        if (buf == NULL) {
+            return NGX_ERROR;
+        }
+
+    } else {
+
+        if (rb->rest == 0) {
+            return NGX_OK;
+        }
+
+        buf = ngx_create_temp_buf(r->pool, (size_t) rb->rest);
+        if (buf == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    rb->buf = buf;
+
+    rb->bufs = ngx_alloc_chain_link(r->pool);
+    if (rb->bufs == NULL) {
+        return NGX_ERROR;
+    }
+
+    rb->bufs->buf = buf;
+    rb->bufs->next = NULL;
+
+    rb->rest = 0;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_v2_read_request_body(ngx_http_request_t *r,
+    ngx_http_client_body_handler_pt post_handler)
+{
+    ngx_http_v2_stream_t  *stream;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http2 read request body");
+
+    stream = r->stream;
+
+    switch (stream->skip_data) {
+
+    case NGX_HTTP_V2_DATA_DISCARD:
+        post_handler(r);
+        return NGX_OK;
+
+    case NGX_HTTP_V2_DATA_ERROR:
+        if (r->headers_in.content_length_n == -1) {
+            return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;
+        } else {
+            return NGX_HTTP_BAD_REQUEST;
+        }
+
+    case NGX_HTTP_V2_DATA_INTERNAL_ERROR:
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (!r->request_body && ngx_http_v2_init_request_body(r) != NGX_OK) {
+        stream->skip_data = NGX_HTTP_V2_DATA_INTERNAL_ERROR;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (stream->in_closed) {
+        post_handler(r);
+        return NGX_OK;
+    }
+
+    r->request_body->post_handler = post_handler;
+
+    r->read_event_handler = ngx_http_test_reading;
+    r->write_event_handler = ngx_http_request_empty_handler;
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream, ngx_uint_t status)
+{
+    ngx_event_t       *rev;
+    ngx_connection_t  *fc;
+
+    if (ngx_http_v2_send_rst_stream(h2c, stream->node->id, status)
+        == NGX_ERROR)
+    {
+        return NGX_ERROR;
+    }
+
+    stream->out_closed = 1;
+
+    fc = stream->request->connection;
+    fc->error = 1;
+
+    rev = fc->read;
+    rev->handler(rev);
+
+    return NGX_OK;
+}
+
+
+void
+ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc)
+{
+    ngx_event_t               *ev;
+    ngx_connection_t          *fc;
+    ngx_http_v2_node_t        *node;
+    ngx_http_v2_connection_t  *h2c;
+
+    h2c = stream->connection;
+    node = stream->node;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 close stream %ui, queued %ui, processing %ui",
+                   node->id, stream->queued, h2c->processing);
+
+    fc = stream->request->connection;
+
+    if (stream->queued) {
+        fc->write->handler = ngx_http_v2_close_stream_handler;
+        return;
+    }
+
+    if (!stream->out_closed) {
+        if (ngx_http_v2_send_rst_stream(h2c, node->id,
+                                        NGX_HTTP_V2_INTERNAL_ERROR)
+            != NGX_OK)
+        {
+            h2c->connection->error = 1;
+        }
+    }
+
+    node->stream = NULL;
+
+    ngx_queue_insert_tail(&h2c->closed, &node->reuse);
+    h2c->closed_nodes++;
+
+    ngx_http_free_request(stream->request, rc);
+
+    ev = fc->read;
+
+    if (ev->active || ev->disabled) {
+        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
+                      "fake read event was activated");
+    }
+
+    if (ev->timer_set) {
+        ngx_del_timer(ev);
+    }
+
+    if (ev->posted) {
+        ngx_delete_posted_event(ev);
+    }
+
+    ev = fc->write;
+
+    if (ev->active || ev->disabled) {
+        ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,
+                      "fake write event was activated");
+    }
+
+    if (ev->timer_set) {
+        ngx_del_timer(ev);
+    }
+
+    if (ev->posted) {
+        ngx_delete_posted_event(ev);
+    }
+
+    fc->data = h2c->free_fake_connections;
+    h2c->free_fake_connections = fc;
+
+    h2c->processing--;
+
+    if (h2c->processing || h2c->blocked) {
+        return;
+    }
+
+    ev = h2c->connection->read;
+
+    ev->handler = ngx_http_v2_handle_connection_handler;
+    ngx_post_event(ev, &ngx_posted_events);
+}
+
+
+static void
+ngx_http_v2_close_stream_handler(ngx_event_t *ev)
+{
+    ngx_connection_t    *fc;
+    ngx_http_request_t  *r;
+
+    fc = ev->data;
+    r = fc->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http2 close stream handler");
+
+    ngx_http_v2_close_stream(r->stream, 0);
+}
+
+
+static void
+ngx_http_v2_handle_connection_handler(ngx_event_t *rev)
+{
+    ngx_connection_t  *c;
+
+    rev->handler = ngx_http_v2_read_handler;
+
+    if (rev->ready) {
+        ngx_http_v2_read_handler(rev);
+        return;
+    }
+
+    c = rev->data;
+
+    ngx_http_v2_handle_connection(c->data);
+}
+
+
+static void
+ngx_http_v2_idle_handler(ngx_event_t *rev)
+{
+    ngx_connection_t          *c;
+    ngx_http_v2_srv_conf_t    *h2scf;
+    ngx_http_v2_connection_t  *h2c;
+
+    c = rev->data;
+    h2c = c->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "http2 idle handler");
+
+    if (rev->timedout || c->close) {
+        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);
+        return;
+    }
+
+#if (NGX_HAVE_KQUEUE)
+
+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {
+        if (rev->pending_eof) {
+            c->log->handler = NULL;
+            ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,
+                          "kevent() reported that client %V closed "
+                          "idle connection", &c->addr_text);
+#if (NGX_HTTP_SSL)
+            if (c->ssl) {
+                c->ssl->no_send_shutdown = 1;
+            }
+#endif
+            ngx_http_close_connection(c);
+            return;
+        }
+    }
+
+#endif
+
+    c->destroyed = 0;
+    c->idle = 0;
+    ngx_reusable_connection(c, 0);
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);
+    if (h2c->pool == NULL) {
+        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR);
+        return;
+    }
+
+    c->write->handler = ngx_http_v2_write_handler;
+
+    rev->handler = ngx_http_v2_read_handler;
+    ngx_http_v2_read_handler(rev);
+}
+
+
+static void
+ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t status)
+{
+    ngx_uint_t               i, size;
+    ngx_event_t             *ev;
+    ngx_connection_t        *c, *fc;
+    ngx_http_request_t      *r;
+    ngx_http_v2_node_t      *node;
+    ngx_http_v2_stream_t    *stream;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    c = h2c->connection;
+
+    h2c->blocked = 1;
+
+    if (!c->error && ngx_http_v2_send_goaway(h2c, status) != NGX_ERROR) {
+        (void) ngx_http_v2_send_output_queue(h2c);
+    }
+
+    if (!h2c->processing) {
+        ngx_http_close_connection(c);
+        return;
+    }
+
+    c->error = 1;
+    c->read->handler = ngx_http_empty_handler;
+    c->write->handler = ngx_http_empty_handler;
+
+    h2c->last_out = NULL;
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    size = ngx_http_v2_index_size(h2scf);
+
+    for (i = 0; i < size; i++) {
+
+        for (node = h2c->streams_index[i]; node; node = node->index) {
+            stream = node->stream;
+
+            if (stream == NULL) {
+                continue;
+            }
+
+            stream->handled = 0;
+
+            r = stream->request;
+            fc = r->connection;
+
+            fc->error = 1;
+
+            if (stream->queued) {
+                stream->queued = 0;
+
+                ev = fc->write;
+                ev->delayed = 0;
+
+            } else {
+                ev = fc->read;
+            }
+
+            ev->eof = 1;
+            ev->handler(ev);
+        }
+    }
+
+    h2c->blocked = 0;
+
+    if (h2c->processing) {
+        return;
+    }
+
+    ngx_http_close_connection(c);
+}
+
+
+static ngx_int_t
+ngx_http_v2_adjust_windows(ngx_http_v2_connection_t *h2c, ssize_t delta)
+{
+    ngx_uint_t               i, size;
+    ngx_event_t             *wev;
+    ngx_http_v2_node_t      *node;
+    ngx_http_v2_stream_t    *stream;
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,
+                                         ngx_http_v2_module);
+
+    size = ngx_http_v2_index_size(h2scf);
+
+    for (i = 0; i < size; i++) {
+
+        for (node = h2c->streams_index[i]; node; node = node->index) {
+            stream = node->stream;
+
+            if (stream == NULL) {
+                continue;
+            }
+
+            if (delta > 0
+                && stream->send_window
+                      > (ssize_t) (NGX_HTTP_V2_MAX_WINDOW - delta))
+            {
+                if (ngx_http_v2_terminate_stream(h2c, stream,
+                                                 NGX_HTTP_V2_FLOW_CTRL_ERROR)
+                    == NGX_ERROR)
+                {
+                    return NGX_ERROR;
+                }
+
+                continue;
+            }
+
+            stream->send_window += delta;
+
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                           "http2:%ui adjusted window: %z",
+                           node->id, stream->send_window);
+
+            if (stream->send_window > 0 && stream->exhausted) {
+                stream->exhausted = 0;
+
+                wev = stream->request->connection->write;
+
+                if (!wev->timer_set) {
+                    wev->delayed = 0;
+                    wev->handler(wev);
+                }
+            }
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_v2_set_dependency(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_node_t *node, ngx_uint_t depend, ngx_uint_t exclusive)
+{
+    ngx_queue_t         *children;
+    ngx_http_v2_node_t  *parent, *next;
+
+    parent = depend ? ngx_http_v2_get_node_by_id(h2c, depend, 0) : NULL;
+
+    if (parent == NULL) {
+        parent = NGX_HTTP_V2_ROOT;
+
+        if (depend != 0) {
+            exclusive = 0;
+        }
+
+        node->rank = 1;
+        node->rel_weight = (1.0 / 256) * node->weight;
+
+        children = &h2c->dependencies;
+
+    } else {
+        if (node->parent != NULL) {
+
+            for (next = parent->parent;
+                 next != NGX_HTTP_V2_ROOT && next->rank >= node->rank;
+                 next = next->parent)
+            {
+                if (next != node) {
+                    continue;
+                }
+
+                ngx_queue_remove(&parent->queue);
+                ngx_queue_insert_after(&node->queue, &parent->queue);
+
+                parent->parent = node->parent;
+
+                if (node->parent == NGX_HTTP_V2_ROOT) {
+                    parent->rank = 1;
+                    parent->rel_weight = (1.0 / 256) * parent->weight;
+
+                } else {
+                    parent->rank = node->parent->rank + 1;
+                    parent->rel_weight = (node->parent->rel_weight / 256)
+                                         * parent->weight;
+                }
+
+                if (!exclusive) {
+                    ngx_http_v2_node_children_update(parent);
+                }
+
+                break;
+            }
+        }
+
+        node->rank = parent->rank + 1;
+        node->rel_weight = (parent->rel_weight / 256) * node->weight;
+
+        if (parent->stream == NULL) {
+            ngx_queue_remove(&parent->reuse);
+            ngx_queue_insert_tail(&h2c->closed, &parent->reuse);
+        }
+
+        children = &parent->children;
+    }
+
+    if (exclusive) {
+        ngx_queue_add(&node->children, children);
+        ngx_queue_init(children);
+    }
+
+    if (node->parent != NULL) {
+        ngx_queue_remove(&node->queue);
+    }
+
+    ngx_queue_insert_tail(children, &node->queue);
+
+    node->parent = parent;
+
+    ngx_http_v2_node_children_update(node);
+}
+
+
+static void
+ngx_http_v2_node_children_update(ngx_http_v2_node_t *node)
+{
+    ngx_queue_t         *q;
+    ngx_http_v2_node_t  *child;
+
+    for (q = ngx_queue_head(&node->children);
+         q != ngx_queue_sentinel(&node->children);
+         q = ngx_queue_next(q))
+    {
+        child = ngx_queue_data(q, ngx_http_v2_node_t, queue);
+
+        child->rank = node->rank + 1;
+        child->rel_weight = (node->rel_weight / 256) * child->weight;
+
+        ngx_http_v2_node_children_update(child);
+    }
+}
+
+
+static void
+ngx_http_v2_pool_cleanup(void *data)
+{
+    ngx_http_v2_connection_t  *h2c = data;
+
+    if (h2c->state.pool) {
+        ngx_destroy_pool(h2c->state.pool);
+    }
+
+    if (h2c->pool) {
+        ngx_destroy_pool(h2c->pool);
+    }
+}
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2.h	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#ifndef _NGX_HTTP_V2_H_INCLUDED_
+#define _NGX_HTTP_V2_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+#define NGX_HTTP_V2_ALPN_ADVERTISE       "\x02h2"
+#define NGX_HTTP_V2_NPN_ADVERTISE        NGX_HTTP_V2_ALPN_ADVERTISE
+
+#define NGX_HTTP_V2_STATE_BUFFER_SIZE    16
+
+#define NGX_HTTP_V2_MAX_FRAME_SIZE       ((1 << 24) - 1)
+
+#define NGX_HTTP_V2_INT_OCTETS           4
+#define NGX_HTTP_V2_MAX_FIELD            ((1 << NGX_HTTP_V2_INT_OCTETS * 7) - 1)
+
+#define NGX_HTTP_V2_DATA_DISCARD         1
+#define NGX_HTTP_V2_DATA_ERROR           2
+#define NGX_HTTP_V2_DATA_INTERNAL_ERROR  3
+
+#define NGX_HTTP_V2_FRAME_HEADER_SIZE    9
+
+/* frame types */
+#define NGX_HTTP_V2_DATA_FRAME           0x0
+#define NGX_HTTP_V2_HEADERS_FRAME        0x1
+#define NGX_HTTP_V2_PRIORITY_FRAME       0x2
+#define NGX_HTTP_V2_RST_STREAM_FRAME     0x3
+#define NGX_HTTP_V2_SETTINGS_FRAME       0x4
+#define NGX_HTTP_V2_PUSH_PROMISE_FRAME   0x5
+#define NGX_HTTP_V2_PING_FRAME           0x6
+#define NGX_HTTP_V2_GOAWAY_FRAME         0x7
+#define NGX_HTTP_V2_WINDOW_UPDATE_FRAME  0x8
+#define NGX_HTTP_V2_CONTINUATION_FRAME   0x9
+
+/* frame flags */
+#define NGX_HTTP_V2_NO_FLAG              0x00
+#define NGX_HTTP_V2_ACK_FLAG             0x01
+#define NGX_HTTP_V2_END_STREAM_FLAG      0x01
+#define NGX_HTTP_V2_END_HEADERS_FLAG     0x04
+#define NGX_HTTP_V2_PADDED_FLAG          0x08
+#define NGX_HTTP_V2_PRIORITY_FLAG        0x20
+
+
+typedef struct ngx_http_v2_connection_s   ngx_http_v2_connection_t;
+typedef struct ngx_http_v2_node_s         ngx_http_v2_node_t;
+typedef struct ngx_http_v2_out_frame_s    ngx_http_v2_out_frame_t;
+
+
+typedef u_char *(*ngx_http_v2_handler_pt) (ngx_http_v2_connection_t *h2c,
+    u_char *pos, u_char *end);
+
+
+typedef struct {
+    ngx_str_t                        name;
+    ngx_str_t                        value;
+} ngx_http_v2_header_t;
+
+
+typedef struct {
+    ngx_uint_t                       sid;
+    size_t                           length;
+    size_t                           padding;
+    unsigned                         flags:8;
+
+    unsigned                         incomplete:1;
+
+    /* HPACK */
+    unsigned                         parse_name:1;
+    unsigned                         parse_value:1;
+    unsigned                         index:1;
+    ngx_http_v2_header_t             header;
+    size_t                           header_limit;
+    size_t                           field_limit;
+    u_char                           field_state;
+    u_char                          *field_start;
+    u_char                          *field_end;
+    size_t                           field_rest;
+    ngx_pool_t                      *pool;
+
+    ngx_http_v2_stream_t            *stream;
+
+    u_char                           buffer[NGX_HTTP_V2_STATE_BUFFER_SIZE];
+    size_t                           buffer_used;
+    ngx_http_v2_handler_pt           handler;
+} ngx_http_v2_state_t;
+
+
+
+typedef struct {
+    ngx_http_v2_header_t           **entries;
+
+    ngx_uint_t                       added;
+    ngx_uint_t                       deleted;
+    ngx_uint_t                       reused;
+    ngx_uint_t                       allocated;
+
+    size_t                           size;
+    size_t                           free;
+    u_char                          *storage;
+    u_char                          *pos;
+} ngx_http_v2_hpack_t;
+
+
+struct ngx_http_v2_connection_s {
+    ngx_connection_t                *connection;
+    ngx_http_connection_t           *http_connection;
+
+    ngx_uint_t                       processing;
+
+    size_t                           send_window;
+    size_t                           recv_window;
+    size_t                           init_window;
+
+    size_t                           frame_size;
+
+    ngx_queue_t                      waiting;
+
+    ngx_http_v2_state_t              state;
+
+    ngx_http_v2_hpack_t              hpack;
+
+    ngx_pool_t                      *pool;
+
+    ngx_http_v2_out_frame_t         *free_frames;
+    ngx_connection_t                *free_fake_connections;
+
+    ngx_http_v2_node_t             **streams_index;
+
+    ngx_http_v2_out_frame_t         *last_out;
+
+    ngx_queue_t                      posted;
+    ngx_queue_t                      dependencies;
+    ngx_queue_t                      closed;
+
+    ngx_uint_t                       last_sid;
+
+    unsigned                         closed_nodes:8;
+    unsigned                         blocked:1;
+};
+
+
+struct ngx_http_v2_node_s {
+    ngx_uint_t                       id;
+    ngx_http_v2_node_t              *index;
+    ngx_http_v2_node_t              *parent;
+    ngx_queue_t                      queue;
+    ngx_queue_t                      children;
+    ngx_queue_t                      reuse;
+    ngx_uint_t                       rank;
+    ngx_uint_t                       weight;
+    double                           rel_weight;
+    ngx_http_v2_stream_t            *stream;
+};
+
+
+struct ngx_http_v2_stream_s {
+    ngx_http_request_t              *request;
+    ngx_http_v2_connection_t        *connection;
+    ngx_http_v2_node_t              *node;
+
+    ngx_uint_t                       header_buffers;
+    ngx_uint_t                       queued;
+
+    /*
+     * A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the
+     * send_window to become negative, hence it's signed.
+     */
+    ssize_t                          send_window;
+    size_t                           recv_window;
+
+    ngx_http_v2_out_frame_t         *free_frames;
+    ngx_chain_t                     *free_data_headers;
+    ngx_chain_t                     *free_bufs;
+
+    ngx_queue_t                      queue;
+
+    ngx_array_t                     *cookies;
+
+    size_t                           header_limit;
+
+    unsigned                         handled:1;
+    unsigned                         blocked:1;
+    unsigned                         exhausted:1;
+    unsigned                         end_headers:1;
+    unsigned                         in_closed:1;
+    unsigned                         out_closed:1;
+    unsigned                         skip_data:2;
+};
+
+
+struct ngx_http_v2_out_frame_s {
+    ngx_http_v2_out_frame_t         *next;
+    ngx_chain_t                     *first;
+    ngx_chain_t                     *last;
+    ngx_int_t                      (*handler)(ngx_http_v2_connection_t *h2c,
+                                        ngx_http_v2_out_frame_t *frame);
+
+    ngx_http_v2_stream_t            *stream;
+    size_t                           length;
+
+    unsigned                         blocked:1;
+    unsigned                         fin:1;
+};
+
+
+static ngx_inline void
+ngx_http_v2_queue_frame(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_http_v2_out_frame_t  **out;
+
+    for (out = &h2c->last_out; *out; out = &(*out)->next) {
+
+        if ((*out)->blocked || (*out)->stream == NULL) {
+            break;
+        }
+
+        if ((*out)->stream->node->rank < frame->stream->node->rank
+            || ((*out)->stream->node->rank == frame->stream->node->rank
+                && (*out)->stream->node->rel_weight
+                   >= frame->stream->node->rel_weight))
+        {
+            break;
+        }
+    }
+
+    frame->next = *out;
+    *out = frame;
+}
+
+
+static ngx_inline void
+ngx_http_v2_queue_blocked_frame(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_http_v2_out_frame_t  **out;
+
+    for (out = &h2c->last_out; *out; out = &(*out)->next)
+    {
+        if ((*out)->blocked || (*out)->stream == NULL) {
+            break;
+        }
+    }
+
+    frame->next = *out;
+    *out = frame;
+}
+
+
+void ngx_http_v2_init(ngx_event_t *rev);
+void ngx_http_v2_request_headers_init(void);
+
+ngx_int_t ngx_http_v2_read_request_body(ngx_http_request_t *r,
+    ngx_http_client_body_handler_pt post_handler);
+
+void ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc);
+
+ngx_int_t ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c);
+
+
+ngx_int_t ngx_http_v2_get_indexed_header(ngx_http_v2_connection_t *h2c,
+    ngx_uint_t index, ngx_uint_t name_only);
+ngx_int_t ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_header_t *header);
+ngx_int_t ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size);
+
+
+ngx_int_t ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len,
+    u_char **dst, ngx_uint_t last, ngx_log_t *log);
+
+
+#define ngx_http_v2_prefix(bits)  ((1 << (bits)) - 1)
+
+
+#if (NGX_HAVE_NONALIGNED)
+
+#define ngx_http_v2_parse_uint16(p)  ntohs(*(uint16_t *) (p))
+#define ngx_http_v2_parse_uint32(p)  ntohl(*(uint32_t *) (p))
+
+#else
+
+#define ngx_http_v2_parse_uint16(p)  ((p)[0] << 8 | (p)[1])
+#define ngx_http_v2_parse_uint32(p)                                           \
+    ((p)[0] << 24 | (p)[1] << 16 | (p)[2] << 8 | (p)[3])
+
+#endif
+
+#define ngx_http_v2_parse_length(p)  ((p) >> 8)
+#define ngx_http_v2_parse_type(p)    ((p) & 0xff)
+#define ngx_http_v2_parse_sid(p)     (ngx_http_v2_parse_uint32(p) & 0x7fffffff)
+#define ngx_http_v2_parse_window(p)  (ngx_http_v2_parse_uint32(p) & 0x7fffffff)
+
+
+#define ngx_http_v2_write_uint16_aligned(p, s)                                \
+    (*(uint16_t *) (p) = htons((uint16_t) (s)), (p) + sizeof(uint16_t))
+#define ngx_http_v2_write_uint32_aligned(p, s)                                \
+    (*(uint32_t *) (p) = htonl((uint32_t) (s)), (p) + sizeof(uint32_t))
+
+#if (NGX_HAVE_NONALIGNED)
+
+#define ngx_http_v2_write_uint16  ngx_http_v2_write_uint16_aligned
+#define ngx_http_v2_write_uint32  ngx_http_v2_write_uint32_aligned
+
+#else
+
+#define ngx_http_v2_write_uint16(p, s)                                        \
+    ((p)[0] = (u_char) ((s) >> 8),                                            \
+     (p)[1] = (u_char)  (s),                                                  \
+     (p) + sizeof(uint16_t))
+
+#define ngx_http_v2_write_uint32(p, s)                                        \
+    ((p)[0] = (u_char) ((s) >> 24),                                           \
+     (p)[1] = (u_char) ((s) >> 16),                                           \
+     (p)[2] = (u_char) ((s) >> 8),                                            \
+     (p)[3] = (u_char)  (s),                                                  \
+     (p) + sizeof(uint32_t))
+
+#endif
+
+#define ngx_http_v2_write_len_and_type(p, l, t)                               \
+    ngx_http_v2_write_uint32_aligned(p, (l) << 8 | (t))
+
+#define ngx_http_v2_write_sid  ngx_http_v2_write_uint32
+
+#endif /* _NGX_HTTP_V2_H_INCLUDED_ */
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_filter_module.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_filter_module.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,1290 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <nginx.h>
+#include <ngx_http_v2_module.h>
+
+
+#define ngx_http_v2_integer_octets(v)  (((v) + 127) / 128)
+
+#define ngx_http_v2_literal_size(h)                                           \
+    (ngx_http_v2_integer_octets(sizeof(h) - 1) + sizeof(h) - 1)
+
+#define ngx_http_v2_indexed(i)      (128 + (i))
+#define ngx_http_v2_inc_indexed(i)  (64 + (i))
+
+
+#define NGX_HTTP_V2_STATUS_INDEX          8
+#define NGX_HTTP_V2_STATUS_200_INDEX      8
+#define NGX_HTTP_V2_STATUS_204_INDEX      9
+#define NGX_HTTP_V2_STATUS_206_INDEX      10
+#define NGX_HTTP_V2_STATUS_304_INDEX      11
+#define NGX_HTTP_V2_STATUS_400_INDEX      12
+#define NGX_HTTP_V2_STATUS_404_INDEX      13
+#define NGX_HTTP_V2_STATUS_500_INDEX      14
+
+#define NGX_HTTP_V2_CONTENT_LENGTH_INDEX  28
+#define NGX_HTTP_V2_CONTENT_TYPE_INDEX    31
+#define NGX_HTTP_V2_DATE_INDEX            33
+#define NGX_HTTP_V2_LAST_MODIFIED_INDEX   44
+#define NGX_HTTP_V2_LOCATION_INDEX        46
+#define NGX_HTTP_V2_SERVER_INDEX          54
+#define NGX_HTTP_V2_VARY_INDEX            59
+
+
+static u_char *ngx_http_v2_write_int(u_char *pos, ngx_uint_t prefix,
+    ngx_uint_t value);
+static void ngx_http_v2_write_headers_head(u_char *pos, size_t length,
+    ngx_uint_t sid, ngx_uint_t end_headers, ngx_uint_t end_stream);
+static void ngx_http_v2_write_continuation_head(u_char *pos, size_t length,
+    ngx_uint_t sid, ngx_uint_t end_headers);
+
+static ngx_chain_t *ngx_http_v2_send_chain(ngx_connection_t *fc,
+    ngx_chain_t *in, off_t limit);
+
+static ngx_chain_t *ngx_http_v2_filter_get_shadow(
+    ngx_http_v2_stream_t *stream, ngx_buf_t *buf, off_t offset, off_t size);
+static ngx_http_v2_out_frame_t *ngx_http_v2_filter_get_data_frame(
+    ngx_http_v2_stream_t *stream, size_t len, ngx_chain_t *first,
+    ngx_chain_t *last);
+
+static ngx_inline ngx_int_t ngx_http_v2_flow_control(
+    ngx_http_v2_connection_t *h2c, ngx_http_v2_stream_t *stream);
+static void ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream);
+
+static ngx_inline ngx_int_t ngx_http_v2_filter_send(
+    ngx_connection_t *fc, ngx_http_v2_stream_t *stream);
+
+static ngx_int_t ngx_http_v2_headers_frame_handler(
+    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);
+static ngx_int_t ngx_http_v2_data_frame_handler(
+    ngx_http_v2_connection_t *h2c, ngx_http_v2_out_frame_t *frame);
+static ngx_inline void ngx_http_v2_handle_frame(
+    ngx_http_v2_stream_t *stream, ngx_http_v2_out_frame_t *frame);
+static ngx_inline void ngx_http_v2_handle_stream(
+    ngx_http_v2_connection_t *h2c, ngx_http_v2_stream_t *stream);
+
+static void ngx_http_v2_filter_cleanup(void *data);
+
+static ngx_int_t ngx_http_v2_filter_init(ngx_conf_t *cf);
+
+
+static ngx_http_module_t  ngx_http_v2_filter_module_ctx = {
+    NULL,                                  /* preconfiguration */
+    ngx_http_v2_filter_init,               /* postconfiguration */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+
+    NULL,                                  /* create location configuration */
+    NULL                                   /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_http_v2_filter_module = {
+    NGX_MODULE_V1,
+    &ngx_http_v2_filter_module_ctx,        /* module context */
+    NULL,                                  /* module directives */
+    NGX_HTTP_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
+
+
+static ngx_int_t
+ngx_http_v2_header_filter(ngx_http_request_t *r)
+{
+    u_char                     status, *p, *head;
+    size_t                     len, rest;
+    ngx_buf_t                 *b;
+    ngx_str_t                  host, location;
+    ngx_uint_t                 i, port, continuation;
+    ngx_chain_t               *cl;
+    ngx_list_part_t           *part;
+    ngx_table_elt_t           *header;
+    ngx_connection_t          *fc;
+    ngx_http_cleanup_t        *cln;
+    ngx_http_v2_stream_t      *stream;
+    ngx_http_v2_out_frame_t   *frame;
+    ngx_http_core_loc_conf_t  *clcf;
+    ngx_http_core_srv_conf_t  *cscf;
+    struct sockaddr_in        *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6       *sin6;
+#endif
+    u_char                     addr[NGX_SOCKADDR_STRLEN];
+
+
+    if (!r->stream) {
+        return ngx_http_next_header_filter(r);
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http2 header filter");
+
+    if (r->header_sent) {
+        return NGX_OK;
+    }
+
+    r->header_sent = 1;
+
+    if (r != r->main) {
+        return NGX_OK;
+    }
+
+    if (r->method == NGX_HTTP_HEAD) {
+        r->header_only = 1;
+    }
+
+    switch (r->headers_out.status) {
+
+    case NGX_HTTP_OK:
+        status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_200_INDEX);
+        break;
+
+    case NGX_HTTP_NO_CONTENT:
+        r->header_only = 1;
+
+        ngx_str_null(&r->headers_out.content_type);
+
+        r->headers_out.content_length = NULL;
+        r->headers_out.content_length_n = -1;
+
+        r->headers_out.last_modified_time = -1;
+        r->headers_out.last_modified = NULL;
+
+        status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_204_INDEX);
+        break;
+
+    case NGX_HTTP_PARTIAL_CONTENT:
+        status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_206_INDEX);
+        break;
+
+    case NGX_HTTP_NOT_MODIFIED:
+        r->header_only = 1;
+        status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_304_INDEX);
+        break;
+
+    default:
+        r->headers_out.last_modified_time = -1;
+        r->headers_out.last_modified = NULL;
+
+        switch (r->headers_out.status) {
+
+        case NGX_HTTP_BAD_REQUEST:
+            status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_400_INDEX);
+            break;
+
+        case NGX_HTTP_NOT_FOUND:
+            status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_404_INDEX);
+            break;
+
+        case NGX_HTTP_INTERNAL_SERVER_ERROR:
+            status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_500_INDEX);
+            break;
+
+        default:
+            status = 0;
+        }
+    }
+
+    len = NGX_HTTP_V2_FRAME_HEADER_SIZE
+          + (status ? 1 : 1 + ngx_http_v2_literal_size("418"));
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (r->headers_out.server == NULL) {
+        len += 1 + clcf->server_tokens ? ngx_http_v2_literal_size(NGINX_VER)
+                                       : ngx_http_v2_literal_size("nginx");
+    }
+
+    if (r->headers_out.date == NULL) {
+        len += 1 + ngx_http_v2_literal_size("Wed, 31 Dec 1986 18:00:00 GMT");
+    }
+
+    if (r->headers_out.content_type.len) {
+        len += NGX_HTTP_V2_INT_OCTETS + r->headers_out.content_type.len;
+
+        if (r->headers_out.content_type_len == r->headers_out.content_type.len
+            && r->headers_out.charset.len)
+        {
+            len += sizeof("; charset=") - 1 + r->headers_out.charset.len;
+        }
+    }
+
+    if (r->headers_out.content_length == NULL
+        && r->headers_out.content_length_n >= 0)
+    {
+        len += 1 + ngx_http_v2_integer_octets(NGX_OFF_T_LEN) + NGX_OFF_T_LEN;
+    }
+
+    if (r->headers_out.last_modified == NULL
+        && r->headers_out.last_modified_time != -1)
+    {
+        len += 1 + ngx_http_v2_literal_size("Wed, 31 Dec 1986 18:00:00 GMT");
+    }
+
+    fc = r->connection;
+
+    if (r->headers_out.location && r->headers_out.location->value.len) {
+
+        if (r->headers_out.location->value.data[0] == '/') {
+            if (clcf->server_name_in_redirect) {
+                cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
+                host = cscf->server_name;
+
+            } else if (r->headers_in.server.len) {
+                host = r->headers_in.server;
+
+            } else {
+                host.len = NGX_SOCKADDR_STRLEN;
+                host.data = addr;
+
+                if (ngx_connection_local_sockaddr(fc, &host, 0) != NGX_OK) {
+                    return NGX_ERROR;
+                }
+            }
+
+            switch (fc->local_sockaddr->sa_family) {
+
+#if (NGX_HAVE_INET6)
+            case AF_INET6:
+                sin6 = (struct sockaddr_in6 *) fc->local_sockaddr;
+                port = ntohs(sin6->sin6_port);
+                break;
+#endif
+#if (NGX_HAVE_UNIX_DOMAIN)
+            case AF_UNIX:
+                port = 0;
+                break;
+#endif
+            default: /* AF_INET */
+                sin = (struct sockaddr_in *) fc->local_sockaddr;
+                port = ntohs(sin->sin_port);
+                break;
+            }
+
+            location.len = sizeof("https://") - 1 + host.len
+                           + r->headers_out.location->value.len;
+
+            if (clcf->port_in_redirect) {
+
+#if (NGX_HTTP_SSL)
+                if (fc->ssl)
+                    port = (port == 443) ? 0 : port;
+                else
+#endif
+                    port = (port == 80) ? 0 : port;
+
+            } else {
+                port = 0;
+            }
+
+            if (port) {
+                location.len += sizeof(":65535") - 1;
+            }
+
+            location.data = ngx_pnalloc(r->pool, location.len);
+            if (location.data == NULL) {
+                return NGX_ERROR;
+            }
+
+            p = ngx_cpymem(location.data, "http", sizeof("http") - 1);
+
+#if (NGX_HTTP_SSL)
+            if (fc->ssl) {
+                *p++ = 's';
+            }
+#endif
+
+            *p++ = ':'; *p++ = '/'; *p++ = '/';
+            p = ngx_cpymem(p, host.data, host.len);
+
+            if (port) {
+                p = ngx_sprintf(p, ":%ui", port);
+            }
+
+            p = ngx_cpymem(p, r->headers_out.location->value.data,
+                              r->headers_out.location->value.len);
+
+            /* update r->headers_out.location->value for possible logging */
+
+            r->headers_out.location->value.len = p - location.data;
+            r->headers_out.location->value.data = location.data;
+            ngx_str_set(&r->headers_out.location->key, "Location");
+        }
+
+        r->headers_out.location->hash = 0;
+
+        len += 1 + NGX_HTTP_V2_INT_OCTETS + r->headers_out.location->value.len;
+    }
+
+#if (NGX_HTTP_GZIP)
+    if (r->gzip_vary) {
+        if (clcf->gzip_vary) {
+            len += 1 + ngx_http_v2_literal_size("Accept-Encoding");
+
+        } else {
+            r->gzip_vary = 0;
+        }
+    }
+#endif
+
+    part = &r->headers_out.headers.part;
+    header = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            header = part->elts;
+            i = 0;
+        }
+
+        if (header[i].hash == 0) {
+            continue;
+        }
+
+        if (header[i].key.len > NGX_HTTP_V2_MAX_FIELD) {
+            ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
+                          "too long response header name: \"%V\"",
+                          &header[i].key);
+            return NGX_ERROR;
+        }
+
+        if (header[i].value.len > NGX_HTTP_V2_MAX_FIELD) {
+            ngx_log_error(NGX_LOG_CRIT, r->connection->log, 0,
+                          "too long response header value: \"%V: %V\"",
+                          &header[i].key, &header[i].value);
+            return NGX_ERROR;
+        }
+
+        len += NGX_HTTP_V2_INT_OCTETS + header[i].key.len
+               + NGX_HTTP_V2_INT_OCTETS + header[i].value.len;
+    }
+
+    stream = r->stream;
+
+    len += NGX_HTTP_V2_FRAME_HEADER_SIZE
+           * (len / stream->connection->frame_size);
+
+    b = ngx_create_temp_buf(r->pool, len);
+    if (b == NULL) {
+        return NGX_ERROR;
+    }
+
+    b->last_buf = r->header_only;
+
+    b->last += NGX_HTTP_V2_FRAME_HEADER_SIZE;
+
+    if (status) {
+        *b->last++ = status;
+
+    } else {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_STATUS_INDEX);
+        *b->last++ = 3;
+        b->last = ngx_sprintf(b->last, "%03ui", r->headers_out.status);
+    }
+
+    if (r->headers_out.server == NULL) {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_SERVER_INDEX);
+
+        if (clcf->server_tokens) {
+            *b->last++ = sizeof(NGINX_VER) - 1;
+            b->last = ngx_cpymem(b->last, NGINX_VER, sizeof(NGINX_VER) - 1);
+
+        } else {
+            *b->last++ = sizeof("nginx") - 1;
+            b->last = ngx_cpymem(b->last, "nginx", sizeof("nginx") - 1);
+        }
+    }
+
+    if (r->headers_out.date == NULL) {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_DATE_INDEX);
+        *b->last++ = (u_char) ngx_cached_http_time.len;
+
+        b->last = ngx_cpymem(b->last, ngx_cached_http_time.data,
+                             ngx_cached_http_time.len);
+    }
+
+    if (r->headers_out.content_type.len) {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_CONTENT_TYPE_INDEX);
+
+        if (r->headers_out.content_type_len == r->headers_out.content_type.len
+            && r->headers_out.charset.len)
+        {
+            *b->last = 0;
+            b->last = ngx_http_v2_write_int(b->last, ngx_http_v2_prefix(7),
+                                            r->headers_out.content_type.len
+                                            + sizeof("; charset=") - 1
+                                            + r->headers_out.charset.len);
+
+            p = b->last;
+
+            b->last = ngx_cpymem(p, r->headers_out.content_type.data,
+                                 r->headers_out.content_type.len);
+
+            b->last = ngx_cpymem(b->last, "; charset=",
+                                 sizeof("; charset=") - 1);
+
+            b->last = ngx_cpymem(b->last, r->headers_out.charset.data,
+                                 r->headers_out.charset.len);
+
+            /* update r->headers_out.content_type for possible logging */
+
+            r->headers_out.content_type.len = b->last - p;
+            r->headers_out.content_type.data = p;
+
+        } else {
+            *b->last = 0;
+            b->last = ngx_http_v2_write_int(b->last, ngx_http_v2_prefix(7),
+                                            r->headers_out.content_type.len);
+            b->last = ngx_cpymem(b->last, r->headers_out.content_type.data,
+                                 r->headers_out.content_type.len);
+        }
+    }
+
+    if (r->headers_out.content_length == NULL
+        && r->headers_out.content_length_n >= 0)
+    {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_CONTENT_LENGTH_INDEX);
+
+        p = b->last;
+        b->last = ngx_sprintf(b->last + 1, "%O",
+                              r->headers_out.content_length_n);
+        *p = (u_char) (b->last - p - 1);
+    }
+
+    if (r->headers_out.last_modified == NULL
+        && r->headers_out.last_modified_time != -1)
+    {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_LAST_MODIFIED_INDEX);
+
+        p = b->last;
+        b->last = ngx_http_time(b->last + 1, r->headers_out.last_modified_time);
+        *p = (u_char) (b->last - p - 1);
+    }
+
+    if (r->headers_out.location && r->headers_out.location->value.len) {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_LOCATION_INDEX);
+
+        *b->last = 0;
+        b->last = ngx_http_v2_write_int(b->last, ngx_http_v2_prefix(7),
+                                        r->headers_out.location->value.len);
+        b->last = ngx_cpymem(b->last, r->headers_out.location->value.data,
+                                      r->headers_out.location->value.len);
+    }
+
+#if (NGX_HTTP_GZIP)
+    if (r->gzip_vary) {
+        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_VARY_INDEX);
+        *b->last++ = sizeof("Accept-Encoding") - 1;
+        b->last = ngx_cpymem(b->last, "Accept-Encoding",
+                             sizeof("Accept-Encoding") - 1);
+    }
+#endif
+
+    continuation = 0;
+    head = b->pos;
+
+    len = b->last - head - NGX_HTTP_V2_FRAME_HEADER_SIZE;
+    rest = stream->connection->frame_size - len;
+
+    part = &r->headers_out.headers.part;
+    header = part->elts;
+
+    for (i = 0; /* void */; i++) {
+
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                break;
+            }
+
+            part = part->next;
+            header = part->elts;
+            i = 0;
+        }
+
+        if (header[i].hash == 0) {
+            continue;
+        }
+
+        len = 1 + NGX_HTTP_V2_INT_OCTETS * 2
+              + header[i].key.len
+              + header[i].value.len;
+
+        if (len > rest) {
+            len = b->last - head - NGX_HTTP_V2_FRAME_HEADER_SIZE;
+
+            if (continuation) {
+                ngx_http_v2_write_continuation_head(head, len,
+                                                    stream->node->id, 0);
+            } else {
+                continuation = 1;
+                ngx_http_v2_write_headers_head(head, len, stream->node->id, 0,
+                                               r->header_only);
+            }
+
+            rest = stream->connection->frame_size;
+            head = b->last;
+
+            b->last += NGX_HTTP_V2_FRAME_HEADER_SIZE;
+        }
+
+        p = b->last;
+
+        *p++ = 0;
+
+        *p = 0;
+        p = ngx_http_v2_write_int(p, ngx_http_v2_prefix(7), header[i].key.len);
+        ngx_strlow(p, header[i].key.data, header[i].key.len);
+        p += header[i].key.len;
+
+        *p = 0;
+        p = ngx_http_v2_write_int(p, ngx_http_v2_prefix(7),
+                                  header[i].value.len);
+        p = ngx_cpymem(p, header[i].value.data, header[i].value.len);
+
+        rest -= p - b->last;
+        b->last = p;
+    }
+
+    len = b->last - head - NGX_HTTP_V2_FRAME_HEADER_SIZE;
+
+    if (continuation) {
+        ngx_http_v2_write_continuation_head(head, len, stream->node->id, 1);
+
+    } else {
+        ngx_http_v2_write_headers_head(head, len, stream->node->id, 1,
+                                       r->header_only);
+    }
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    cl->buf = b;
+    cl->next = NULL;
+
+    frame = ngx_palloc(r->pool, sizeof(ngx_http_v2_out_frame_t));
+    if (frame == NULL) {
+        return NGX_ERROR;
+    }
+
+    frame->first = cl;
+    frame->last = cl;
+    frame->handler = ngx_http_v2_headers_frame_handler;
+    frame->stream = stream;
+    frame->length = b->last - b->pos - NGX_HTTP_V2_FRAME_HEADER_SIZE;
+    frame->blocked = 1;
+    frame->fin = r->header_only;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, stream->request->connection->log, 0,
+                   "http2:%ui create HEADERS frame %p: len:%uz",
+                   stream->node->id, frame, frame->length);
+
+    ngx_http_v2_queue_blocked_frame(stream->connection, frame);
+
+    cln = ngx_http_cleanup_add(r, 0);
+    if (cln == NULL) {
+        return NGX_ERROR;
+    }
+
+    cln->handler = ngx_http_v2_filter_cleanup;
+    cln->data = stream;
+
+    stream->queued = 1;
+
+    fc->send_chain = ngx_http_v2_send_chain;
+    fc->need_last_buf = 1;
+
+    return ngx_http_v2_filter_send(fc, stream);
+}
+
+
+static u_char *
+ngx_http_v2_write_int(u_char *pos, ngx_uint_t prefix, ngx_uint_t value)
+{
+    if (value < prefix) {
+        *pos++ |= value;
+        return pos;
+    }
+
+    *pos++ |= prefix;
+    value -= prefix;
+
+    while (value >= 128) {
+        *pos++ = value % 128 + 128;
+        value /= 128;
+    }
+
+    *pos++ = (u_char) value;
+
+    return pos;
+}
+
+
+static void
+ngx_http_v2_write_headers_head(u_char *pos, size_t length, ngx_uint_t sid,
+    ngx_uint_t end_headers, ngx_uint_t end_stream)
+{
+    u_char  flags;
+
+    pos = ngx_http_v2_write_len_and_type(pos, length,
+                                         NGX_HTTP_V2_HEADERS_FRAME);
+
+    flags = NGX_HTTP_V2_NO_FLAG;
+
+    if (end_headers) {
+        flags |= NGX_HTTP_V2_END_HEADERS_FLAG;
+    }
+
+    if (end_stream) {
+        flags |= NGX_HTTP_V2_END_STREAM_FLAG;
+    }
+
+    *pos++ = flags;
+
+    (void) ngx_http_v2_write_sid(pos, sid);
+}
+
+
+static void
+ngx_http_v2_write_continuation_head(u_char *pos, size_t length, ngx_uint_t sid,
+    ngx_uint_t end_headers)
+{
+    pos = ngx_http_v2_write_len_and_type(pos, length,
+                                         NGX_HTTP_V2_CONTINUATION_FRAME);
+
+    *pos++ = end_headers ? NGX_HTTP_V2_END_HEADERS_FLAG : NGX_HTTP_V2_NO_FLAG;
+
+    (void) ngx_http_v2_write_sid(pos, sid);
+}
+
+
+static ngx_chain_t *
+ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)
+{
+    off_t                      size, offset;
+    size_t                     rest, frame_size;
+    ngx_chain_t               *cl, *out, **ln;
+    ngx_http_request_t        *r;
+    ngx_http_v2_stream_t      *stream;
+    ngx_http_v2_loc_conf_t    *h2lcf;
+    ngx_http_v2_out_frame_t   *frame;
+    ngx_http_v2_connection_t  *h2c;
+
+    r = fc->data;
+    stream = r->stream;
+
+#if (NGX_SUPPRESS_WARN)
+    size = 0;
+#endif
+
+    while (in) {
+        size = ngx_buf_size(in->buf);
+
+        if (size || in->buf->last_buf) {
+            break;
+        }
+
+        in = in->next;
+    }
+
+    if (in == NULL) {
+
+        if (stream->queued) {
+            fc->write->delayed = 1;
+        } else {
+            fc->buffered &= ~NGX_HTTP_V2_BUFFERED;
+        }
+
+        return NULL;
+    }
+
+    h2c = stream->connection;
+
+    if (size && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {
+        fc->write->delayed = 1;
+        return in;
+    }
+
+    if (in->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        cl->buf = in->buf;
+        in->buf = cl->buf->shadow;
+
+        offset = ngx_buf_in_memory(in->buf)
+                 ? (cl->buf->pos - in->buf->pos)
+                 : (cl->buf->file_pos - in->buf->file_pos);
+
+        cl->next = stream->free_bufs;
+        stream->free_bufs = cl;
+
+    } else {
+        offset = 0;
+    }
+
+    if (limit == 0 || limit > (off_t) h2c->send_window) {
+        limit = h2c->send_window;
+    }
+
+    if (limit > stream->send_window) {
+        limit = (stream->send_window > 0) ? stream->send_window : 0;
+    }
+
+    h2lcf = ngx_http_get_module_loc_conf(r, ngx_http_v2_module);
+
+    frame_size = (h2lcf->chunk_size < h2c->frame_size)
+                 ? h2lcf->chunk_size : h2c->frame_size;
+
+#if (NGX_SUPPRESS_WARN)
+    cl = NULL;
+#endif
+
+    for ( ;; ) {
+        if ((off_t) frame_size > limit) {
+            frame_size = (size_t) limit;
+        }
+
+        ln = &out;
+        rest = frame_size;
+
+        while ((off_t) rest >= size) {
+
+            if (offset) {
+                cl = ngx_http_v2_filter_get_shadow(stream, in->buf,
+                                                   offset, size);
+                if (cl == NULL) {
+                    return NGX_CHAIN_ERROR;
+                }
+
+                offset = 0;
+
+            } else {
+                cl = ngx_alloc_chain_link(r->pool);
+                if (cl == NULL) {
+                    return NGX_CHAIN_ERROR;
+                }
+
+                cl->buf = in->buf;
+            }
+
+            *ln = cl;
+            ln = &cl->next;
+
+            rest -= (size_t) size;
+            in = in->next;
+
+            if (in == NULL) {
+                frame_size -= rest;
+                rest = 0;
+                break;
+            }
+
+            size = ngx_buf_size(in->buf);
+        }
+
+        if (rest) {
+            cl = ngx_http_v2_filter_get_shadow(stream, in->buf, offset, rest);
+            if (cl == NULL) {
+                return NGX_CHAIN_ERROR;
+            }
+
+            cl->buf->flush = 0;
+            cl->buf->last_buf = 0;
+
+            *ln = cl;
+
+            offset += rest;
+            size -= rest;
+        }
+
+        frame = ngx_http_v2_filter_get_data_frame(stream, frame_size, out, cl);
+        if (frame == NULL) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        ngx_http_v2_queue_frame(h2c, frame);
+
+        h2c->send_window -= frame_size;
+
+        stream->send_window -= frame_size;
+        stream->queued++;
+
+        if (in == NULL) {
+            break;
+        }
+
+        limit -= frame_size;
+
+        if (limit == 0) {
+            break;
+        }
+    }
+
+    if (offset) {
+        cl = ngx_http_v2_filter_get_shadow(stream, in->buf, offset, size);
+        if (cl == NULL) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        in->buf = cl->buf;
+        ngx_free_chain(r->pool, cl);
+    }
+
+    if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {
+        return NGX_CHAIN_ERROR;
+    }
+
+    if (in && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {
+        fc->write->delayed = 1;
+    }
+
+    return in;
+}
+
+
+static ngx_chain_t *
+ngx_http_v2_filter_get_shadow(ngx_http_v2_stream_t *stream, ngx_buf_t *buf,
+    off_t offset, off_t size)
+{
+    ngx_buf_t    *chunk;
+    ngx_chain_t  *cl;
+
+    cl = ngx_chain_get_free_buf(stream->request->pool, &stream->free_bufs);
+    if (cl == NULL) {
+        return NULL;
+    }
+
+    chunk = cl->buf;
+
+    ngx_memcpy(chunk, buf, sizeof(ngx_buf_t));
+
+    chunk->tag = (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow;
+    chunk->shadow = buf;
+
+    if (ngx_buf_in_memory(chunk)) {
+        chunk->pos += offset;
+        chunk->last = chunk->pos + size;
+    }
+
+    if (chunk->in_file) {
+        chunk->file_pos += offset;
+        chunk->file_last = chunk->file_pos + size;
+    }
+
+    return cl;
+}
+
+
+static ngx_http_v2_out_frame_t *
+ngx_http_v2_filter_get_data_frame(ngx_http_v2_stream_t *stream,
+    size_t len, ngx_chain_t *first, ngx_chain_t *last)
+{
+    u_char                      flags;
+    ngx_buf_t                  *buf;
+    ngx_chain_t                *cl;
+    ngx_http_v2_out_frame_t  *frame;
+
+
+    frame = stream->free_frames;
+
+    if (frame) {
+        stream->free_frames = frame->next;
+
+    } else {
+        frame = ngx_palloc(stream->request->pool,
+                           sizeof(ngx_http_v2_out_frame_t));
+        if (frame == NULL) {
+            return NULL;
+        }
+    }
+
+    flags = last->buf->last_buf ? NGX_HTTP_V2_END_STREAM_FLAG : 0;
+
+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, stream->request->connection->log, 0,
+                   "http2:%ui create DATA frame %p: len:%uz flags:%ui",
+                   stream->node->id, frame, len, (ngx_uint_t) flags);
+
+    cl = ngx_chain_get_free_buf(stream->request->pool,
+                                &stream->free_data_headers);
+    if (cl == NULL) {
+        return NULL;
+    }
+
+    buf = cl->buf;
+
+    if (!buf->start) {
+        buf->start = ngx_palloc(stream->request->pool, NGX_HTTP_V2_FRAME_HEADER_SIZE);
+        if (buf->start == NULL) {
+            return NULL;
+        }
+
+        buf->end = buf->start + NGX_HTTP_V2_FRAME_HEADER_SIZE;
+        buf->last = buf->end;
+
+        buf->tag = (ngx_buf_tag_t) &ngx_http_v2_filter_get_data_frame;
+        buf->memory = 1;
+    }
+
+    buf->pos = buf->start;
+    buf->last = buf->pos;
+
+    buf->last = ngx_http_v2_write_len_and_type(buf->last, len,
+                                               NGX_HTTP_V2_DATA_FRAME);
+    *buf->last++ = flags;
+
+    buf->last = ngx_http_v2_write_sid(buf->last, stream->node->id);
+
+    cl->next = first;
+    first = cl;
+
+    last->buf->flush = 1;
+
+    frame->first = first;
+    frame->last = last;
+    frame->handler = ngx_http_v2_data_frame_handler;
+    frame->stream = stream;
+    frame->length = len;
+    frame->blocked = 0;
+    frame->fin = last->buf->last_buf;
+
+    return frame;
+}
+
+
+static ngx_inline ngx_int_t
+ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)
+{
+    stream->blocked = 1;
+
+    if (ngx_http_v2_send_output_queue(stream->connection) == NGX_ERROR) {
+        fc->error = 1;
+        return NGX_ERROR;
+    }
+
+    stream->blocked = 0;
+
+    if (stream->queued) {
+        fc->buffered |= NGX_HTTP_V2_BUFFERED;
+        fc->write->delayed = 1;
+        return NGX_AGAIN;
+    }
+
+    fc->buffered &= ~NGX_HTTP_V2_BUFFERED;
+
+    return NGX_OK;
+}
+
+
+static ngx_inline ngx_int_t
+ngx_http_v2_flow_control(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream)
+{
+    if (stream->send_window <= 0) {
+        stream->exhausted = 1;
+        return NGX_DECLINED;
+    }
+
+    if (h2c->send_window == 0) {
+        ngx_http_v2_waiting_queue(h2c, stream);
+        return NGX_DECLINED;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream)
+{
+    ngx_queue_t           *q;
+    ngx_http_v2_stream_t  *s;
+
+    if (stream->handled) {
+        return;
+    }
+
+    stream->handled = 1;
+
+    for (q = ngx_queue_last(&h2c->waiting);
+         q != ngx_queue_sentinel(&h2c->waiting);
+         q = ngx_queue_prev(q))
+    {
+        s = ngx_queue_data(q, ngx_http_v2_stream_t, queue);
+
+        if (s->node->rank < stream->node->rank
+            || (s->node->rank == stream->node->rank
+                && s->node->rel_weight >= stream->node->rel_weight))
+        {
+            break;
+        }
+    }
+
+    ngx_queue_insert_after(q, &stream->queue);
+}
+
+
+
+static ngx_int_t
+ngx_http_v2_headers_frame_handler(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_buf_t             *buf;
+    ngx_http_v2_stream_t  *stream;
+
+    buf = frame->first->buf;
+
+    if (buf->pos != buf->last) {
+        return NGX_AGAIN;
+    }
+
+    stream = frame->stream;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2:%ui HEADERS frame %p was sent",
+                   stream->node->id, frame);
+
+    ngx_free_chain(stream->request->pool, frame->first);
+
+    ngx_http_v2_handle_frame(stream, frame);
+
+    ngx_http_v2_handle_stream(h2c, stream);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_data_frame_handler(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_buf_t             *buf;
+    ngx_chain_t           *cl, *ln;
+    ngx_http_v2_stream_t  *stream;
+
+    stream = frame->stream;
+
+    cl = frame->first;
+
+    if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_data_frame) {
+
+        if (cl->buf->pos != cl->buf->last) {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                           "http2:%ui DATA frame %p was sent partially",
+                           stream->node->id, frame);
+
+            return NGX_AGAIN;
+        }
+
+        ln = cl->next;
+
+        cl->next = stream->free_data_headers;
+        stream->free_data_headers = cl;
+
+        if (cl == frame->last) {
+            goto done;
+        }
+
+        cl = ln;
+    }
+
+    for ( ;; ) {
+        if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {
+            buf = cl->buf->shadow;
+
+            if (ngx_buf_in_memory(buf)) {
+                buf->pos = cl->buf->pos;
+            }
+
+            if (buf->in_file) {
+                buf->file_pos = cl->buf->file_pos;
+            }
+        }
+
+        if (ngx_buf_size(cl->buf) != 0) {
+
+            if (cl != frame->first) {
+                frame->first = cl;
+                ngx_http_v2_handle_stream(h2c, stream);
+            }
+
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                           "http2:%ui DATA frame %p was sent partially",
+                           stream->node->id, frame);
+
+            return NGX_AGAIN;
+        }
+
+        ln = cl->next;
+
+        if (cl->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {
+            cl->next = stream->free_bufs;
+            stream->free_bufs = cl;
+
+        } else {
+            ngx_free_chain(stream->request->pool, cl);
+        }
+
+        if (cl == frame->last) {
+            goto done;
+        }
+
+        cl = ln;
+    }
+
+done:
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2:%ui DATA frame %p was sent",
+                   stream->node->id, frame);
+
+    stream->request->header_size += NGX_HTTP_V2_FRAME_HEADER_SIZE;
+
+    ngx_http_v2_handle_frame(stream, frame);
+
+    ngx_http_v2_handle_stream(h2c, stream);
+
+    return NGX_OK;
+}
+
+
+static ngx_inline void
+ngx_http_v2_handle_frame(ngx_http_v2_stream_t *stream,
+    ngx_http_v2_out_frame_t *frame)
+{
+    ngx_http_request_t  *r;
+
+    r = stream->request;
+
+    r->connection->sent += NGX_HTTP_V2_FRAME_HEADER_SIZE + frame->length;
+
+    if (frame->fin) {
+        stream->out_closed = 1;
+    }
+
+    frame->next = stream->free_frames;
+    stream->free_frames = frame;
+
+    stream->queued--;
+}
+
+
+static ngx_inline void
+ngx_http_v2_handle_stream(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_stream_t *stream)
+{
+    ngx_event_t  *wev;
+
+    if (stream->handled || stream->blocked || stream->exhausted) {
+        return;
+    }
+
+    wev = stream->request->connection->write;
+
+    /*
+     * This timer can only be set if the stream was delayed because of rate
+     * limit.  In that case the event should be triggered by the timer.
+     */
+
+    if (!wev->timer_set) {
+        wev->delayed = 0;
+
+        stream->handled = 1;
+        ngx_queue_insert_tail(&h2c->posted, &stream->queue);
+    }
+}
+
+
+static void
+ngx_http_v2_filter_cleanup(void *data)
+{
+    ngx_http_v2_stream_t *stream = data;
+
+    size_t                     window;
+    ngx_http_v2_out_frame_t   *frame, **fn;
+    ngx_http_v2_connection_t  *h2c;
+
+    if (stream->handled) {
+        stream->handled = 0;
+        ngx_queue_remove(&stream->queue);
+    }
+
+    if (stream->queued == 0) {
+        return;
+    }
+
+    window = 0;
+    h2c = stream->connection;
+    fn = &h2c->last_out;
+
+    for ( ;; ) {
+        frame = *fn;
+
+        if (frame == NULL) {
+            break;
+        }
+
+        if (frame->stream == stream && !frame->blocked) {
+            *fn = frame->next;
+
+            window += frame->length;
+
+            if (--stream->queued == 0) {
+                break;
+            }
+
+            continue;
+        }
+
+        fn = &frame->next;
+    }
+
+    if (h2c->send_window == 0 && window && !ngx_queue_empty(&h2c->waiting)) {
+        ngx_queue_add(&h2c->posted, &h2c->waiting);
+        ngx_queue_init(&h2c->waiting);
+    }
+
+    h2c->send_window += window;
+}
+
+
+static ngx_int_t
+ngx_http_v2_filter_init(ngx_conf_t *cf)
+{
+    ngx_http_next_header_filter = ngx_http_top_header_filter;
+    ngx_http_top_header_filter = ngx_http_v2_header_filter;
+
+    return NGX_OK;
+}
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_huff_decode.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_huff_decode.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,2714 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+typedef struct {
+    u_char  next;
+    u_char  emit;
+    u_char  sym;
+    u_char  ending;
+} ngx_http_v2_huff_decode_code_t;
+
+
+static ngx_inline ngx_int_t ngx_http_v2_huff_decode_bits(u_char *state,
+    u_char *ending, ngx_uint_t bits, u_char **dst);
+
+
+static ngx_http_v2_huff_decode_code_t  ngx_http_v2_huff_decode_codes[256][16] =
+{
+    /* 0 */
+    {
+        {0x04, 0x00, 0x00, 0x00}, {0x05, 0x00, 0x00, 0x00},
+        {0x07, 0x00, 0x00, 0x00}, {0x08, 0x00, 0x00, 0x00},
+        {0x0b, 0x00, 0x00, 0x00}, {0x0c, 0x00, 0x00, 0x00},
+        {0x10, 0x00, 0x00, 0x00}, {0x13, 0x00, 0x00, 0x00},
+        {0x19, 0x00, 0x00, 0x00}, {0x1c, 0x00, 0x00, 0x00},
+        {0x20, 0x00, 0x00, 0x00}, {0x23, 0x00, 0x00, 0x00},
+        {0x2a, 0x00, 0x00, 0x00}, {0x31, 0x00, 0x00, 0x00},
+        {0x39, 0x00, 0x00, 0x00}, {0x40, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x30, 0x01}, {0x00, 0x01, 0x31, 0x01},
+        {0x00, 0x01, 0x32, 0x01}, {0x00, 0x01, 0x61, 0x01},
+        {0x00, 0x01, 0x63, 0x01}, {0x00, 0x01, 0x65, 0x01},
+        {0x00, 0x01, 0x69, 0x01}, {0x00, 0x01, 0x6f, 0x01},
+        {0x00, 0x01, 0x73, 0x01}, {0x00, 0x01, 0x74, 0x01},
+        {0x0d, 0x00, 0x00, 0x00}, {0x0e, 0x00, 0x00, 0x00},
+        {0x11, 0x00, 0x00, 0x00}, {0x12, 0x00, 0x00, 0x00},
+        {0x14, 0x00, 0x00, 0x00}, {0x15, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x01, 0x01, 0x30, 0x00}, {0x16, 0x01, 0x30, 0x01},
+        {0x01, 0x01, 0x31, 0x00}, {0x16, 0x01, 0x31, 0x01},
+        {0x01, 0x01, 0x32, 0x00}, {0x16, 0x01, 0x32, 0x01},
+        {0x01, 0x01, 0x61, 0x00}, {0x16, 0x01, 0x61, 0x01},
+        {0x01, 0x01, 0x63, 0x00}, {0x16, 0x01, 0x63, 0x01},
+        {0x01, 0x01, 0x65, 0x00}, {0x16, 0x01, 0x65, 0x01},
+        {0x01, 0x01, 0x69, 0x00}, {0x16, 0x01, 0x69, 0x01},
+        {0x01, 0x01, 0x6f, 0x00}, {0x16, 0x01, 0x6f, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x30, 0x00}, {0x09, 0x01, 0x30, 0x00},
+        {0x17, 0x01, 0x30, 0x00}, {0x28, 0x01, 0x30, 0x01},
+        {0x02, 0x01, 0x31, 0x00}, {0x09, 0x01, 0x31, 0x00},
+        {0x17, 0x01, 0x31, 0x00}, {0x28, 0x01, 0x31, 0x01},
+        {0x02, 0x01, 0x32, 0x00}, {0x09, 0x01, 0x32, 0x00},
+        {0x17, 0x01, 0x32, 0x00}, {0x28, 0x01, 0x32, 0x01},
+        {0x02, 0x01, 0x61, 0x00}, {0x09, 0x01, 0x61, 0x00},
+        {0x17, 0x01, 0x61, 0x00}, {0x28, 0x01, 0x61, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x30, 0x00}, {0x06, 0x01, 0x30, 0x00},
+        {0x0a, 0x01, 0x30, 0x00}, {0x0f, 0x01, 0x30, 0x00},
+        {0x18, 0x01, 0x30, 0x00}, {0x1f, 0x01, 0x30, 0x00},
+        {0x29, 0x01, 0x30, 0x00}, {0x38, 0x01, 0x30, 0x01},
+        {0x03, 0x01, 0x31, 0x00}, {0x06, 0x01, 0x31, 0x00},
+        {0x0a, 0x01, 0x31, 0x00}, {0x0f, 0x01, 0x31, 0x00},
+        {0x18, 0x01, 0x31, 0x00}, {0x1f, 0x01, 0x31, 0x00},
+        {0x29, 0x01, 0x31, 0x00}, {0x38, 0x01, 0x31, 0x01}
+    },
+    /* 5 */
+    {
+        {0x03, 0x01, 0x32, 0x00}, {0x06, 0x01, 0x32, 0x00},
+        {0x0a, 0x01, 0x32, 0x00}, {0x0f, 0x01, 0x32, 0x00},
+        {0x18, 0x01, 0x32, 0x00}, {0x1f, 0x01, 0x32, 0x00},
+        {0x29, 0x01, 0x32, 0x00}, {0x38, 0x01, 0x32, 0x01},
+        {0x03, 0x01, 0x61, 0x00}, {0x06, 0x01, 0x61, 0x00},
+        {0x0a, 0x01, 0x61, 0x00}, {0x0f, 0x01, 0x61, 0x00},
+        {0x18, 0x01, 0x61, 0x00}, {0x1f, 0x01, 0x61, 0x00},
+        {0x29, 0x01, 0x61, 0x00}, {0x38, 0x01, 0x61, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x63, 0x00}, {0x09, 0x01, 0x63, 0x00},
+        {0x17, 0x01, 0x63, 0x00}, {0x28, 0x01, 0x63, 0x01},
+        {0x02, 0x01, 0x65, 0x00}, {0x09, 0x01, 0x65, 0x00},
+        {0x17, 0x01, 0x65, 0x00}, {0x28, 0x01, 0x65, 0x01},
+        {0x02, 0x01, 0x69, 0x00}, {0x09, 0x01, 0x69, 0x00},
+        {0x17, 0x01, 0x69, 0x00}, {0x28, 0x01, 0x69, 0x01},
+        {0x02, 0x01, 0x6f, 0x00}, {0x09, 0x01, 0x6f, 0x00},
+        {0x17, 0x01, 0x6f, 0x00}, {0x28, 0x01, 0x6f, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x63, 0x00}, {0x06, 0x01, 0x63, 0x00},
+        {0x0a, 0x01, 0x63, 0x00}, {0x0f, 0x01, 0x63, 0x00},
+        {0x18, 0x01, 0x63, 0x00}, {0x1f, 0x01, 0x63, 0x00},
+        {0x29, 0x01, 0x63, 0x00}, {0x38, 0x01, 0x63, 0x01},
+        {0x03, 0x01, 0x65, 0x00}, {0x06, 0x01, 0x65, 0x00},
+        {0x0a, 0x01, 0x65, 0x00}, {0x0f, 0x01, 0x65, 0x00},
+        {0x18, 0x01, 0x65, 0x00}, {0x1f, 0x01, 0x65, 0x00},
+        {0x29, 0x01, 0x65, 0x00}, {0x38, 0x01, 0x65, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x69, 0x00}, {0x06, 0x01, 0x69, 0x00},
+        {0x0a, 0x01, 0x69, 0x00}, {0x0f, 0x01, 0x69, 0x00},
+        {0x18, 0x01, 0x69, 0x00}, {0x1f, 0x01, 0x69, 0x00},
+        {0x29, 0x01, 0x69, 0x00}, {0x38, 0x01, 0x69, 0x01},
+        {0x03, 0x01, 0x6f, 0x00}, {0x06, 0x01, 0x6f, 0x00},
+        {0x0a, 0x01, 0x6f, 0x00}, {0x0f, 0x01, 0x6f, 0x00},
+        {0x18, 0x01, 0x6f, 0x00}, {0x1f, 0x01, 0x6f, 0x00},
+        {0x29, 0x01, 0x6f, 0x00}, {0x38, 0x01, 0x6f, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x73, 0x00}, {0x16, 0x01, 0x73, 0x01},
+        {0x01, 0x01, 0x74, 0x00}, {0x16, 0x01, 0x74, 0x01},
+        {0x00, 0x01, 0x20, 0x01}, {0x00, 0x01, 0x25, 0x01},
+        {0x00, 0x01, 0x2d, 0x01}, {0x00, 0x01, 0x2e, 0x01},
+        {0x00, 0x01, 0x2f, 0x01}, {0x00, 0x01, 0x33, 0x01},
+        {0x00, 0x01, 0x34, 0x01}, {0x00, 0x01, 0x35, 0x01},
+        {0x00, 0x01, 0x36, 0x01}, {0x00, 0x01, 0x37, 0x01},
+        {0x00, 0x01, 0x38, 0x01}, {0x00, 0x01, 0x39, 0x01}
+    },
+    /* 10 */
+    {
+        {0x02, 0x01, 0x73, 0x00}, {0x09, 0x01, 0x73, 0x00},
+        {0x17, 0x01, 0x73, 0x00}, {0x28, 0x01, 0x73, 0x01},
+        {0x02, 0x01, 0x74, 0x00}, {0x09, 0x01, 0x74, 0x00},
+        {0x17, 0x01, 0x74, 0x00}, {0x28, 0x01, 0x74, 0x01},
+        {0x01, 0x01, 0x20, 0x00}, {0x16, 0x01, 0x20, 0x01},
+        {0x01, 0x01, 0x25, 0x00}, {0x16, 0x01, 0x25, 0x01},
+        {0x01, 0x01, 0x2d, 0x00}, {0x16, 0x01, 0x2d, 0x01},
+        {0x01, 0x01, 0x2e, 0x00}, {0x16, 0x01, 0x2e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x73, 0x00}, {0x06, 0x01, 0x73, 0x00},
+        {0x0a, 0x01, 0x73, 0x00}, {0x0f, 0x01, 0x73, 0x00},
+        {0x18, 0x01, 0x73, 0x00}, {0x1f, 0x01, 0x73, 0x00},
+        {0x29, 0x01, 0x73, 0x00}, {0x38, 0x01, 0x73, 0x01},
+        {0x03, 0x01, 0x74, 0x00}, {0x06, 0x01, 0x74, 0x00},
+        {0x0a, 0x01, 0x74, 0x00}, {0x0f, 0x01, 0x74, 0x00},
+        {0x18, 0x01, 0x74, 0x00}, {0x1f, 0x01, 0x74, 0x00},
+        {0x29, 0x01, 0x74, 0x00}, {0x38, 0x01, 0x74, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x20, 0x00}, {0x09, 0x01, 0x20, 0x00},
+        {0x17, 0x01, 0x20, 0x00}, {0x28, 0x01, 0x20, 0x01},
+        {0x02, 0x01, 0x25, 0x00}, {0x09, 0x01, 0x25, 0x00},
+        {0x17, 0x01, 0x25, 0x00}, {0x28, 0x01, 0x25, 0x01},
+        {0x02, 0x01, 0x2d, 0x00}, {0x09, 0x01, 0x2d, 0x00},
+        {0x17, 0x01, 0x2d, 0x00}, {0x28, 0x01, 0x2d, 0x01},
+        {0x02, 0x01, 0x2e, 0x00}, {0x09, 0x01, 0x2e, 0x00},
+        {0x17, 0x01, 0x2e, 0x00}, {0x28, 0x01, 0x2e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x20, 0x00}, {0x06, 0x01, 0x20, 0x00},
+        {0x0a, 0x01, 0x20, 0x00}, {0x0f, 0x01, 0x20, 0x00},
+        {0x18, 0x01, 0x20, 0x00}, {0x1f, 0x01, 0x20, 0x00},
+        {0x29, 0x01, 0x20, 0x00}, {0x38, 0x01, 0x20, 0x01},
+        {0x03, 0x01, 0x25, 0x00}, {0x06, 0x01, 0x25, 0x00},
+        {0x0a, 0x01, 0x25, 0x00}, {0x0f, 0x01, 0x25, 0x00},
+        {0x18, 0x01, 0x25, 0x00}, {0x1f, 0x01, 0x25, 0x00},
+        {0x29, 0x01, 0x25, 0x00}, {0x38, 0x01, 0x25, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x2d, 0x00}, {0x06, 0x01, 0x2d, 0x00},
+        {0x0a, 0x01, 0x2d, 0x00}, {0x0f, 0x01, 0x2d, 0x00},
+        {0x18, 0x01, 0x2d, 0x00}, {0x1f, 0x01, 0x2d, 0x00},
+        {0x29, 0x01, 0x2d, 0x00}, {0x38, 0x01, 0x2d, 0x01},
+        {0x03, 0x01, 0x2e, 0x00}, {0x06, 0x01, 0x2e, 0x00},
+        {0x0a, 0x01, 0x2e, 0x00}, {0x0f, 0x01, 0x2e, 0x00},
+        {0x18, 0x01, 0x2e, 0x00}, {0x1f, 0x01, 0x2e, 0x00},
+        {0x29, 0x01, 0x2e, 0x00}, {0x38, 0x01, 0x2e, 0x01}
+    },
+    /* 15 */
+    {
+        {0x01, 0x01, 0x2f, 0x00}, {0x16, 0x01, 0x2f, 0x01},
+        {0x01, 0x01, 0x33, 0x00}, {0x16, 0x01, 0x33, 0x01},
+        {0x01, 0x01, 0x34, 0x00}, {0x16, 0x01, 0x34, 0x01},
+        {0x01, 0x01, 0x35, 0x00}, {0x16, 0x01, 0x35, 0x01},
+        {0x01, 0x01, 0x36, 0x00}, {0x16, 0x01, 0x36, 0x01},
+        {0x01, 0x01, 0x37, 0x00}, {0x16, 0x01, 0x37, 0x01},
+        {0x01, 0x01, 0x38, 0x00}, {0x16, 0x01, 0x38, 0x01},
+        {0x01, 0x01, 0x39, 0x00}, {0x16, 0x01, 0x39, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x2f, 0x00}, {0x09, 0x01, 0x2f, 0x00},
+        {0x17, 0x01, 0x2f, 0x00}, {0x28, 0x01, 0x2f, 0x01},
+        {0x02, 0x01, 0x33, 0x00}, {0x09, 0x01, 0x33, 0x00},
+        {0x17, 0x01, 0x33, 0x00}, {0x28, 0x01, 0x33, 0x01},
+        {0x02, 0x01, 0x34, 0x00}, {0x09, 0x01, 0x34, 0x00},
+        {0x17, 0x01, 0x34, 0x00}, {0x28, 0x01, 0x34, 0x01},
+        {0x02, 0x01, 0x35, 0x00}, {0x09, 0x01, 0x35, 0x00},
+        {0x17, 0x01, 0x35, 0x00}, {0x28, 0x01, 0x35, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x2f, 0x00}, {0x06, 0x01, 0x2f, 0x00},
+        {0x0a, 0x01, 0x2f, 0x00}, {0x0f, 0x01, 0x2f, 0x00},
+        {0x18, 0x01, 0x2f, 0x00}, {0x1f, 0x01, 0x2f, 0x00},
+        {0x29, 0x01, 0x2f, 0x00}, {0x38, 0x01, 0x2f, 0x01},
+        {0x03, 0x01, 0x33, 0x00}, {0x06, 0x01, 0x33, 0x00},
+        {0x0a, 0x01, 0x33, 0x00}, {0x0f, 0x01, 0x33, 0x00},
+        {0x18, 0x01, 0x33, 0x00}, {0x1f, 0x01, 0x33, 0x00},
+        {0x29, 0x01, 0x33, 0x00}, {0x38, 0x01, 0x33, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x34, 0x00}, {0x06, 0x01, 0x34, 0x00},
+        {0x0a, 0x01, 0x34, 0x00}, {0x0f, 0x01, 0x34, 0x00},
+        {0x18, 0x01, 0x34, 0x00}, {0x1f, 0x01, 0x34, 0x00},
+        {0x29, 0x01, 0x34, 0x00}, {0x38, 0x01, 0x34, 0x01},
+        {0x03, 0x01, 0x35, 0x00}, {0x06, 0x01, 0x35, 0x00},
+        {0x0a, 0x01, 0x35, 0x00}, {0x0f, 0x01, 0x35, 0x00},
+        {0x18, 0x01, 0x35, 0x00}, {0x1f, 0x01, 0x35, 0x00},
+        {0x29, 0x01, 0x35, 0x00}, {0x38, 0x01, 0x35, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x36, 0x00}, {0x09, 0x01, 0x36, 0x00},
+        {0x17, 0x01, 0x36, 0x00}, {0x28, 0x01, 0x36, 0x01},
+        {0x02, 0x01, 0x37, 0x00}, {0x09, 0x01, 0x37, 0x00},
+        {0x17, 0x01, 0x37, 0x00}, {0x28, 0x01, 0x37, 0x01},
+        {0x02, 0x01, 0x38, 0x00}, {0x09, 0x01, 0x38, 0x00},
+        {0x17, 0x01, 0x38, 0x00}, {0x28, 0x01, 0x38, 0x01},
+        {0x02, 0x01, 0x39, 0x00}, {0x09, 0x01, 0x39, 0x00},
+        {0x17, 0x01, 0x39, 0x00}, {0x28, 0x01, 0x39, 0x01}
+    },
+    /* 20 */
+    {
+        {0x03, 0x01, 0x36, 0x00}, {0x06, 0x01, 0x36, 0x00},
+        {0x0a, 0x01, 0x36, 0x00}, {0x0f, 0x01, 0x36, 0x00},
+        {0x18, 0x01, 0x36, 0x00}, {0x1f, 0x01, 0x36, 0x00},
+        {0x29, 0x01, 0x36, 0x00}, {0x38, 0x01, 0x36, 0x01},
+        {0x03, 0x01, 0x37, 0x00}, {0x06, 0x01, 0x37, 0x00},
+        {0x0a, 0x01, 0x37, 0x00}, {0x0f, 0x01, 0x37, 0x00},
+        {0x18, 0x01, 0x37, 0x00}, {0x1f, 0x01, 0x37, 0x00},
+        {0x29, 0x01, 0x37, 0x00}, {0x38, 0x01, 0x37, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x38, 0x00}, {0x06, 0x01, 0x38, 0x00},
+        {0x0a, 0x01, 0x38, 0x00}, {0x0f, 0x01, 0x38, 0x00},
+        {0x18, 0x01, 0x38, 0x00}, {0x1f, 0x01, 0x38, 0x00},
+        {0x29, 0x01, 0x38, 0x00}, {0x38, 0x01, 0x38, 0x01},
+        {0x03, 0x01, 0x39, 0x00}, {0x06, 0x01, 0x39, 0x00},
+        {0x0a, 0x01, 0x39, 0x00}, {0x0f, 0x01, 0x39, 0x00},
+        {0x18, 0x01, 0x39, 0x00}, {0x1f, 0x01, 0x39, 0x00},
+        {0x29, 0x01, 0x39, 0x00}, {0x38, 0x01, 0x39, 0x01}
+    },
+    {
+        {0x1a, 0x00, 0x00, 0x00}, {0x1b, 0x00, 0x00, 0x00},
+        {0x1d, 0x00, 0x00, 0x00}, {0x1e, 0x00, 0x00, 0x00},
+        {0x21, 0x00, 0x00, 0x00}, {0x22, 0x00, 0x00, 0x00},
+        {0x24, 0x00, 0x00, 0x00}, {0x25, 0x00, 0x00, 0x00},
+        {0x2b, 0x00, 0x00, 0x00}, {0x2e, 0x00, 0x00, 0x00},
+        {0x32, 0x00, 0x00, 0x00}, {0x35, 0x00, 0x00, 0x00},
+        {0x3a, 0x00, 0x00, 0x00}, {0x3d, 0x00, 0x00, 0x00},
+        {0x41, 0x00, 0x00, 0x00}, {0x44, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x3d, 0x01}, {0x00, 0x01, 0x41, 0x01},
+        {0x00, 0x01, 0x5f, 0x01}, {0x00, 0x01, 0x62, 0x01},
+        {0x00, 0x01, 0x64, 0x01}, {0x00, 0x01, 0x66, 0x01},
+        {0x00, 0x01, 0x67, 0x01}, {0x00, 0x01, 0x68, 0x01},
+        {0x00, 0x01, 0x6c, 0x01}, {0x00, 0x01, 0x6d, 0x01},
+        {0x00, 0x01, 0x6e, 0x01}, {0x00, 0x01, 0x70, 0x01},
+        {0x00, 0x01, 0x72, 0x01}, {0x00, 0x01, 0x75, 0x01},
+        {0x26, 0x00, 0x00, 0x00}, {0x27, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x01, 0x01, 0x3d, 0x00}, {0x16, 0x01, 0x3d, 0x01},
+        {0x01, 0x01, 0x41, 0x00}, {0x16, 0x01, 0x41, 0x01},
+        {0x01, 0x01, 0x5f, 0x00}, {0x16, 0x01, 0x5f, 0x01},
+        {0x01, 0x01, 0x62, 0x00}, {0x16, 0x01, 0x62, 0x01},
+        {0x01, 0x01, 0x64, 0x00}, {0x16, 0x01, 0x64, 0x01},
+        {0x01, 0x01, 0x66, 0x00}, {0x16, 0x01, 0x66, 0x01},
+        {0x01, 0x01, 0x67, 0x00}, {0x16, 0x01, 0x67, 0x01},
+        {0x01, 0x01, 0x68, 0x00}, {0x16, 0x01, 0x68, 0x01}
+    },
+    /* 25 */
+    {
+        {0x02, 0x01, 0x3d, 0x00}, {0x09, 0x01, 0x3d, 0x00},
+        {0x17, 0x01, 0x3d, 0x00}, {0x28, 0x01, 0x3d, 0x01},
+        {0x02, 0x01, 0x41, 0x00}, {0x09, 0x01, 0x41, 0x00},
+        {0x17, 0x01, 0x41, 0x00}, {0x28, 0x01, 0x41, 0x01},
+        {0x02, 0x01, 0x5f, 0x00}, {0x09, 0x01, 0x5f, 0x00},
+        {0x17, 0x01, 0x5f, 0x00}, {0x28, 0x01, 0x5f, 0x01},
+        {0x02, 0x01, 0x62, 0x00}, {0x09, 0x01, 0x62, 0x00},
+        {0x17, 0x01, 0x62, 0x00}, {0x28, 0x01, 0x62, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x3d, 0x00}, {0x06, 0x01, 0x3d, 0x00},
+        {0x0a, 0x01, 0x3d, 0x00}, {0x0f, 0x01, 0x3d, 0x00},
+        {0x18, 0x01, 0x3d, 0x00}, {0x1f, 0x01, 0x3d, 0x00},
+        {0x29, 0x01, 0x3d, 0x00}, {0x38, 0x01, 0x3d, 0x01},
+        {0x03, 0x01, 0x41, 0x00}, {0x06, 0x01, 0x41, 0x00},
+        {0x0a, 0x01, 0x41, 0x00}, {0x0f, 0x01, 0x41, 0x00},
+        {0x18, 0x01, 0x41, 0x00}, {0x1f, 0x01, 0x41, 0x00},
+        {0x29, 0x01, 0x41, 0x00}, {0x38, 0x01, 0x41, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x5f, 0x00}, {0x06, 0x01, 0x5f, 0x00},
+        {0x0a, 0x01, 0x5f, 0x00}, {0x0f, 0x01, 0x5f, 0x00},
+        {0x18, 0x01, 0x5f, 0x00}, {0x1f, 0x01, 0x5f, 0x00},
+        {0x29, 0x01, 0x5f, 0x00}, {0x38, 0x01, 0x5f, 0x01},
+        {0x03, 0x01, 0x62, 0x00}, {0x06, 0x01, 0x62, 0x00},
+        {0x0a, 0x01, 0x62, 0x00}, {0x0f, 0x01, 0x62, 0x00},
+        {0x18, 0x01, 0x62, 0x00}, {0x1f, 0x01, 0x62, 0x00},
+        {0x29, 0x01, 0x62, 0x00}, {0x38, 0x01, 0x62, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x64, 0x00}, {0x09, 0x01, 0x64, 0x00},
+        {0x17, 0x01, 0x64, 0x00}, {0x28, 0x01, 0x64, 0x01},
+        {0x02, 0x01, 0x66, 0x00}, {0x09, 0x01, 0x66, 0x00},
+        {0x17, 0x01, 0x66, 0x00}, {0x28, 0x01, 0x66, 0x01},
+        {0x02, 0x01, 0x67, 0x00}, {0x09, 0x01, 0x67, 0x00},
+        {0x17, 0x01, 0x67, 0x00}, {0x28, 0x01, 0x67, 0x01},
+        {0x02, 0x01, 0x68, 0x00}, {0x09, 0x01, 0x68, 0x00},
+        {0x17, 0x01, 0x68, 0x00}, {0x28, 0x01, 0x68, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x64, 0x00}, {0x06, 0x01, 0x64, 0x00},
+        {0x0a, 0x01, 0x64, 0x00}, {0x0f, 0x01, 0x64, 0x00},
+        {0x18, 0x01, 0x64, 0x00}, {0x1f, 0x01, 0x64, 0x00},
+        {0x29, 0x01, 0x64, 0x00}, {0x38, 0x01, 0x64, 0x01},
+        {0x03, 0x01, 0x66, 0x00}, {0x06, 0x01, 0x66, 0x00},
+        {0x0a, 0x01, 0x66, 0x00}, {0x0f, 0x01, 0x66, 0x00},
+        {0x18, 0x01, 0x66, 0x00}, {0x1f, 0x01, 0x66, 0x00},
+        {0x29, 0x01, 0x66, 0x00}, {0x38, 0x01, 0x66, 0x01}
+    },
+    /* 30 */
+    {
+        {0x03, 0x01, 0x67, 0x00}, {0x06, 0x01, 0x67, 0x00},
+        {0x0a, 0x01, 0x67, 0x00}, {0x0f, 0x01, 0x67, 0x00},
+        {0x18, 0x01, 0x67, 0x00}, {0x1f, 0x01, 0x67, 0x00},
+        {0x29, 0x01, 0x67, 0x00}, {0x38, 0x01, 0x67, 0x01},
+        {0x03, 0x01, 0x68, 0x00}, {0x06, 0x01, 0x68, 0x00},
+        {0x0a, 0x01, 0x68, 0x00}, {0x0f, 0x01, 0x68, 0x00},
+        {0x18, 0x01, 0x68, 0x00}, {0x1f, 0x01, 0x68, 0x00},
+        {0x29, 0x01, 0x68, 0x00}, {0x38, 0x01, 0x68, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x6c, 0x00}, {0x16, 0x01, 0x6c, 0x01},
+        {0x01, 0x01, 0x6d, 0x00}, {0x16, 0x01, 0x6d, 0x01},
+        {0x01, 0x01, 0x6e, 0x00}, {0x16, 0x01, 0x6e, 0x01},
+        {0x01, 0x01, 0x70, 0x00}, {0x16, 0x01, 0x70, 0x01},
+        {0x01, 0x01, 0x72, 0x00}, {0x16, 0x01, 0x72, 0x01},
+        {0x01, 0x01, 0x75, 0x00}, {0x16, 0x01, 0x75, 0x01},
+        {0x00, 0x01, 0x3a, 0x01}, {0x00, 0x01, 0x42, 0x01},
+        {0x00, 0x01, 0x43, 0x01}, {0x00, 0x01, 0x44, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x6c, 0x00}, {0x09, 0x01, 0x6c, 0x00},
+        {0x17, 0x01, 0x6c, 0x00}, {0x28, 0x01, 0x6c, 0x01},
+        {0x02, 0x01, 0x6d, 0x00}, {0x09, 0x01, 0x6d, 0x00},
+        {0x17, 0x01, 0x6d, 0x00}, {0x28, 0x01, 0x6d, 0x01},
+        {0x02, 0x01, 0x6e, 0x00}, {0x09, 0x01, 0x6e, 0x00},
+        {0x17, 0x01, 0x6e, 0x00}, {0x28, 0x01, 0x6e, 0x01},
+        {0x02, 0x01, 0x70, 0x00}, {0x09, 0x01, 0x70, 0x00},
+        {0x17, 0x01, 0x70, 0x00}, {0x28, 0x01, 0x70, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x6c, 0x00}, {0x06, 0x01, 0x6c, 0x00},
+        {0x0a, 0x01, 0x6c, 0x00}, {0x0f, 0x01, 0x6c, 0x00},
+        {0x18, 0x01, 0x6c, 0x00}, {0x1f, 0x01, 0x6c, 0x00},
+        {0x29, 0x01, 0x6c, 0x00}, {0x38, 0x01, 0x6c, 0x01},
+        {0x03, 0x01, 0x6d, 0x00}, {0x06, 0x01, 0x6d, 0x00},
+        {0x0a, 0x01, 0x6d, 0x00}, {0x0f, 0x01, 0x6d, 0x00},
+        {0x18, 0x01, 0x6d, 0x00}, {0x1f, 0x01, 0x6d, 0x00},
+        {0x29, 0x01, 0x6d, 0x00}, {0x38, 0x01, 0x6d, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x6e, 0x00}, {0x06, 0x01, 0x6e, 0x00},
+        {0x0a, 0x01, 0x6e, 0x00}, {0x0f, 0x01, 0x6e, 0x00},
+        {0x18, 0x01, 0x6e, 0x00}, {0x1f, 0x01, 0x6e, 0x00},
+        {0x29, 0x01, 0x6e, 0x00}, {0x38, 0x01, 0x6e, 0x01},
+        {0x03, 0x01, 0x70, 0x00}, {0x06, 0x01, 0x70, 0x00},
+        {0x0a, 0x01, 0x70, 0x00}, {0x0f, 0x01, 0x70, 0x00},
+        {0x18, 0x01, 0x70, 0x00}, {0x1f, 0x01, 0x70, 0x00},
+        {0x29, 0x01, 0x70, 0x00}, {0x38, 0x01, 0x70, 0x01}
+    },
+    /* 35 */
+    {
+        {0x02, 0x01, 0x72, 0x00}, {0x09, 0x01, 0x72, 0x00},
+        {0x17, 0x01, 0x72, 0x00}, {0x28, 0x01, 0x72, 0x01},
+        {0x02, 0x01, 0x75, 0x00}, {0x09, 0x01, 0x75, 0x00},
+        {0x17, 0x01, 0x75, 0x00}, {0x28, 0x01, 0x75, 0x01},
+        {0x01, 0x01, 0x3a, 0x00}, {0x16, 0x01, 0x3a, 0x01},
+        {0x01, 0x01, 0x42, 0x00}, {0x16, 0x01, 0x42, 0x01},
+        {0x01, 0x01, 0x43, 0x00}, {0x16, 0x01, 0x43, 0x01},
+        {0x01, 0x01, 0x44, 0x00}, {0x16, 0x01, 0x44, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x72, 0x00}, {0x06, 0x01, 0x72, 0x00},
+        {0x0a, 0x01, 0x72, 0x00}, {0x0f, 0x01, 0x72, 0x00},
+        {0x18, 0x01, 0x72, 0x00}, {0x1f, 0x01, 0x72, 0x00},
+        {0x29, 0x01, 0x72, 0x00}, {0x38, 0x01, 0x72, 0x01},
+        {0x03, 0x01, 0x75, 0x00}, {0x06, 0x01, 0x75, 0x00},
+        {0x0a, 0x01, 0x75, 0x00}, {0x0f, 0x01, 0x75, 0x00},
+        {0x18, 0x01, 0x75, 0x00}, {0x1f, 0x01, 0x75, 0x00},
+        {0x29, 0x01, 0x75, 0x00}, {0x38, 0x01, 0x75, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x3a, 0x00}, {0x09, 0x01, 0x3a, 0x00},
+        {0x17, 0x01, 0x3a, 0x00}, {0x28, 0x01, 0x3a, 0x01},
+        {0x02, 0x01, 0x42, 0x00}, {0x09, 0x01, 0x42, 0x00},
+        {0x17, 0x01, 0x42, 0x00}, {0x28, 0x01, 0x42, 0x01},
+        {0x02, 0x01, 0x43, 0x00}, {0x09, 0x01, 0x43, 0x00},
+        {0x17, 0x01, 0x43, 0x00}, {0x28, 0x01, 0x43, 0x01},
+        {0x02, 0x01, 0x44, 0x00}, {0x09, 0x01, 0x44, 0x00},
+        {0x17, 0x01, 0x44, 0x00}, {0x28, 0x01, 0x44, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x3a, 0x00}, {0x06, 0x01, 0x3a, 0x00},
+        {0x0a, 0x01, 0x3a, 0x00}, {0x0f, 0x01, 0x3a, 0x00},
+        {0x18, 0x01, 0x3a, 0x00}, {0x1f, 0x01, 0x3a, 0x00},
+        {0x29, 0x01, 0x3a, 0x00}, {0x38, 0x01, 0x3a, 0x01},
+        {0x03, 0x01, 0x42, 0x00}, {0x06, 0x01, 0x42, 0x00},
+        {0x0a, 0x01, 0x42, 0x00}, {0x0f, 0x01, 0x42, 0x00},
+        {0x18, 0x01, 0x42, 0x00}, {0x1f, 0x01, 0x42, 0x00},
+        {0x29, 0x01, 0x42, 0x00}, {0x38, 0x01, 0x42, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x43, 0x00}, {0x06, 0x01, 0x43, 0x00},
+        {0x0a, 0x01, 0x43, 0x00}, {0x0f, 0x01, 0x43, 0x00},
+        {0x18, 0x01, 0x43, 0x00}, {0x1f, 0x01, 0x43, 0x00},
+        {0x29, 0x01, 0x43, 0x00}, {0x38, 0x01, 0x43, 0x01},
+        {0x03, 0x01, 0x44, 0x00}, {0x06, 0x01, 0x44, 0x00},
+        {0x0a, 0x01, 0x44, 0x00}, {0x0f, 0x01, 0x44, 0x00},
+        {0x18, 0x01, 0x44, 0x00}, {0x1f, 0x01, 0x44, 0x00},
+        {0x29, 0x01, 0x44, 0x00}, {0x38, 0x01, 0x44, 0x01}
+    },
+    /* 40 */
+    {
+        {0x2c, 0x00, 0x00, 0x00}, {0x2d, 0x00, 0x00, 0x00},
+        {0x2f, 0x00, 0x00, 0x00}, {0x30, 0x00, 0x00, 0x00},
+        {0x33, 0x00, 0x00, 0x00}, {0x34, 0x00, 0x00, 0x00},
+        {0x36, 0x00, 0x00, 0x00}, {0x37, 0x00, 0x00, 0x00},
+        {0x3b, 0x00, 0x00, 0x00}, {0x3c, 0x00, 0x00, 0x00},
+        {0x3e, 0x00, 0x00, 0x00}, {0x3f, 0x00, 0x00, 0x00},
+        {0x42, 0x00, 0x00, 0x00}, {0x43, 0x00, 0x00, 0x00},
+        {0x45, 0x00, 0x00, 0x00}, {0x48, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x45, 0x01}, {0x00, 0x01, 0x46, 0x01},
+        {0x00, 0x01, 0x47, 0x01}, {0x00, 0x01, 0x48, 0x01},
+        {0x00, 0x01, 0x49, 0x01}, {0x00, 0x01, 0x4a, 0x01},
+        {0x00, 0x01, 0x4b, 0x01}, {0x00, 0x01, 0x4c, 0x01},
+        {0x00, 0x01, 0x4d, 0x01}, {0x00, 0x01, 0x4e, 0x01},
+        {0x00, 0x01, 0x4f, 0x01}, {0x00, 0x01, 0x50, 0x01},
+        {0x00, 0x01, 0x51, 0x01}, {0x00, 0x01, 0x52, 0x01},
+        {0x00, 0x01, 0x53, 0x01}, {0x00, 0x01, 0x54, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x45, 0x00}, {0x16, 0x01, 0x45, 0x01},
+        {0x01, 0x01, 0x46, 0x00}, {0x16, 0x01, 0x46, 0x01},
+        {0x01, 0x01, 0x47, 0x00}, {0x16, 0x01, 0x47, 0x01},
+        {0x01, 0x01, 0x48, 0x00}, {0x16, 0x01, 0x48, 0x01},
+        {0x01, 0x01, 0x49, 0x00}, {0x16, 0x01, 0x49, 0x01},
+        {0x01, 0x01, 0x4a, 0x00}, {0x16, 0x01, 0x4a, 0x01},
+        {0x01, 0x01, 0x4b, 0x00}, {0x16, 0x01, 0x4b, 0x01},
+        {0x01, 0x01, 0x4c, 0x00}, {0x16, 0x01, 0x4c, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x45, 0x00}, {0x09, 0x01, 0x45, 0x00},
+        {0x17, 0x01, 0x45, 0x00}, {0x28, 0x01, 0x45, 0x01},
+        {0x02, 0x01, 0x46, 0x00}, {0x09, 0x01, 0x46, 0x00},
+        {0x17, 0x01, 0x46, 0x00}, {0x28, 0x01, 0x46, 0x01},
+        {0x02, 0x01, 0x47, 0x00}, {0x09, 0x01, 0x47, 0x00},
+        {0x17, 0x01, 0x47, 0x00}, {0x28, 0x01, 0x47, 0x01},
+        {0x02, 0x01, 0x48, 0x00}, {0x09, 0x01, 0x48, 0x00},
+        {0x17, 0x01, 0x48, 0x00}, {0x28, 0x01, 0x48, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x45, 0x00}, {0x06, 0x01, 0x45, 0x00},
+        {0x0a, 0x01, 0x45, 0x00}, {0x0f, 0x01, 0x45, 0x00},
+        {0x18, 0x01, 0x45, 0x00}, {0x1f, 0x01, 0x45, 0x00},
+        {0x29, 0x01, 0x45, 0x00}, {0x38, 0x01, 0x45, 0x01},
+        {0x03, 0x01, 0x46, 0x00}, {0x06, 0x01, 0x46, 0x00},
+        {0x0a, 0x01, 0x46, 0x00}, {0x0f, 0x01, 0x46, 0x00},
+        {0x18, 0x01, 0x46, 0x00}, {0x1f, 0x01, 0x46, 0x00},
+        {0x29, 0x01, 0x46, 0x00}, {0x38, 0x01, 0x46, 0x01}
+    },
+    /* 45 */
+    {
+        {0x03, 0x01, 0x47, 0x00}, {0x06, 0x01, 0x47, 0x00},
+        {0x0a, 0x01, 0x47, 0x00}, {0x0f, 0x01, 0x47, 0x00},
+        {0x18, 0x01, 0x47, 0x00}, {0x1f, 0x01, 0x47, 0x00},
+        {0x29, 0x01, 0x47, 0x00}, {0x38, 0x01, 0x47, 0x01},
+        {0x03, 0x01, 0x48, 0x00}, {0x06, 0x01, 0x48, 0x00},
+        {0x0a, 0x01, 0x48, 0x00}, {0x0f, 0x01, 0x48, 0x00},
+        {0x18, 0x01, 0x48, 0x00}, {0x1f, 0x01, 0x48, 0x00},
+        {0x29, 0x01, 0x48, 0x00}, {0x38, 0x01, 0x48, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x49, 0x00}, {0x09, 0x01, 0x49, 0x00},
+        {0x17, 0x01, 0x49, 0x00}, {0x28, 0x01, 0x49, 0x01},
+        {0x02, 0x01, 0x4a, 0x00}, {0x09, 0x01, 0x4a, 0x00},
+        {0x17, 0x01, 0x4a, 0x00}, {0x28, 0x01, 0x4a, 0x01},
+        {0x02, 0x01, 0x4b, 0x00}, {0x09, 0x01, 0x4b, 0x00},
+        {0x17, 0x01, 0x4b, 0x00}, {0x28, 0x01, 0x4b, 0x01},
+        {0x02, 0x01, 0x4c, 0x00}, {0x09, 0x01, 0x4c, 0x00},
+        {0x17, 0x01, 0x4c, 0x00}, {0x28, 0x01, 0x4c, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x49, 0x00}, {0x06, 0x01, 0x49, 0x00},
+        {0x0a, 0x01, 0x49, 0x00}, {0x0f, 0x01, 0x49, 0x00},
+        {0x18, 0x01, 0x49, 0x00}, {0x1f, 0x01, 0x49, 0x00},
+        {0x29, 0x01, 0x49, 0x00}, {0x38, 0x01, 0x49, 0x01},
+        {0x03, 0x01, 0x4a, 0x00}, {0x06, 0x01, 0x4a, 0x00},
+        {0x0a, 0x01, 0x4a, 0x00}, {0x0f, 0x01, 0x4a, 0x00},
+        {0x18, 0x01, 0x4a, 0x00}, {0x1f, 0x01, 0x4a, 0x00},
+        {0x29, 0x01, 0x4a, 0x00}, {0x38, 0x01, 0x4a, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x4b, 0x00}, {0x06, 0x01, 0x4b, 0x00},
+        {0x0a, 0x01, 0x4b, 0x00}, {0x0f, 0x01, 0x4b, 0x00},
+        {0x18, 0x01, 0x4b, 0x00}, {0x1f, 0x01, 0x4b, 0x00},
+        {0x29, 0x01, 0x4b, 0x00}, {0x38, 0x01, 0x4b, 0x01},
+        {0x03, 0x01, 0x4c, 0x00}, {0x06, 0x01, 0x4c, 0x00},
+        {0x0a, 0x01, 0x4c, 0x00}, {0x0f, 0x01, 0x4c, 0x00},
+        {0x18, 0x01, 0x4c, 0x00}, {0x1f, 0x01, 0x4c, 0x00},
+        {0x29, 0x01, 0x4c, 0x00}, {0x38, 0x01, 0x4c, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x4d, 0x00}, {0x16, 0x01, 0x4d, 0x01},
+        {0x01, 0x01, 0x4e, 0x00}, {0x16, 0x01, 0x4e, 0x01},
+        {0x01, 0x01, 0x4f, 0x00}, {0x16, 0x01, 0x4f, 0x01},
+        {0x01, 0x01, 0x50, 0x00}, {0x16, 0x01, 0x50, 0x01},
+        {0x01, 0x01, 0x51, 0x00}, {0x16, 0x01, 0x51, 0x01},
+        {0x01, 0x01, 0x52, 0x00}, {0x16, 0x01, 0x52, 0x01},
+        {0x01, 0x01, 0x53, 0x00}, {0x16, 0x01, 0x53, 0x01},
+        {0x01, 0x01, 0x54, 0x00}, {0x16, 0x01, 0x54, 0x01}
+    },
+    /* 50 */
+    {
+        {0x02, 0x01, 0x4d, 0x00}, {0x09, 0x01, 0x4d, 0x00},
+        {0x17, 0x01, 0x4d, 0x00}, {0x28, 0x01, 0x4d, 0x01},
+        {0x02, 0x01, 0x4e, 0x00}, {0x09, 0x01, 0x4e, 0x00},
+        {0x17, 0x01, 0x4e, 0x00}, {0x28, 0x01, 0x4e, 0x01},
+        {0x02, 0x01, 0x4f, 0x00}, {0x09, 0x01, 0x4f, 0x00},
+        {0x17, 0x01, 0x4f, 0x00}, {0x28, 0x01, 0x4f, 0x01},
+        {0x02, 0x01, 0x50, 0x00}, {0x09, 0x01, 0x50, 0x00},
+        {0x17, 0x01, 0x50, 0x00}, {0x28, 0x01, 0x50, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x4d, 0x00}, {0x06, 0x01, 0x4d, 0x00},
+        {0x0a, 0x01, 0x4d, 0x00}, {0x0f, 0x01, 0x4d, 0x00},
+        {0x18, 0x01, 0x4d, 0x00}, {0x1f, 0x01, 0x4d, 0x00},
+        {0x29, 0x01, 0x4d, 0x00}, {0x38, 0x01, 0x4d, 0x01},
+        {0x03, 0x01, 0x4e, 0x00}, {0x06, 0x01, 0x4e, 0x00},
+        {0x0a, 0x01, 0x4e, 0x00}, {0x0f, 0x01, 0x4e, 0x00},
+        {0x18, 0x01, 0x4e, 0x00}, {0x1f, 0x01, 0x4e, 0x00},
+        {0x29, 0x01, 0x4e, 0x00}, {0x38, 0x01, 0x4e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x4f, 0x00}, {0x06, 0x01, 0x4f, 0x00},
+        {0x0a, 0x01, 0x4f, 0x00}, {0x0f, 0x01, 0x4f, 0x00},
+        {0x18, 0x01, 0x4f, 0x00}, {0x1f, 0x01, 0x4f, 0x00},
+        {0x29, 0x01, 0x4f, 0x00}, {0x38, 0x01, 0x4f, 0x01},
+        {0x03, 0x01, 0x50, 0x00}, {0x06, 0x01, 0x50, 0x00},
+        {0x0a, 0x01, 0x50, 0x00}, {0x0f, 0x01, 0x50, 0x00},
+        {0x18, 0x01, 0x50, 0x00}, {0x1f, 0x01, 0x50, 0x00},
+        {0x29, 0x01, 0x50, 0x00}, {0x38, 0x01, 0x50, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x51, 0x00}, {0x09, 0x01, 0x51, 0x00},
+        {0x17, 0x01, 0x51, 0x00}, {0x28, 0x01, 0x51, 0x01},
+        {0x02, 0x01, 0x52, 0x00}, {0x09, 0x01, 0x52, 0x00},
+        {0x17, 0x01, 0x52, 0x00}, {0x28, 0x01, 0x52, 0x01},
+        {0x02, 0x01, 0x53, 0x00}, {0x09, 0x01, 0x53, 0x00},
+        {0x17, 0x01, 0x53, 0x00}, {0x28, 0x01, 0x53, 0x01},
+        {0x02, 0x01, 0x54, 0x00}, {0x09, 0x01, 0x54, 0x00},
+        {0x17, 0x01, 0x54, 0x00}, {0x28, 0x01, 0x54, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x51, 0x00}, {0x06, 0x01, 0x51, 0x00},
+        {0x0a, 0x01, 0x51, 0x00}, {0x0f, 0x01, 0x51, 0x00},
+        {0x18, 0x01, 0x51, 0x00}, {0x1f, 0x01, 0x51, 0x00},
+        {0x29, 0x01, 0x51, 0x00}, {0x38, 0x01, 0x51, 0x01},
+        {0x03, 0x01, 0x52, 0x00}, {0x06, 0x01, 0x52, 0x00},
+        {0x0a, 0x01, 0x52, 0x00}, {0x0f, 0x01, 0x52, 0x00},
+        {0x18, 0x01, 0x52, 0x00}, {0x1f, 0x01, 0x52, 0x00},
+        {0x29, 0x01, 0x52, 0x00}, {0x38, 0x01, 0x52, 0x01}
+    },
+    /* 55 */
+    {
+        {0x03, 0x01, 0x53, 0x00}, {0x06, 0x01, 0x53, 0x00},
+        {0x0a, 0x01, 0x53, 0x00}, {0x0f, 0x01, 0x53, 0x00},
+        {0x18, 0x01, 0x53, 0x00}, {0x1f, 0x01, 0x53, 0x00},
+        {0x29, 0x01, 0x53, 0x00}, {0x38, 0x01, 0x53, 0x01},
+        {0x03, 0x01, 0x54, 0x00}, {0x06, 0x01, 0x54, 0x00},
+        {0x0a, 0x01, 0x54, 0x00}, {0x0f, 0x01, 0x54, 0x00},
+        {0x18, 0x01, 0x54, 0x00}, {0x1f, 0x01, 0x54, 0x00},
+        {0x29, 0x01, 0x54, 0x00}, {0x38, 0x01, 0x54, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x55, 0x01}, {0x00, 0x01, 0x56, 0x01},
+        {0x00, 0x01, 0x57, 0x01}, {0x00, 0x01, 0x59, 0x01},
+        {0x00, 0x01, 0x6a, 0x01}, {0x00, 0x01, 0x6b, 0x01},
+        {0x00, 0x01, 0x71, 0x01}, {0x00, 0x01, 0x76, 0x01},
+        {0x00, 0x01, 0x77, 0x01}, {0x00, 0x01, 0x78, 0x01},
+        {0x00, 0x01, 0x79, 0x01}, {0x00, 0x01, 0x7a, 0x01},
+        {0x46, 0x00, 0x00, 0x00}, {0x47, 0x00, 0x00, 0x00},
+        {0x49, 0x00, 0x00, 0x00}, {0x4a, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x55, 0x00}, {0x16, 0x01, 0x55, 0x01},
+        {0x01, 0x01, 0x56, 0x00}, {0x16, 0x01, 0x56, 0x01},
+        {0x01, 0x01, 0x57, 0x00}, {0x16, 0x01, 0x57, 0x01},
+        {0x01, 0x01, 0x59, 0x00}, {0x16, 0x01, 0x59, 0x01},
+        {0x01, 0x01, 0x6a, 0x00}, {0x16, 0x01, 0x6a, 0x01},
+        {0x01, 0x01, 0x6b, 0x00}, {0x16, 0x01, 0x6b, 0x01},
+        {0x01, 0x01, 0x71, 0x00}, {0x16, 0x01, 0x71, 0x01},
+        {0x01, 0x01, 0x76, 0x00}, {0x16, 0x01, 0x76, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x55, 0x00}, {0x09, 0x01, 0x55, 0x00},
+        {0x17, 0x01, 0x55, 0x00}, {0x28, 0x01, 0x55, 0x01},
+        {0x02, 0x01, 0x56, 0x00}, {0x09, 0x01, 0x56, 0x00},
+        {0x17, 0x01, 0x56, 0x00}, {0x28, 0x01, 0x56, 0x01},
+        {0x02, 0x01, 0x57, 0x00}, {0x09, 0x01, 0x57, 0x00},
+        {0x17, 0x01, 0x57, 0x00}, {0x28, 0x01, 0x57, 0x01},
+        {0x02, 0x01, 0x59, 0x00}, {0x09, 0x01, 0x59, 0x00},
+        {0x17, 0x01, 0x59, 0x00}, {0x28, 0x01, 0x59, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x55, 0x00}, {0x06, 0x01, 0x55, 0x00},
+        {0x0a, 0x01, 0x55, 0x00}, {0x0f, 0x01, 0x55, 0x00},
+        {0x18, 0x01, 0x55, 0x00}, {0x1f, 0x01, 0x55, 0x00},
+        {0x29, 0x01, 0x55, 0x00}, {0x38, 0x01, 0x55, 0x01},
+        {0x03, 0x01, 0x56, 0x00}, {0x06, 0x01, 0x56, 0x00},
+        {0x0a, 0x01, 0x56, 0x00}, {0x0f, 0x01, 0x56, 0x00},
+        {0x18, 0x01, 0x56, 0x00}, {0x1f, 0x01, 0x56, 0x00},
+        {0x29, 0x01, 0x56, 0x00}, {0x38, 0x01, 0x56, 0x01}
+    },
+    /* 60 */
+    {
+        {0x03, 0x01, 0x57, 0x00}, {0x06, 0x01, 0x57, 0x00},
+        {0x0a, 0x01, 0x57, 0x00}, {0x0f, 0x01, 0x57, 0x00},
+        {0x18, 0x01, 0x57, 0x00}, {0x1f, 0x01, 0x57, 0x00},
+        {0x29, 0x01, 0x57, 0x00}, {0x38, 0x01, 0x57, 0x01},
+        {0x03, 0x01, 0x59, 0x00}, {0x06, 0x01, 0x59, 0x00},
+        {0x0a, 0x01, 0x59, 0x00}, {0x0f, 0x01, 0x59, 0x00},
+        {0x18, 0x01, 0x59, 0x00}, {0x1f, 0x01, 0x59, 0x00},
+        {0x29, 0x01, 0x59, 0x00}, {0x38, 0x01, 0x59, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x6a, 0x00}, {0x09, 0x01, 0x6a, 0x00},
+        {0x17, 0x01, 0x6a, 0x00}, {0x28, 0x01, 0x6a, 0x01},
+        {0x02, 0x01, 0x6b, 0x00}, {0x09, 0x01, 0x6b, 0x00},
+        {0x17, 0x01, 0x6b, 0x00}, {0x28, 0x01, 0x6b, 0x01},
+        {0x02, 0x01, 0x71, 0x00}, {0x09, 0x01, 0x71, 0x00},
+        {0x17, 0x01, 0x71, 0x00}, {0x28, 0x01, 0x71, 0x01},
+        {0x02, 0x01, 0x76, 0x00}, {0x09, 0x01, 0x76, 0x00},
+        {0x17, 0x01, 0x76, 0x00}, {0x28, 0x01, 0x76, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x6a, 0x00}, {0x06, 0x01, 0x6a, 0x00},
+        {0x0a, 0x01, 0x6a, 0x00}, {0x0f, 0x01, 0x6a, 0x00},
+        {0x18, 0x01, 0x6a, 0x00}, {0x1f, 0x01, 0x6a, 0x00},
+        {0x29, 0x01, 0x6a, 0x00}, {0x38, 0x01, 0x6a, 0x01},
+        {0x03, 0x01, 0x6b, 0x00}, {0x06, 0x01, 0x6b, 0x00},
+        {0x0a, 0x01, 0x6b, 0x00}, {0x0f, 0x01, 0x6b, 0x00},
+        {0x18, 0x01, 0x6b, 0x00}, {0x1f, 0x01, 0x6b, 0x00},
+        {0x29, 0x01, 0x6b, 0x00}, {0x38, 0x01, 0x6b, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x71, 0x00}, {0x06, 0x01, 0x71, 0x00},
+        {0x0a, 0x01, 0x71, 0x00}, {0x0f, 0x01, 0x71, 0x00},
+        {0x18, 0x01, 0x71, 0x00}, {0x1f, 0x01, 0x71, 0x00},
+        {0x29, 0x01, 0x71, 0x00}, {0x38, 0x01, 0x71, 0x01},
+        {0x03, 0x01, 0x76, 0x00}, {0x06, 0x01, 0x76, 0x00},
+        {0x0a, 0x01, 0x76, 0x00}, {0x0f, 0x01, 0x76, 0x00},
+        {0x18, 0x01, 0x76, 0x00}, {0x1f, 0x01, 0x76, 0x00},
+        {0x29, 0x01, 0x76, 0x00}, {0x38, 0x01, 0x76, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x77, 0x00}, {0x16, 0x01, 0x77, 0x01},
+        {0x01, 0x01, 0x78, 0x00}, {0x16, 0x01, 0x78, 0x01},
+        {0x01, 0x01, 0x79, 0x00}, {0x16, 0x01, 0x79, 0x01},
+        {0x01, 0x01, 0x7a, 0x00}, {0x16, 0x01, 0x7a, 0x01},
+        {0x00, 0x01, 0x26, 0x01}, {0x00, 0x01, 0x2a, 0x01},
+        {0x00, 0x01, 0x2c, 0x01}, {0x00, 0x01, 0x3b, 0x01},
+        {0x00, 0x01, 0x58, 0x01}, {0x00, 0x01, 0x5a, 0x01},
+        {0x4b, 0x00, 0x00, 0x00}, {0x4e, 0x00, 0x00, 0x01}
+    },
+    /* 65 */
+    {
+        {0x02, 0x01, 0x77, 0x00}, {0x09, 0x01, 0x77, 0x00},
+        {0x17, 0x01, 0x77, 0x00}, {0x28, 0x01, 0x77, 0x01},
+        {0x02, 0x01, 0x78, 0x00}, {0x09, 0x01, 0x78, 0x00},
+        {0x17, 0x01, 0x78, 0x00}, {0x28, 0x01, 0x78, 0x01},
+        {0x02, 0x01, 0x79, 0x00}, {0x09, 0x01, 0x79, 0x00},
+        {0x17, 0x01, 0x79, 0x00}, {0x28, 0x01, 0x79, 0x01},
+        {0x02, 0x01, 0x7a, 0x00}, {0x09, 0x01, 0x7a, 0x00},
+        {0x17, 0x01, 0x7a, 0x00}, {0x28, 0x01, 0x7a, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x77, 0x00}, {0x06, 0x01, 0x77, 0x00},
+        {0x0a, 0x01, 0x77, 0x00}, {0x0f, 0x01, 0x77, 0x00},
+        {0x18, 0x01, 0x77, 0x00}, {0x1f, 0x01, 0x77, 0x00},
+        {0x29, 0x01, 0x77, 0x00}, {0x38, 0x01, 0x77, 0x01},
+        {0x03, 0x01, 0x78, 0x00}, {0x06, 0x01, 0x78, 0x00},
+        {0x0a, 0x01, 0x78, 0x00}, {0x0f, 0x01, 0x78, 0x00},
+        {0x18, 0x01, 0x78, 0x00}, {0x1f, 0x01, 0x78, 0x00},
+        {0x29, 0x01, 0x78, 0x00}, {0x38, 0x01, 0x78, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x79, 0x00}, {0x06, 0x01, 0x79, 0x00},
+        {0x0a, 0x01, 0x79, 0x00}, {0x0f, 0x01, 0x79, 0x00},
+        {0x18, 0x01, 0x79, 0x00}, {0x1f, 0x01, 0x79, 0x00},
+        {0x29, 0x01, 0x79, 0x00}, {0x38, 0x01, 0x79, 0x01},
+        {0x03, 0x01, 0x7a, 0x00}, {0x06, 0x01, 0x7a, 0x00},
+        {0x0a, 0x01, 0x7a, 0x00}, {0x0f, 0x01, 0x7a, 0x00},
+        {0x18, 0x01, 0x7a, 0x00}, {0x1f, 0x01, 0x7a, 0x00},
+        {0x29, 0x01, 0x7a, 0x00}, {0x38, 0x01, 0x7a, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x26, 0x00}, {0x16, 0x01, 0x26, 0x01},
+        {0x01, 0x01, 0x2a, 0x00}, {0x16, 0x01, 0x2a, 0x01},
+        {0x01, 0x01, 0x2c, 0x00}, {0x16, 0x01, 0x2c, 0x01},
+        {0x01, 0x01, 0x3b, 0x00}, {0x16, 0x01, 0x3b, 0x01},
+        {0x01, 0x01, 0x58, 0x00}, {0x16, 0x01, 0x58, 0x01},
+        {0x01, 0x01, 0x5a, 0x00}, {0x16, 0x01, 0x5a, 0x01},
+        {0x4c, 0x00, 0x00, 0x00}, {0x4d, 0x00, 0x00, 0x00},
+        {0x4f, 0x00, 0x00, 0x00}, {0x51, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x26, 0x00}, {0x09, 0x01, 0x26, 0x00},
+        {0x17, 0x01, 0x26, 0x00}, {0x28, 0x01, 0x26, 0x01},
+        {0x02, 0x01, 0x2a, 0x00}, {0x09, 0x01, 0x2a, 0x00},
+        {0x17, 0x01, 0x2a, 0x00}, {0x28, 0x01, 0x2a, 0x01},
+        {0x02, 0x01, 0x2c, 0x00}, {0x09, 0x01, 0x2c, 0x00},
+        {0x17, 0x01, 0x2c, 0x00}, {0x28, 0x01, 0x2c, 0x01},
+        {0x02, 0x01, 0x3b, 0x00}, {0x09, 0x01, 0x3b, 0x00},
+        {0x17, 0x01, 0x3b, 0x00}, {0x28, 0x01, 0x3b, 0x01}
+    },
+    /* 70 */
+    {
+        {0x03, 0x01, 0x26, 0x00}, {0x06, 0x01, 0x26, 0x00},
+        {0x0a, 0x01, 0x26, 0x00}, {0x0f, 0x01, 0x26, 0x00},
+        {0x18, 0x01, 0x26, 0x00}, {0x1f, 0x01, 0x26, 0x00},
+        {0x29, 0x01, 0x26, 0x00}, {0x38, 0x01, 0x26, 0x01},
+        {0x03, 0x01, 0x2a, 0x00}, {0x06, 0x01, 0x2a, 0x00},
+        {0x0a, 0x01, 0x2a, 0x00}, {0x0f, 0x01, 0x2a, 0x00},
+        {0x18, 0x01, 0x2a, 0x00}, {0x1f, 0x01, 0x2a, 0x00},
+        {0x29, 0x01, 0x2a, 0x00}, {0x38, 0x01, 0x2a, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x2c, 0x00}, {0x06, 0x01, 0x2c, 0x00},
+        {0x0a, 0x01, 0x2c, 0x00}, {0x0f, 0x01, 0x2c, 0x00},
+        {0x18, 0x01, 0x2c, 0x00}, {0x1f, 0x01, 0x2c, 0x00},
+        {0x29, 0x01, 0x2c, 0x00}, {0x38, 0x01, 0x2c, 0x01},
+        {0x03, 0x01, 0x3b, 0x00}, {0x06, 0x01, 0x3b, 0x00},
+        {0x0a, 0x01, 0x3b, 0x00}, {0x0f, 0x01, 0x3b, 0x00},
+        {0x18, 0x01, 0x3b, 0x00}, {0x1f, 0x01, 0x3b, 0x00},
+        {0x29, 0x01, 0x3b, 0x00}, {0x38, 0x01, 0x3b, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x58, 0x00}, {0x09, 0x01, 0x58, 0x00},
+        {0x17, 0x01, 0x58, 0x00}, {0x28, 0x01, 0x58, 0x01},
+        {0x02, 0x01, 0x5a, 0x00}, {0x09, 0x01, 0x5a, 0x00},
+        {0x17, 0x01, 0x5a, 0x00}, {0x28, 0x01, 0x5a, 0x01},
+        {0x00, 0x01, 0x21, 0x01}, {0x00, 0x01, 0x22, 0x01},
+        {0x00, 0x01, 0x28, 0x01}, {0x00, 0x01, 0x29, 0x01},
+        {0x00, 0x01, 0x3f, 0x01}, {0x50, 0x00, 0x00, 0x00},
+        {0x52, 0x00, 0x00, 0x00}, {0x54, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x58, 0x00}, {0x06, 0x01, 0x58, 0x00},
+        {0x0a, 0x01, 0x58, 0x00}, {0x0f, 0x01, 0x58, 0x00},
+        {0x18, 0x01, 0x58, 0x00}, {0x1f, 0x01, 0x58, 0x00},
+        {0x29, 0x01, 0x58, 0x00}, {0x38, 0x01, 0x58, 0x01},
+        {0x03, 0x01, 0x5a, 0x00}, {0x06, 0x01, 0x5a, 0x00},
+        {0x0a, 0x01, 0x5a, 0x00}, {0x0f, 0x01, 0x5a, 0x00},
+        {0x18, 0x01, 0x5a, 0x00}, {0x1f, 0x01, 0x5a, 0x00},
+        {0x29, 0x01, 0x5a, 0x00}, {0x38, 0x01, 0x5a, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x21, 0x00}, {0x16, 0x01, 0x21, 0x01},
+        {0x01, 0x01, 0x22, 0x00}, {0x16, 0x01, 0x22, 0x01},
+        {0x01, 0x01, 0x28, 0x00}, {0x16, 0x01, 0x28, 0x01},
+        {0x01, 0x01, 0x29, 0x00}, {0x16, 0x01, 0x29, 0x01},
+        {0x01, 0x01, 0x3f, 0x00}, {0x16, 0x01, 0x3f, 0x01},
+        {0x00, 0x01, 0x27, 0x01}, {0x00, 0x01, 0x2b, 0x01},
+        {0x00, 0x01, 0x7c, 0x01}, {0x53, 0x00, 0x00, 0x00},
+        {0x55, 0x00, 0x00, 0x00}, {0x58, 0x00, 0x00, 0x01}
+    },
+    /* 75 */
+    {
+        {0x02, 0x01, 0x21, 0x00}, {0x09, 0x01, 0x21, 0x00},
+        {0x17, 0x01, 0x21, 0x00}, {0x28, 0x01, 0x21, 0x01},
+        {0x02, 0x01, 0x22, 0x00}, {0x09, 0x01, 0x22, 0x00},
+        {0x17, 0x01, 0x22, 0x00}, {0x28, 0x01, 0x22, 0x01},
+        {0x02, 0x01, 0x28, 0x00}, {0x09, 0x01, 0x28, 0x00},
+        {0x17, 0x01, 0x28, 0x00}, {0x28, 0x01, 0x28, 0x01},
+        {0x02, 0x01, 0x29, 0x00}, {0x09, 0x01, 0x29, 0x00},
+        {0x17, 0x01, 0x29, 0x00}, {0x28, 0x01, 0x29, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x21, 0x00}, {0x06, 0x01, 0x21, 0x00},
+        {0x0a, 0x01, 0x21, 0x00}, {0x0f, 0x01, 0x21, 0x00},
+        {0x18, 0x01, 0x21, 0x00}, {0x1f, 0x01, 0x21, 0x00},
+        {0x29, 0x01, 0x21, 0x00}, {0x38, 0x01, 0x21, 0x01},
+        {0x03, 0x01, 0x22, 0x00}, {0x06, 0x01, 0x22, 0x00},
+        {0x0a, 0x01, 0x22, 0x00}, {0x0f, 0x01, 0x22, 0x00},
+        {0x18, 0x01, 0x22, 0x00}, {0x1f, 0x01, 0x22, 0x00},
+        {0x29, 0x01, 0x22, 0x00}, {0x38, 0x01, 0x22, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x28, 0x00}, {0x06, 0x01, 0x28, 0x00},
+        {0x0a, 0x01, 0x28, 0x00}, {0x0f, 0x01, 0x28, 0x00},
+        {0x18, 0x01, 0x28, 0x00}, {0x1f, 0x01, 0x28, 0x00},
+        {0x29, 0x01, 0x28, 0x00}, {0x38, 0x01, 0x28, 0x01},
+        {0x03, 0x01, 0x29, 0x00}, {0x06, 0x01, 0x29, 0x00},
+        {0x0a, 0x01, 0x29, 0x00}, {0x0f, 0x01, 0x29, 0x00},
+        {0x18, 0x01, 0x29, 0x00}, {0x1f, 0x01, 0x29, 0x00},
+        {0x29, 0x01, 0x29, 0x00}, {0x38, 0x01, 0x29, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x3f, 0x00}, {0x09, 0x01, 0x3f, 0x00},
+        {0x17, 0x01, 0x3f, 0x00}, {0x28, 0x01, 0x3f, 0x01},
+        {0x01, 0x01, 0x27, 0x00}, {0x16, 0x01, 0x27, 0x01},
+        {0x01, 0x01, 0x2b, 0x00}, {0x16, 0x01, 0x2b, 0x01},
+        {0x01, 0x01, 0x7c, 0x00}, {0x16, 0x01, 0x7c, 0x01},
+        {0x00, 0x01, 0x23, 0x01}, {0x00, 0x01, 0x3e, 0x01},
+        {0x56, 0x00, 0x00, 0x00}, {0x57, 0x00, 0x00, 0x00},
+        {0x59, 0x00, 0x00, 0x00}, {0x5a, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x3f, 0x00}, {0x06, 0x01, 0x3f, 0x00},
+        {0x0a, 0x01, 0x3f, 0x00}, {0x0f, 0x01, 0x3f, 0x00},
+        {0x18, 0x01, 0x3f, 0x00}, {0x1f, 0x01, 0x3f, 0x00},
+        {0x29, 0x01, 0x3f, 0x00}, {0x38, 0x01, 0x3f, 0x01},
+        {0x02, 0x01, 0x27, 0x00}, {0x09, 0x01, 0x27, 0x00},
+        {0x17, 0x01, 0x27, 0x00}, {0x28, 0x01, 0x27, 0x01},
+        {0x02, 0x01, 0x2b, 0x00}, {0x09, 0x01, 0x2b, 0x00},
+        {0x17, 0x01, 0x2b, 0x00}, {0x28, 0x01, 0x2b, 0x01}
+    },
+    /* 80 */
+    {
+        {0x03, 0x01, 0x27, 0x00}, {0x06, 0x01, 0x27, 0x00},
+        {0x0a, 0x01, 0x27, 0x00}, {0x0f, 0x01, 0x27, 0x00},
+        {0x18, 0x01, 0x27, 0x00}, {0x1f, 0x01, 0x27, 0x00},
+        {0x29, 0x01, 0x27, 0x00}, {0x38, 0x01, 0x27, 0x01},
+        {0x03, 0x01, 0x2b, 0x00}, {0x06, 0x01, 0x2b, 0x00},
+        {0x0a, 0x01, 0x2b, 0x00}, {0x0f, 0x01, 0x2b, 0x00},
+        {0x18, 0x01, 0x2b, 0x00}, {0x1f, 0x01, 0x2b, 0x00},
+        {0x29, 0x01, 0x2b, 0x00}, {0x38, 0x01, 0x2b, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x7c, 0x00}, {0x09, 0x01, 0x7c, 0x00},
+        {0x17, 0x01, 0x7c, 0x00}, {0x28, 0x01, 0x7c, 0x01},
+        {0x01, 0x01, 0x23, 0x00}, {0x16, 0x01, 0x23, 0x01},
+        {0x01, 0x01, 0x3e, 0x00}, {0x16, 0x01, 0x3e, 0x01},
+        {0x00, 0x01, 0x00, 0x01}, {0x00, 0x01, 0x24, 0x01},
+        {0x00, 0x01, 0x40, 0x01}, {0x00, 0x01, 0x5b, 0x01},
+        {0x00, 0x01, 0x5d, 0x01}, {0x00, 0x01, 0x7e, 0x01},
+        {0x5b, 0x00, 0x00, 0x00}, {0x5c, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x7c, 0x00}, {0x06, 0x01, 0x7c, 0x00},
+        {0x0a, 0x01, 0x7c, 0x00}, {0x0f, 0x01, 0x7c, 0x00},
+        {0x18, 0x01, 0x7c, 0x00}, {0x1f, 0x01, 0x7c, 0x00},
+        {0x29, 0x01, 0x7c, 0x00}, {0x38, 0x01, 0x7c, 0x01},
+        {0x02, 0x01, 0x23, 0x00}, {0x09, 0x01, 0x23, 0x00},
+        {0x17, 0x01, 0x23, 0x00}, {0x28, 0x01, 0x23, 0x01},
+        {0x02, 0x01, 0x3e, 0x00}, {0x09, 0x01, 0x3e, 0x00},
+        {0x17, 0x01, 0x3e, 0x00}, {0x28, 0x01, 0x3e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x23, 0x00}, {0x06, 0x01, 0x23, 0x00},
+        {0x0a, 0x01, 0x23, 0x00}, {0x0f, 0x01, 0x23, 0x00},
+        {0x18, 0x01, 0x23, 0x00}, {0x1f, 0x01, 0x23, 0x00},
+        {0x29, 0x01, 0x23, 0x00}, {0x38, 0x01, 0x23, 0x01},
+        {0x03, 0x01, 0x3e, 0x00}, {0x06, 0x01, 0x3e, 0x00},
+        {0x0a, 0x01, 0x3e, 0x00}, {0x0f, 0x01, 0x3e, 0x00},
+        {0x18, 0x01, 0x3e, 0x00}, {0x1f, 0x01, 0x3e, 0x00},
+        {0x29, 0x01, 0x3e, 0x00}, {0x38, 0x01, 0x3e, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x00, 0x00}, {0x16, 0x01, 0x00, 0x01},
+        {0x01, 0x01, 0x24, 0x00}, {0x16, 0x01, 0x24, 0x01},
+        {0x01, 0x01, 0x40, 0x00}, {0x16, 0x01, 0x40, 0x01},
+        {0x01, 0x01, 0x5b, 0x00}, {0x16, 0x01, 0x5b, 0x01},
+        {0x01, 0x01, 0x5d, 0x00}, {0x16, 0x01, 0x5d, 0x01},
+        {0x01, 0x01, 0x7e, 0x00}, {0x16, 0x01, 0x7e, 0x01},
+        {0x00, 0x01, 0x5e, 0x01}, {0x00, 0x01, 0x7d, 0x01},
+        {0x5d, 0x00, 0x00, 0x00}, {0x5e, 0x00, 0x00, 0x01}
+    },
+    /* 85 */
+    {
+        {0x02, 0x01, 0x00, 0x00}, {0x09, 0x01, 0x00, 0x00},
+        {0x17, 0x01, 0x00, 0x00}, {0x28, 0x01, 0x00, 0x01},
+        {0x02, 0x01, 0x24, 0x00}, {0x09, 0x01, 0x24, 0x00},
+        {0x17, 0x01, 0x24, 0x00}, {0x28, 0x01, 0x24, 0x01},
+        {0x02, 0x01, 0x40, 0x00}, {0x09, 0x01, 0x40, 0x00},
+        {0x17, 0x01, 0x40, 0x00}, {0x28, 0x01, 0x40, 0x01},
+        {0x02, 0x01, 0x5b, 0x00}, {0x09, 0x01, 0x5b, 0x00},
+        {0x17, 0x01, 0x5b, 0x00}, {0x28, 0x01, 0x5b, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x00, 0x00}, {0x06, 0x01, 0x00, 0x00},
+        {0x0a, 0x01, 0x00, 0x00}, {0x0f, 0x01, 0x00, 0x00},
+        {0x18, 0x01, 0x00, 0x00}, {0x1f, 0x01, 0x00, 0x00},
+        {0x29, 0x01, 0x00, 0x00}, {0x38, 0x01, 0x00, 0x01},
+        {0x03, 0x01, 0x24, 0x00}, {0x06, 0x01, 0x24, 0x00},
+        {0x0a, 0x01, 0x24, 0x00}, {0x0f, 0x01, 0x24, 0x00},
+        {0x18, 0x01, 0x24, 0x00}, {0x1f, 0x01, 0x24, 0x00},
+        {0x29, 0x01, 0x24, 0x00}, {0x38, 0x01, 0x24, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x40, 0x00}, {0x06, 0x01, 0x40, 0x00},
+        {0x0a, 0x01, 0x40, 0x00}, {0x0f, 0x01, 0x40, 0x00},
+        {0x18, 0x01, 0x40, 0x00}, {0x1f, 0x01, 0x40, 0x00},
+        {0x29, 0x01, 0x40, 0x00}, {0x38, 0x01, 0x40, 0x01},
+        {0x03, 0x01, 0x5b, 0x00}, {0x06, 0x01, 0x5b, 0x00},
+        {0x0a, 0x01, 0x5b, 0x00}, {0x0f, 0x01, 0x5b, 0x00},
+        {0x18, 0x01, 0x5b, 0x00}, {0x1f, 0x01, 0x5b, 0x00},
+        {0x29, 0x01, 0x5b, 0x00}, {0x38, 0x01, 0x5b, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x5d, 0x00}, {0x09, 0x01, 0x5d, 0x00},
+        {0x17, 0x01, 0x5d, 0x00}, {0x28, 0x01, 0x5d, 0x01},
+        {0x02, 0x01, 0x7e, 0x00}, {0x09, 0x01, 0x7e, 0x00},
+        {0x17, 0x01, 0x7e, 0x00}, {0x28, 0x01, 0x7e, 0x01},
+        {0x01, 0x01, 0x5e, 0x00}, {0x16, 0x01, 0x5e, 0x01},
+        {0x01, 0x01, 0x7d, 0x00}, {0x16, 0x01, 0x7d, 0x01},
+        {0x00, 0x01, 0x3c, 0x01}, {0x00, 0x01, 0x60, 0x01},
+        {0x00, 0x01, 0x7b, 0x01}, {0x5f, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x5d, 0x00}, {0x06, 0x01, 0x5d, 0x00},
+        {0x0a, 0x01, 0x5d, 0x00}, {0x0f, 0x01, 0x5d, 0x00},
+        {0x18, 0x01, 0x5d, 0x00}, {0x1f, 0x01, 0x5d, 0x00},
+        {0x29, 0x01, 0x5d, 0x00}, {0x38, 0x01, 0x5d, 0x01},
+        {0x03, 0x01, 0x7e, 0x00}, {0x06, 0x01, 0x7e, 0x00},
+        {0x0a, 0x01, 0x7e, 0x00}, {0x0f, 0x01, 0x7e, 0x00},
+        {0x18, 0x01, 0x7e, 0x00}, {0x1f, 0x01, 0x7e, 0x00},
+        {0x29, 0x01, 0x7e, 0x00}, {0x38, 0x01, 0x7e, 0x01}
+    },
+    /* 90 */
+    {
+        {0x02, 0x01, 0x5e, 0x00}, {0x09, 0x01, 0x5e, 0x00},
+        {0x17, 0x01, 0x5e, 0x00}, {0x28, 0x01, 0x5e, 0x01},
+        {0x02, 0x01, 0x7d, 0x00}, {0x09, 0x01, 0x7d, 0x00},
+        {0x17, 0x01, 0x7d, 0x00}, {0x28, 0x01, 0x7d, 0x01},
+        {0x01, 0x01, 0x3c, 0x00}, {0x16, 0x01, 0x3c, 0x01},
+        {0x01, 0x01, 0x60, 0x00}, {0x16, 0x01, 0x60, 0x01},
+        {0x01, 0x01, 0x7b, 0x00}, {0x16, 0x01, 0x7b, 0x01},
+        {0x60, 0x00, 0x00, 0x00}, {0x6e, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x5e, 0x00}, {0x06, 0x01, 0x5e, 0x00},
+        {0x0a, 0x01, 0x5e, 0x00}, {0x0f, 0x01, 0x5e, 0x00},
+        {0x18, 0x01, 0x5e, 0x00}, {0x1f, 0x01, 0x5e, 0x00},
+        {0x29, 0x01, 0x5e, 0x00}, {0x38, 0x01, 0x5e, 0x01},
+        {0x03, 0x01, 0x7d, 0x00}, {0x06, 0x01, 0x7d, 0x00},
+        {0x0a, 0x01, 0x7d, 0x00}, {0x0f, 0x01, 0x7d, 0x00},
+        {0x18, 0x01, 0x7d, 0x00}, {0x1f, 0x01, 0x7d, 0x00},
+        {0x29, 0x01, 0x7d, 0x00}, {0x38, 0x01, 0x7d, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x3c, 0x00}, {0x09, 0x01, 0x3c, 0x00},
+        {0x17, 0x01, 0x3c, 0x00}, {0x28, 0x01, 0x3c, 0x01},
+        {0x02, 0x01, 0x60, 0x00}, {0x09, 0x01, 0x60, 0x00},
+        {0x17, 0x01, 0x60, 0x00}, {0x28, 0x01, 0x60, 0x01},
+        {0x02, 0x01, 0x7b, 0x00}, {0x09, 0x01, 0x7b, 0x00},
+        {0x17, 0x01, 0x7b, 0x00}, {0x28, 0x01, 0x7b, 0x01},
+        {0x61, 0x00, 0x00, 0x00}, {0x65, 0x00, 0x00, 0x00},
+        {0x6f, 0x00, 0x00, 0x00}, {0x85, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x3c, 0x00}, {0x06, 0x01, 0x3c, 0x00},
+        {0x0a, 0x01, 0x3c, 0x00}, {0x0f, 0x01, 0x3c, 0x00},
+        {0x18, 0x01, 0x3c, 0x00}, {0x1f, 0x01, 0x3c, 0x00},
+        {0x29, 0x01, 0x3c, 0x00}, {0x38, 0x01, 0x3c, 0x01},
+        {0x03, 0x01, 0x60, 0x00}, {0x06, 0x01, 0x60, 0x00},
+        {0x0a, 0x01, 0x60, 0x00}, {0x0f, 0x01, 0x60, 0x00},
+        {0x18, 0x01, 0x60, 0x00}, {0x1f, 0x01, 0x60, 0x00},
+        {0x29, 0x01, 0x60, 0x00}, {0x38, 0x01, 0x60, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x7b, 0x00}, {0x06, 0x01, 0x7b, 0x00},
+        {0x0a, 0x01, 0x7b, 0x00}, {0x0f, 0x01, 0x7b, 0x00},
+        {0x18, 0x01, 0x7b, 0x00}, {0x1f, 0x01, 0x7b, 0x00},
+        {0x29, 0x01, 0x7b, 0x00}, {0x38, 0x01, 0x7b, 0x01},
+        {0x62, 0x00, 0x00, 0x00}, {0x63, 0x00, 0x00, 0x00},
+        {0x66, 0x00, 0x00, 0x00}, {0x69, 0x00, 0x00, 0x00},
+        {0x70, 0x00, 0x00, 0x00}, {0x77, 0x00, 0x00, 0x00},
+        {0x86, 0x00, 0x00, 0x00}, {0x99, 0x00, 0x00, 0x01}
+    },
+    /* 95 */
+    {
+        {0x00, 0x01, 0x5c, 0x01}, {0x00, 0x01, 0xc3, 0x01},
+        {0x00, 0x01, 0xd0, 0x01}, {0x64, 0x00, 0x00, 0x00},
+        {0x67, 0x00, 0x00, 0x00}, {0x68, 0x00, 0x00, 0x00},
+        {0x6a, 0x00, 0x00, 0x00}, {0x6b, 0x00, 0x00, 0x00},
+        {0x71, 0x00, 0x00, 0x00}, {0x74, 0x00, 0x00, 0x00},
+        {0x78, 0x00, 0x00, 0x00}, {0x7e, 0x00, 0x00, 0x00},
+        {0x87, 0x00, 0x00, 0x00}, {0x8e, 0x00, 0x00, 0x00},
+        {0x9a, 0x00, 0x00, 0x00}, {0xa9, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x5c, 0x00}, {0x16, 0x01, 0x5c, 0x01},
+        {0x01, 0x01, 0xc3, 0x00}, {0x16, 0x01, 0xc3, 0x01},
+        {0x01, 0x01, 0xd0, 0x00}, {0x16, 0x01, 0xd0, 0x01},
+        {0x00, 0x01, 0x80, 0x01}, {0x00, 0x01, 0x82, 0x01},
+        {0x00, 0x01, 0x83, 0x01}, {0x00, 0x01, 0xa2, 0x01},
+        {0x00, 0x01, 0xb8, 0x01}, {0x00, 0x01, 0xc2, 0x01},
+        {0x00, 0x01, 0xe0, 0x01}, {0x00, 0x01, 0xe2, 0x01},
+        {0x6c, 0x00, 0x00, 0x00}, {0x6d, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x02, 0x01, 0x5c, 0x00}, {0x09, 0x01, 0x5c, 0x00},
+        {0x17, 0x01, 0x5c, 0x00}, {0x28, 0x01, 0x5c, 0x01},
+        {0x02, 0x01, 0xc3, 0x00}, {0x09, 0x01, 0xc3, 0x00},
+        {0x17, 0x01, 0xc3, 0x00}, {0x28, 0x01, 0xc3, 0x01},
+        {0x02, 0x01, 0xd0, 0x00}, {0x09, 0x01, 0xd0, 0x00},
+        {0x17, 0x01, 0xd0, 0x00}, {0x28, 0x01, 0xd0, 0x01},
+        {0x01, 0x01, 0x80, 0x00}, {0x16, 0x01, 0x80, 0x01},
+        {0x01, 0x01, 0x82, 0x00}, {0x16, 0x01, 0x82, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x5c, 0x00}, {0x06, 0x01, 0x5c, 0x00},
+        {0x0a, 0x01, 0x5c, 0x00}, {0x0f, 0x01, 0x5c, 0x00},
+        {0x18, 0x01, 0x5c, 0x00}, {0x1f, 0x01, 0x5c, 0x00},
+        {0x29, 0x01, 0x5c, 0x00}, {0x38, 0x01, 0x5c, 0x01},
+        {0x03, 0x01, 0xc3, 0x00}, {0x06, 0x01, 0xc3, 0x00},
+        {0x0a, 0x01, 0xc3, 0x00}, {0x0f, 0x01, 0xc3, 0x00},
+        {0x18, 0x01, 0xc3, 0x00}, {0x1f, 0x01, 0xc3, 0x00},
+        {0x29, 0x01, 0xc3, 0x00}, {0x38, 0x01, 0xc3, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd0, 0x00}, {0x06, 0x01, 0xd0, 0x00},
+        {0x0a, 0x01, 0xd0, 0x00}, {0x0f, 0x01, 0xd0, 0x00},
+        {0x18, 0x01, 0xd0, 0x00}, {0x1f, 0x01, 0xd0, 0x00},
+        {0x29, 0x01, 0xd0, 0x00}, {0x38, 0x01, 0xd0, 0x01},
+        {0x02, 0x01, 0x80, 0x00}, {0x09, 0x01, 0x80, 0x00},
+        {0x17, 0x01, 0x80, 0x00}, {0x28, 0x01, 0x80, 0x01},
+        {0x02, 0x01, 0x82, 0x00}, {0x09, 0x01, 0x82, 0x00},
+        {0x17, 0x01, 0x82, 0x00}, {0x28, 0x01, 0x82, 0x01}
+    },
+    /* 100 */
+    {
+        {0x03, 0x01, 0x80, 0x00}, {0x06, 0x01, 0x80, 0x00},
+        {0x0a, 0x01, 0x80, 0x00}, {0x0f, 0x01, 0x80, 0x00},
+        {0x18, 0x01, 0x80, 0x00}, {0x1f, 0x01, 0x80, 0x00},
+        {0x29, 0x01, 0x80, 0x00}, {0x38, 0x01, 0x80, 0x01},
+        {0x03, 0x01, 0x82, 0x00}, {0x06, 0x01, 0x82, 0x00},
+        {0x0a, 0x01, 0x82, 0x00}, {0x0f, 0x01, 0x82, 0x00},
+        {0x18, 0x01, 0x82, 0x00}, {0x1f, 0x01, 0x82, 0x00},
+        {0x29, 0x01, 0x82, 0x00}, {0x38, 0x01, 0x82, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x83, 0x00}, {0x16, 0x01, 0x83, 0x01},
+        {0x01, 0x01, 0xa2, 0x00}, {0x16, 0x01, 0xa2, 0x01},
+        {0x01, 0x01, 0xb8, 0x00}, {0x16, 0x01, 0xb8, 0x01},
+        {0x01, 0x01, 0xc2, 0x00}, {0x16, 0x01, 0xc2, 0x01},
+        {0x01, 0x01, 0xe0, 0x00}, {0x16, 0x01, 0xe0, 0x01},
+        {0x01, 0x01, 0xe2, 0x00}, {0x16, 0x01, 0xe2, 0x01},
+        {0x00, 0x01, 0x99, 0x01}, {0x00, 0x01, 0xa1, 0x01},
+        {0x00, 0x01, 0xa7, 0x01}, {0x00, 0x01, 0xac, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x83, 0x00}, {0x09, 0x01, 0x83, 0x00},
+        {0x17, 0x01, 0x83, 0x00}, {0x28, 0x01, 0x83, 0x01},
+        {0x02, 0x01, 0xa2, 0x00}, {0x09, 0x01, 0xa2, 0x00},
+        {0x17, 0x01, 0xa2, 0x00}, {0x28, 0x01, 0xa2, 0x01},
+        {0x02, 0x01, 0xb8, 0x00}, {0x09, 0x01, 0xb8, 0x00},
+        {0x17, 0x01, 0xb8, 0x00}, {0x28, 0x01, 0xb8, 0x01},
+        {0x02, 0x01, 0xc2, 0x00}, {0x09, 0x01, 0xc2, 0x00},
+        {0x17, 0x01, 0xc2, 0x00}, {0x28, 0x01, 0xc2, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x83, 0x00}, {0x06, 0x01, 0x83, 0x00},
+        {0x0a, 0x01, 0x83, 0x00}, {0x0f, 0x01, 0x83, 0x00},
+        {0x18, 0x01, 0x83, 0x00}, {0x1f, 0x01, 0x83, 0x00},
+        {0x29, 0x01, 0x83, 0x00}, {0x38, 0x01, 0x83, 0x01},
+        {0x03, 0x01, 0xa2, 0x00}, {0x06, 0x01, 0xa2, 0x00},
+        {0x0a, 0x01, 0xa2, 0x00}, {0x0f, 0x01, 0xa2, 0x00},
+        {0x18, 0x01, 0xa2, 0x00}, {0x1f, 0x01, 0xa2, 0x00},
+        {0x29, 0x01, 0xa2, 0x00}, {0x38, 0x01, 0xa2, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xb8, 0x00}, {0x06, 0x01, 0xb8, 0x00},
+        {0x0a, 0x01, 0xb8, 0x00}, {0x0f, 0x01, 0xb8, 0x00},
+        {0x18, 0x01, 0xb8, 0x00}, {0x1f, 0x01, 0xb8, 0x00},
+        {0x29, 0x01, 0xb8, 0x00}, {0x38, 0x01, 0xb8, 0x01},
+        {0x03, 0x01, 0xc2, 0x00}, {0x06, 0x01, 0xc2, 0x00},
+        {0x0a, 0x01, 0xc2, 0x00}, {0x0f, 0x01, 0xc2, 0x00},
+        {0x18, 0x01, 0xc2, 0x00}, {0x1f, 0x01, 0xc2, 0x00},
+        {0x29, 0x01, 0xc2, 0x00}, {0x38, 0x01, 0xc2, 0x01}
+    },
+    /* 105 */
+    {
+        {0x02, 0x01, 0xe0, 0x00}, {0x09, 0x01, 0xe0, 0x00},
+        {0x17, 0x01, 0xe0, 0x00}, {0x28, 0x01, 0xe0, 0x01},
+        {0x02, 0x01, 0xe2, 0x00}, {0x09, 0x01, 0xe2, 0x00},
+        {0x17, 0x01, 0xe2, 0x00}, {0x28, 0x01, 0xe2, 0x01},
+        {0x01, 0x01, 0x99, 0x00}, {0x16, 0x01, 0x99, 0x01},
+        {0x01, 0x01, 0xa1, 0x00}, {0x16, 0x01, 0xa1, 0x01},
+        {0x01, 0x01, 0xa7, 0x00}, {0x16, 0x01, 0xa7, 0x01},
+        {0x01, 0x01, 0xac, 0x00}, {0x16, 0x01, 0xac, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xe0, 0x00}, {0x06, 0x01, 0xe0, 0x00},
+        {0x0a, 0x01, 0xe0, 0x00}, {0x0f, 0x01, 0xe0, 0x00},
+        {0x18, 0x01, 0xe0, 0x00}, {0x1f, 0x01, 0xe0, 0x00},
+        {0x29, 0x01, 0xe0, 0x00}, {0x38, 0x01, 0xe0, 0x01},
+        {0x03, 0x01, 0xe2, 0x00}, {0x06, 0x01, 0xe2, 0x00},
+        {0x0a, 0x01, 0xe2, 0x00}, {0x0f, 0x01, 0xe2, 0x00},
+        {0x18, 0x01, 0xe2, 0x00}, {0x1f, 0x01, 0xe2, 0x00},
+        {0x29, 0x01, 0xe2, 0x00}, {0x38, 0x01, 0xe2, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x99, 0x00}, {0x09, 0x01, 0x99, 0x00},
+        {0x17, 0x01, 0x99, 0x00}, {0x28, 0x01, 0x99, 0x01},
+        {0x02, 0x01, 0xa1, 0x00}, {0x09, 0x01, 0xa1, 0x00},
+        {0x17, 0x01, 0xa1, 0x00}, {0x28, 0x01, 0xa1, 0x01},
+        {0x02, 0x01, 0xa7, 0x00}, {0x09, 0x01, 0xa7, 0x00},
+        {0x17, 0x01, 0xa7, 0x00}, {0x28, 0x01, 0xa7, 0x01},
+        {0x02, 0x01, 0xac, 0x00}, {0x09, 0x01, 0xac, 0x00},
+        {0x17, 0x01, 0xac, 0x00}, {0x28, 0x01, 0xac, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x99, 0x00}, {0x06, 0x01, 0x99, 0x00},
+        {0x0a, 0x01, 0x99, 0x00}, {0x0f, 0x01, 0x99, 0x00},
+        {0x18, 0x01, 0x99, 0x00}, {0x1f, 0x01, 0x99, 0x00},
+        {0x29, 0x01, 0x99, 0x00}, {0x38, 0x01, 0x99, 0x01},
+        {0x03, 0x01, 0xa1, 0x00}, {0x06, 0x01, 0xa1, 0x00},
+        {0x0a, 0x01, 0xa1, 0x00}, {0x0f, 0x01, 0xa1, 0x00},
+        {0x18, 0x01, 0xa1, 0x00}, {0x1f, 0x01, 0xa1, 0x00},
+        {0x29, 0x01, 0xa1, 0x00}, {0x38, 0x01, 0xa1, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xa7, 0x00}, {0x06, 0x01, 0xa7, 0x00},
+        {0x0a, 0x01, 0xa7, 0x00}, {0x0f, 0x01, 0xa7, 0x00},
+        {0x18, 0x01, 0xa7, 0x00}, {0x1f, 0x01, 0xa7, 0x00},
+        {0x29, 0x01, 0xa7, 0x00}, {0x38, 0x01, 0xa7, 0x01},
+        {0x03, 0x01, 0xac, 0x00}, {0x06, 0x01, 0xac, 0x00},
+        {0x0a, 0x01, 0xac, 0x00}, {0x0f, 0x01, 0xac, 0x00},
+        {0x18, 0x01, 0xac, 0x00}, {0x1f, 0x01, 0xac, 0x00},
+        {0x29, 0x01, 0xac, 0x00}, {0x38, 0x01, 0xac, 0x01}
+    },
+    /* 110 */
+    {
+        {0x72, 0x00, 0x00, 0x00}, {0x73, 0x00, 0x00, 0x00},
+        {0x75, 0x00, 0x00, 0x00}, {0x76, 0x00, 0x00, 0x00},
+        {0x79, 0x00, 0x00, 0x00}, {0x7b, 0x00, 0x00, 0x00},
+        {0x7f, 0x00, 0x00, 0x00}, {0x82, 0x00, 0x00, 0x00},
+        {0x88, 0x00, 0x00, 0x00}, {0x8b, 0x00, 0x00, 0x00},
+        {0x8f, 0x00, 0x00, 0x00}, {0x92, 0x00, 0x00, 0x00},
+        {0x9b, 0x00, 0x00, 0x00}, {0xa2, 0x00, 0x00, 0x00},
+        {0xaa, 0x00, 0x00, 0x00}, {0xb4, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xb0, 0x01}, {0x00, 0x01, 0xb1, 0x01},
+        {0x00, 0x01, 0xb3, 0x01}, {0x00, 0x01, 0xd1, 0x01},
+        {0x00, 0x01, 0xd8, 0x01}, {0x00, 0x01, 0xd9, 0x01},
+        {0x00, 0x01, 0xe3, 0x01}, {0x00, 0x01, 0xe5, 0x01},
+        {0x00, 0x01, 0xe6, 0x01}, {0x7a, 0x00, 0x00, 0x00},
+        {0x7c, 0x00, 0x00, 0x00}, {0x7d, 0x00, 0x00, 0x00},
+        {0x80, 0x00, 0x00, 0x00}, {0x81, 0x00, 0x00, 0x00},
+        {0x83, 0x00, 0x00, 0x00}, {0x84, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x01, 0x01, 0xb0, 0x00}, {0x16, 0x01, 0xb0, 0x01},
+        {0x01, 0x01, 0xb1, 0x00}, {0x16, 0x01, 0xb1, 0x01},
+        {0x01, 0x01, 0xb3, 0x00}, {0x16, 0x01, 0xb3, 0x01},
+        {0x01, 0x01, 0xd1, 0x00}, {0x16, 0x01, 0xd1, 0x01},
+        {0x01, 0x01, 0xd8, 0x00}, {0x16, 0x01, 0xd8, 0x01},
+        {0x01, 0x01, 0xd9, 0x00}, {0x16, 0x01, 0xd9, 0x01},
+        {0x01, 0x01, 0xe3, 0x00}, {0x16, 0x01, 0xe3, 0x01},
+        {0x01, 0x01, 0xe5, 0x00}, {0x16, 0x01, 0xe5, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xb0, 0x00}, {0x09, 0x01, 0xb0, 0x00},
+        {0x17, 0x01, 0xb0, 0x00}, {0x28, 0x01, 0xb0, 0x01},
+        {0x02, 0x01, 0xb1, 0x00}, {0x09, 0x01, 0xb1, 0x00},
+        {0x17, 0x01, 0xb1, 0x00}, {0x28, 0x01, 0xb1, 0x01},
+        {0x02, 0x01, 0xb3, 0x00}, {0x09, 0x01, 0xb3, 0x00},
+        {0x17, 0x01, 0xb3, 0x00}, {0x28, 0x01, 0xb3, 0x01},
+        {0x02, 0x01, 0xd1, 0x00}, {0x09, 0x01, 0xd1, 0x00},
+        {0x17, 0x01, 0xd1, 0x00}, {0x28, 0x01, 0xd1, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xb0, 0x00}, {0x06, 0x01, 0xb0, 0x00},
+        {0x0a, 0x01, 0xb0, 0x00}, {0x0f, 0x01, 0xb0, 0x00},
+        {0x18, 0x01, 0xb0, 0x00}, {0x1f, 0x01, 0xb0, 0x00},
+        {0x29, 0x01, 0xb0, 0x00}, {0x38, 0x01, 0xb0, 0x01},
+        {0x03, 0x01, 0xb1, 0x00}, {0x06, 0x01, 0xb1, 0x00},
+        {0x0a, 0x01, 0xb1, 0x00}, {0x0f, 0x01, 0xb1, 0x00},
+        {0x18, 0x01, 0xb1, 0x00}, {0x1f, 0x01, 0xb1, 0x00},
+        {0x29, 0x01, 0xb1, 0x00}, {0x38, 0x01, 0xb1, 0x01}
+    },
+    /* 115 */
+    {
+        {0x03, 0x01, 0xb3, 0x00}, {0x06, 0x01, 0xb3, 0x00},
+        {0x0a, 0x01, 0xb3, 0x00}, {0x0f, 0x01, 0xb3, 0x00},
+        {0x18, 0x01, 0xb3, 0x00}, {0x1f, 0x01, 0xb3, 0x00},
+        {0x29, 0x01, 0xb3, 0x00}, {0x38, 0x01, 0xb3, 0x01},
+        {0x03, 0x01, 0xd1, 0x00}, {0x06, 0x01, 0xd1, 0x00},
+        {0x0a, 0x01, 0xd1, 0x00}, {0x0f, 0x01, 0xd1, 0x00},
+        {0x18, 0x01, 0xd1, 0x00}, {0x1f, 0x01, 0xd1, 0x00},
+        {0x29, 0x01, 0xd1, 0x00}, {0x38, 0x01, 0xd1, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xd8, 0x00}, {0x09, 0x01, 0xd8, 0x00},
+        {0x17, 0x01, 0xd8, 0x00}, {0x28, 0x01, 0xd8, 0x01},
+        {0x02, 0x01, 0xd9, 0x00}, {0x09, 0x01, 0xd9, 0x00},
+        {0x17, 0x01, 0xd9, 0x00}, {0x28, 0x01, 0xd9, 0x01},
+        {0x02, 0x01, 0xe3, 0x00}, {0x09, 0x01, 0xe3, 0x00},
+        {0x17, 0x01, 0xe3, 0x00}, {0x28, 0x01, 0xe3, 0x01},
+        {0x02, 0x01, 0xe5, 0x00}, {0x09, 0x01, 0xe5, 0x00},
+        {0x17, 0x01, 0xe5, 0x00}, {0x28, 0x01, 0xe5, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd8, 0x00}, {0x06, 0x01, 0xd8, 0x00},
+        {0x0a, 0x01, 0xd8, 0x00}, {0x0f, 0x01, 0xd8, 0x00},
+        {0x18, 0x01, 0xd8, 0x00}, {0x1f, 0x01, 0xd8, 0x00},
+        {0x29, 0x01, 0xd8, 0x00}, {0x38, 0x01, 0xd8, 0x01},
+        {0x03, 0x01, 0xd9, 0x00}, {0x06, 0x01, 0xd9, 0x00},
+        {0x0a, 0x01, 0xd9, 0x00}, {0x0f, 0x01, 0xd9, 0x00},
+        {0x18, 0x01, 0xd9, 0x00}, {0x1f, 0x01, 0xd9, 0x00},
+        {0x29, 0x01, 0xd9, 0x00}, {0x38, 0x01, 0xd9, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xe3, 0x00}, {0x06, 0x01, 0xe3, 0x00},
+        {0x0a, 0x01, 0xe3, 0x00}, {0x0f, 0x01, 0xe3, 0x00},
+        {0x18, 0x01, 0xe3, 0x00}, {0x1f, 0x01, 0xe3, 0x00},
+        {0x29, 0x01, 0xe3, 0x00}, {0x38, 0x01, 0xe3, 0x01},
+        {0x03, 0x01, 0xe5, 0x00}, {0x06, 0x01, 0xe5, 0x00},
+        {0x0a, 0x01, 0xe5, 0x00}, {0x0f, 0x01, 0xe5, 0x00},
+        {0x18, 0x01, 0xe5, 0x00}, {0x1f, 0x01, 0xe5, 0x00},
+        {0x29, 0x01, 0xe5, 0x00}, {0x38, 0x01, 0xe5, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xe6, 0x00}, {0x16, 0x01, 0xe6, 0x01},
+        {0x00, 0x01, 0x81, 0x01}, {0x00, 0x01, 0x84, 0x01},
+        {0x00, 0x01, 0x85, 0x01}, {0x00, 0x01, 0x86, 0x01},
+        {0x00, 0x01, 0x88, 0x01}, {0x00, 0x01, 0x92, 0x01},
+        {0x00, 0x01, 0x9a, 0x01}, {0x00, 0x01, 0x9c, 0x01},
+        {0x00, 0x01, 0xa0, 0x01}, {0x00, 0x01, 0xa3, 0x01},
+        {0x00, 0x01, 0xa4, 0x01}, {0x00, 0x01, 0xa9, 0x01},
+        {0x00, 0x01, 0xaa, 0x01}, {0x00, 0x01, 0xad, 0x01}
+    },
+    /* 120 */
+    {
+        {0x02, 0x01, 0xe6, 0x00}, {0x09, 0x01, 0xe6, 0x00},
+        {0x17, 0x01, 0xe6, 0x00}, {0x28, 0x01, 0xe6, 0x01},
+        {0x01, 0x01, 0x81, 0x00}, {0x16, 0x01, 0x81, 0x01},
+        {0x01, 0x01, 0x84, 0x00}, {0x16, 0x01, 0x84, 0x01},
+        {0x01, 0x01, 0x85, 0x00}, {0x16, 0x01, 0x85, 0x01},
+        {0x01, 0x01, 0x86, 0x00}, {0x16, 0x01, 0x86, 0x01},
+        {0x01, 0x01, 0x88, 0x00}, {0x16, 0x01, 0x88, 0x01},
+        {0x01, 0x01, 0x92, 0x00}, {0x16, 0x01, 0x92, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xe6, 0x00}, {0x06, 0x01, 0xe6, 0x00},
+        {0x0a, 0x01, 0xe6, 0x00}, {0x0f, 0x01, 0xe6, 0x00},
+        {0x18, 0x01, 0xe6, 0x00}, {0x1f, 0x01, 0xe6, 0x00},
+        {0x29, 0x01, 0xe6, 0x00}, {0x38, 0x01, 0xe6, 0x01},
+        {0x02, 0x01, 0x81, 0x00}, {0x09, 0x01, 0x81, 0x00},
+        {0x17, 0x01, 0x81, 0x00}, {0x28, 0x01, 0x81, 0x01},
+        {0x02, 0x01, 0x84, 0x00}, {0x09, 0x01, 0x84, 0x00},
+        {0x17, 0x01, 0x84, 0x00}, {0x28, 0x01, 0x84, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x81, 0x00}, {0x06, 0x01, 0x81, 0x00},
+        {0x0a, 0x01, 0x81, 0x00}, {0x0f, 0x01, 0x81, 0x00},
+        {0x18, 0x01, 0x81, 0x00}, {0x1f, 0x01, 0x81, 0x00},
+        {0x29, 0x01, 0x81, 0x00}, {0x38, 0x01, 0x81, 0x01},
+        {0x03, 0x01, 0x84, 0x00}, {0x06, 0x01, 0x84, 0x00},
+        {0x0a, 0x01, 0x84, 0x00}, {0x0f, 0x01, 0x84, 0x00},
+        {0x18, 0x01, 0x84, 0x00}, {0x1f, 0x01, 0x84, 0x00},
+        {0x29, 0x01, 0x84, 0x00}, {0x38, 0x01, 0x84, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x85, 0x00}, {0x09, 0x01, 0x85, 0x00},
+        {0x17, 0x01, 0x85, 0x00}, {0x28, 0x01, 0x85, 0x01},
+        {0x02, 0x01, 0x86, 0x00}, {0x09, 0x01, 0x86, 0x00},
+        {0x17, 0x01, 0x86, 0x00}, {0x28, 0x01, 0x86, 0x01},
+        {0x02, 0x01, 0x88, 0x00}, {0x09, 0x01, 0x88, 0x00},
+        {0x17, 0x01, 0x88, 0x00}, {0x28, 0x01, 0x88, 0x01},
+        {0x02, 0x01, 0x92, 0x00}, {0x09, 0x01, 0x92, 0x00},
+        {0x17, 0x01, 0x92, 0x00}, {0x28, 0x01, 0x92, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x85, 0x00}, {0x06, 0x01, 0x85, 0x00},
+        {0x0a, 0x01, 0x85, 0x00}, {0x0f, 0x01, 0x85, 0x00},
+        {0x18, 0x01, 0x85, 0x00}, {0x1f, 0x01, 0x85, 0x00},
+        {0x29, 0x01, 0x85, 0x00}, {0x38, 0x01, 0x85, 0x01},
+        {0x03, 0x01, 0x86, 0x00}, {0x06, 0x01, 0x86, 0x00},
+        {0x0a, 0x01, 0x86, 0x00}, {0x0f, 0x01, 0x86, 0x00},
+        {0x18, 0x01, 0x86, 0x00}, {0x1f, 0x01, 0x86, 0x00},
+        {0x29, 0x01, 0x86, 0x00}, {0x38, 0x01, 0x86, 0x01}
+    },
+    /* 125 */
+    {
+        {0x03, 0x01, 0x88, 0x00}, {0x06, 0x01, 0x88, 0x00},
+        {0x0a, 0x01, 0x88, 0x00}, {0x0f, 0x01, 0x88, 0x00},
+        {0x18, 0x01, 0x88, 0x00}, {0x1f, 0x01, 0x88, 0x00},
+        {0x29, 0x01, 0x88, 0x00}, {0x38, 0x01, 0x88, 0x01},
+        {0x03, 0x01, 0x92, 0x00}, {0x06, 0x01, 0x92, 0x00},
+        {0x0a, 0x01, 0x92, 0x00}, {0x0f, 0x01, 0x92, 0x00},
+        {0x18, 0x01, 0x92, 0x00}, {0x1f, 0x01, 0x92, 0x00},
+        {0x29, 0x01, 0x92, 0x00}, {0x38, 0x01, 0x92, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x9a, 0x00}, {0x16, 0x01, 0x9a, 0x01},
+        {0x01, 0x01, 0x9c, 0x00}, {0x16, 0x01, 0x9c, 0x01},
+        {0x01, 0x01, 0xa0, 0x00}, {0x16, 0x01, 0xa0, 0x01},
+        {0x01, 0x01, 0xa3, 0x00}, {0x16, 0x01, 0xa3, 0x01},
+        {0x01, 0x01, 0xa4, 0x00}, {0x16, 0x01, 0xa4, 0x01},
+        {0x01, 0x01, 0xa9, 0x00}, {0x16, 0x01, 0xa9, 0x01},
+        {0x01, 0x01, 0xaa, 0x00}, {0x16, 0x01, 0xaa, 0x01},
+        {0x01, 0x01, 0xad, 0x00}, {0x16, 0x01, 0xad, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x9a, 0x00}, {0x09, 0x01, 0x9a, 0x00},
+        {0x17, 0x01, 0x9a, 0x00}, {0x28, 0x01, 0x9a, 0x01},
+        {0x02, 0x01, 0x9c, 0x00}, {0x09, 0x01, 0x9c, 0x00},
+        {0x17, 0x01, 0x9c, 0x00}, {0x28, 0x01, 0x9c, 0x01},
+        {0x02, 0x01, 0xa0, 0x00}, {0x09, 0x01, 0xa0, 0x00},
+        {0x17, 0x01, 0xa0, 0x00}, {0x28, 0x01, 0xa0, 0x01},
+        {0x02, 0x01, 0xa3, 0x00}, {0x09, 0x01, 0xa3, 0x00},
+        {0x17, 0x01, 0xa3, 0x00}, {0x28, 0x01, 0xa3, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x9a, 0x00}, {0x06, 0x01, 0x9a, 0x00},
+        {0x0a, 0x01, 0x9a, 0x00}, {0x0f, 0x01, 0x9a, 0x00},
+        {0x18, 0x01, 0x9a, 0x00}, {0x1f, 0x01, 0x9a, 0x00},
+        {0x29, 0x01, 0x9a, 0x00}, {0x38, 0x01, 0x9a, 0x01},
+        {0x03, 0x01, 0x9c, 0x00}, {0x06, 0x01, 0x9c, 0x00},
+        {0x0a, 0x01, 0x9c, 0x00}, {0x0f, 0x01, 0x9c, 0x00},
+        {0x18, 0x01, 0x9c, 0x00}, {0x1f, 0x01, 0x9c, 0x00},
+        {0x29, 0x01, 0x9c, 0x00}, {0x38, 0x01, 0x9c, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xa0, 0x00}, {0x06, 0x01, 0xa0, 0x00},
+        {0x0a, 0x01, 0xa0, 0x00}, {0x0f, 0x01, 0xa0, 0x00},
+        {0x18, 0x01, 0xa0, 0x00}, {0x1f, 0x01, 0xa0, 0x00},
+        {0x29, 0x01, 0xa0, 0x00}, {0x38, 0x01, 0xa0, 0x01},
+        {0x03, 0x01, 0xa3, 0x00}, {0x06, 0x01, 0xa3, 0x00},
+        {0x0a, 0x01, 0xa3, 0x00}, {0x0f, 0x01, 0xa3, 0x00},
+        {0x18, 0x01, 0xa3, 0x00}, {0x1f, 0x01, 0xa3, 0x00},
+        {0x29, 0x01, 0xa3, 0x00}, {0x38, 0x01, 0xa3, 0x01}
+    },
+    /* 130 */
+    {
+        {0x02, 0x01, 0xa4, 0x00}, {0x09, 0x01, 0xa4, 0x00},
+        {0x17, 0x01, 0xa4, 0x00}, {0x28, 0x01, 0xa4, 0x01},
+        {0x02, 0x01, 0xa9, 0x00}, {0x09, 0x01, 0xa9, 0x00},
+        {0x17, 0x01, 0xa9, 0x00}, {0x28, 0x01, 0xa9, 0x01},
+        {0x02, 0x01, 0xaa, 0x00}, {0x09, 0x01, 0xaa, 0x00},
+        {0x17, 0x01, 0xaa, 0x00}, {0x28, 0x01, 0xaa, 0x01},
+        {0x02, 0x01, 0xad, 0x00}, {0x09, 0x01, 0xad, 0x00},
+        {0x17, 0x01, 0xad, 0x00}, {0x28, 0x01, 0xad, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xa4, 0x00}, {0x06, 0x01, 0xa4, 0x00},
+        {0x0a, 0x01, 0xa4, 0x00}, {0x0f, 0x01, 0xa4, 0x00},
+        {0x18, 0x01, 0xa4, 0x00}, {0x1f, 0x01, 0xa4, 0x00},
+        {0x29, 0x01, 0xa4, 0x00}, {0x38, 0x01, 0xa4, 0x01},
+        {0x03, 0x01, 0xa9, 0x00}, {0x06, 0x01, 0xa9, 0x00},
+        {0x0a, 0x01, 0xa9, 0x00}, {0x0f, 0x01, 0xa9, 0x00},
+        {0x18, 0x01, 0xa9, 0x00}, {0x1f, 0x01, 0xa9, 0x00},
+        {0x29, 0x01, 0xa9, 0x00}, {0x38, 0x01, 0xa9, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xaa, 0x00}, {0x06, 0x01, 0xaa, 0x00},
+        {0x0a, 0x01, 0xaa, 0x00}, {0x0f, 0x01, 0xaa, 0x00},
+        {0x18, 0x01, 0xaa, 0x00}, {0x1f, 0x01, 0xaa, 0x00},
+        {0x29, 0x01, 0xaa, 0x00}, {0x38, 0x01, 0xaa, 0x01},
+        {0x03, 0x01, 0xad, 0x00}, {0x06, 0x01, 0xad, 0x00},
+        {0x0a, 0x01, 0xad, 0x00}, {0x0f, 0x01, 0xad, 0x00},
+        {0x18, 0x01, 0xad, 0x00}, {0x1f, 0x01, 0xad, 0x00},
+        {0x29, 0x01, 0xad, 0x00}, {0x38, 0x01, 0xad, 0x01}
+    },
+    {
+        {0x89, 0x00, 0x00, 0x00}, {0x8a, 0x00, 0x00, 0x00},
+        {0x8c, 0x00, 0x00, 0x00}, {0x8d, 0x00, 0x00, 0x00},
+        {0x90, 0x00, 0x00, 0x00}, {0x91, 0x00, 0x00, 0x00},
+        {0x93, 0x00, 0x00, 0x00}, {0x96, 0x00, 0x00, 0x00},
+        {0x9c, 0x00, 0x00, 0x00}, {0x9f, 0x00, 0x00, 0x00},
+        {0xa3, 0x00, 0x00, 0x00}, {0xa6, 0x00, 0x00, 0x00},
+        {0xab, 0x00, 0x00, 0x00}, {0xae, 0x00, 0x00, 0x00},
+        {0xb5, 0x00, 0x00, 0x00}, {0xbe, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xb2, 0x01}, {0x00, 0x01, 0xb5, 0x01},
+        {0x00, 0x01, 0xb9, 0x01}, {0x00, 0x01, 0xba, 0x01},
+        {0x00, 0x01, 0xbb, 0x01}, {0x00, 0x01, 0xbd, 0x01},
+        {0x00, 0x01, 0xbe, 0x01}, {0x00, 0x01, 0xc4, 0x01},
+        {0x00, 0x01, 0xc6, 0x01}, {0x00, 0x01, 0xe4, 0x01},
+        {0x00, 0x01, 0xe8, 0x01}, {0x00, 0x01, 0xe9, 0x01},
+        {0x94, 0x00, 0x00, 0x00}, {0x95, 0x00, 0x00, 0x00},
+        {0x97, 0x00, 0x00, 0x00}, {0x98, 0x00, 0x00, 0x00}
+    },
+    /* 135 */
+    {
+        {0x01, 0x01, 0xb2, 0x00}, {0x16, 0x01, 0xb2, 0x01},
+        {0x01, 0x01, 0xb5, 0x00}, {0x16, 0x01, 0xb5, 0x01},
+        {0x01, 0x01, 0xb9, 0x00}, {0x16, 0x01, 0xb9, 0x01},
+        {0x01, 0x01, 0xba, 0x00}, {0x16, 0x01, 0xba, 0x01},
+        {0x01, 0x01, 0xbb, 0x00}, {0x16, 0x01, 0xbb, 0x01},
+        {0x01, 0x01, 0xbd, 0x00}, {0x16, 0x01, 0xbd, 0x01},
+        {0x01, 0x01, 0xbe, 0x00}, {0x16, 0x01, 0xbe, 0x01},
+        {0x01, 0x01, 0xc4, 0x00}, {0x16, 0x01, 0xc4, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xb2, 0x00}, {0x09, 0x01, 0xb2, 0x00},
+        {0x17, 0x01, 0xb2, 0x00}, {0x28, 0x01, 0xb2, 0x01},
+        {0x02, 0x01, 0xb5, 0x00}, {0x09, 0x01, 0xb5, 0x00},
+        {0x17, 0x01, 0xb5, 0x00}, {0x28, 0x01, 0xb5, 0x01},
+        {0x02, 0x01, 0xb9, 0x00}, {0x09, 0x01, 0xb9, 0x00},
+        {0x17, 0x01, 0xb9, 0x00}, {0x28, 0x01, 0xb9, 0x01},
+        {0x02, 0x01, 0xba, 0x00}, {0x09, 0x01, 0xba, 0x00},
+        {0x17, 0x01, 0xba, 0x00}, {0x28, 0x01, 0xba, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xb2, 0x00}, {0x06, 0x01, 0xb2, 0x00},
+        {0x0a, 0x01, 0xb2, 0x00}, {0x0f, 0x01, 0xb2, 0x00},
+        {0x18, 0x01, 0xb2, 0x00}, {0x1f, 0x01, 0xb2, 0x00},
+        {0x29, 0x01, 0xb2, 0x00}, {0x38, 0x01, 0xb2, 0x01},
+        {0x03, 0x01, 0xb5, 0x00}, {0x06, 0x01, 0xb5, 0x00},
+        {0x0a, 0x01, 0xb5, 0x00}, {0x0f, 0x01, 0xb5, 0x00},
+        {0x18, 0x01, 0xb5, 0x00}, {0x1f, 0x01, 0xb5, 0x00},
+        {0x29, 0x01, 0xb5, 0x00}, {0x38, 0x01, 0xb5, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xb9, 0x00}, {0x06, 0x01, 0xb9, 0x00},
+        {0x0a, 0x01, 0xb9, 0x00}, {0x0f, 0x01, 0xb9, 0x00},
+        {0x18, 0x01, 0xb9, 0x00}, {0x1f, 0x01, 0xb9, 0x00},
+        {0x29, 0x01, 0xb9, 0x00}, {0x38, 0x01, 0xb9, 0x01},
+        {0x03, 0x01, 0xba, 0x00}, {0x06, 0x01, 0xba, 0x00},
+        {0x0a, 0x01, 0xba, 0x00}, {0x0f, 0x01, 0xba, 0x00},
+        {0x18, 0x01, 0xba, 0x00}, {0x1f, 0x01, 0xba, 0x00},
+        {0x29, 0x01, 0xba, 0x00}, {0x38, 0x01, 0xba, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xbb, 0x00}, {0x09, 0x01, 0xbb, 0x00},
+        {0x17, 0x01, 0xbb, 0x00}, {0x28, 0x01, 0xbb, 0x01},
+        {0x02, 0x01, 0xbd, 0x00}, {0x09, 0x01, 0xbd, 0x00},
+        {0x17, 0x01, 0xbd, 0x00}, {0x28, 0x01, 0xbd, 0x01},
+        {0x02, 0x01, 0xbe, 0x00}, {0x09, 0x01, 0xbe, 0x00},
+        {0x17, 0x01, 0xbe, 0x00}, {0x28, 0x01, 0xbe, 0x01},
+        {0x02, 0x01, 0xc4, 0x00}, {0x09, 0x01, 0xc4, 0x00},
+        {0x17, 0x01, 0xc4, 0x00}, {0x28, 0x01, 0xc4, 0x01}
+    },
+    /* 140 */
+    {
+        {0x03, 0x01, 0xbb, 0x00}, {0x06, 0x01, 0xbb, 0x00},
+        {0x0a, 0x01, 0xbb, 0x00}, {0x0f, 0x01, 0xbb, 0x00},
+        {0x18, 0x01, 0xbb, 0x00}, {0x1f, 0x01, 0xbb, 0x00},
+        {0x29, 0x01, 0xbb, 0x00}, {0x38, 0x01, 0xbb, 0x01},
+        {0x03, 0x01, 0xbd, 0x00}, {0x06, 0x01, 0xbd, 0x00},
+        {0x0a, 0x01, 0xbd, 0x00}, {0x0f, 0x01, 0xbd, 0x00},
+        {0x18, 0x01, 0xbd, 0x00}, {0x1f, 0x01, 0xbd, 0x00},
+        {0x29, 0x01, 0xbd, 0x00}, {0x38, 0x01, 0xbd, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xbe, 0x00}, {0x06, 0x01, 0xbe, 0x00},
+        {0x0a, 0x01, 0xbe, 0x00}, {0x0f, 0x01, 0xbe, 0x00},
+        {0x18, 0x01, 0xbe, 0x00}, {0x1f, 0x01, 0xbe, 0x00},
+        {0x29, 0x01, 0xbe, 0x00}, {0x38, 0x01, 0xbe, 0x01},
+        {0x03, 0x01, 0xc4, 0x00}, {0x06, 0x01, 0xc4, 0x00},
+        {0x0a, 0x01, 0xc4, 0x00}, {0x0f, 0x01, 0xc4, 0x00},
+        {0x18, 0x01, 0xc4, 0x00}, {0x1f, 0x01, 0xc4, 0x00},
+        {0x29, 0x01, 0xc4, 0x00}, {0x38, 0x01, 0xc4, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xc6, 0x00}, {0x16, 0x01, 0xc6, 0x01},
+        {0x01, 0x01, 0xe4, 0x00}, {0x16, 0x01, 0xe4, 0x01},
+        {0x01, 0x01, 0xe8, 0x00}, {0x16, 0x01, 0xe8, 0x01},
+        {0x01, 0x01, 0xe9, 0x00}, {0x16, 0x01, 0xe9, 0x01},
+        {0x00, 0x01, 0x01, 0x01}, {0x00, 0x01, 0x87, 0x01},
+        {0x00, 0x01, 0x89, 0x01}, {0x00, 0x01, 0x8a, 0x01},
+        {0x00, 0x01, 0x8b, 0x01}, {0x00, 0x01, 0x8c, 0x01},
+        {0x00, 0x01, 0x8d, 0x01}, {0x00, 0x01, 0x8f, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xc6, 0x00}, {0x09, 0x01, 0xc6, 0x00},
+        {0x17, 0x01, 0xc6, 0x00}, {0x28, 0x01, 0xc6, 0x01},
+        {0x02, 0x01, 0xe4, 0x00}, {0x09, 0x01, 0xe4, 0x00},
+        {0x17, 0x01, 0xe4, 0x00}, {0x28, 0x01, 0xe4, 0x01},
+        {0x02, 0x01, 0xe8, 0x00}, {0x09, 0x01, 0xe8, 0x00},
+        {0x17, 0x01, 0xe8, 0x00}, {0x28, 0x01, 0xe8, 0x01},
+        {0x02, 0x01, 0xe9, 0x00}, {0x09, 0x01, 0xe9, 0x00},
+        {0x17, 0x01, 0xe9, 0x00}, {0x28, 0x01, 0xe9, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xc6, 0x00}, {0x06, 0x01, 0xc6, 0x00},
+        {0x0a, 0x01, 0xc6, 0x00}, {0x0f, 0x01, 0xc6, 0x00},
+        {0x18, 0x01, 0xc6, 0x00}, {0x1f, 0x01, 0xc6, 0x00},
+        {0x29, 0x01, 0xc6, 0x00}, {0x38, 0x01, 0xc6, 0x01},
+        {0x03, 0x01, 0xe4, 0x00}, {0x06, 0x01, 0xe4, 0x00},
+        {0x0a, 0x01, 0xe4, 0x00}, {0x0f, 0x01, 0xe4, 0x00},
+        {0x18, 0x01, 0xe4, 0x00}, {0x1f, 0x01, 0xe4, 0x00},
+        {0x29, 0x01, 0xe4, 0x00}, {0x38, 0x01, 0xe4, 0x01}
+    },
+    /* 145 */
+    {
+        {0x03, 0x01, 0xe8, 0x00}, {0x06, 0x01, 0xe8, 0x00},
+        {0x0a, 0x01, 0xe8, 0x00}, {0x0f, 0x01, 0xe8, 0x00},
+        {0x18, 0x01, 0xe8, 0x00}, {0x1f, 0x01, 0xe8, 0x00},
+        {0x29, 0x01, 0xe8, 0x00}, {0x38, 0x01, 0xe8, 0x01},
+        {0x03, 0x01, 0xe9, 0x00}, {0x06, 0x01, 0xe9, 0x00},
+        {0x0a, 0x01, 0xe9, 0x00}, {0x0f, 0x01, 0xe9, 0x00},
+        {0x18, 0x01, 0xe9, 0x00}, {0x1f, 0x01, 0xe9, 0x00},
+        {0x29, 0x01, 0xe9, 0x00}, {0x38, 0x01, 0xe9, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x01, 0x00}, {0x16, 0x01, 0x01, 0x01},
+        {0x01, 0x01, 0x87, 0x00}, {0x16, 0x01, 0x87, 0x01},
+        {0x01, 0x01, 0x89, 0x00}, {0x16, 0x01, 0x89, 0x01},
+        {0x01, 0x01, 0x8a, 0x00}, {0x16, 0x01, 0x8a, 0x01},
+        {0x01, 0x01, 0x8b, 0x00}, {0x16, 0x01, 0x8b, 0x01},
+        {0x01, 0x01, 0x8c, 0x00}, {0x16, 0x01, 0x8c, 0x01},
+        {0x01, 0x01, 0x8d, 0x00}, {0x16, 0x01, 0x8d, 0x01},
+        {0x01, 0x01, 0x8f, 0x00}, {0x16, 0x01, 0x8f, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x01, 0x00}, {0x09, 0x01, 0x01, 0x00},
+        {0x17, 0x01, 0x01, 0x00}, {0x28, 0x01, 0x01, 0x01},
+        {0x02, 0x01, 0x87, 0x00}, {0x09, 0x01, 0x87, 0x00},
+        {0x17, 0x01, 0x87, 0x00}, {0x28, 0x01, 0x87, 0x01},
+        {0x02, 0x01, 0x89, 0x00}, {0x09, 0x01, 0x89, 0x00},
+        {0x17, 0x01, 0x89, 0x00}, {0x28, 0x01, 0x89, 0x01},
+        {0x02, 0x01, 0x8a, 0x00}, {0x09, 0x01, 0x8a, 0x00},
+        {0x17, 0x01, 0x8a, 0x00}, {0x28, 0x01, 0x8a, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x01, 0x00}, {0x06, 0x01, 0x01, 0x00},
+        {0x0a, 0x01, 0x01, 0x00}, {0x0f, 0x01, 0x01, 0x00},
+        {0x18, 0x01, 0x01, 0x00}, {0x1f, 0x01, 0x01, 0x00},
+        {0x29, 0x01, 0x01, 0x00}, {0x38, 0x01, 0x01, 0x01},
+        {0x03, 0x01, 0x87, 0x00}, {0x06, 0x01, 0x87, 0x00},
+        {0x0a, 0x01, 0x87, 0x00}, {0x0f, 0x01, 0x87, 0x00},
+        {0x18, 0x01, 0x87, 0x00}, {0x1f, 0x01, 0x87, 0x00},
+        {0x29, 0x01, 0x87, 0x00}, {0x38, 0x01, 0x87, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x89, 0x00}, {0x06, 0x01, 0x89, 0x00},
+        {0x0a, 0x01, 0x89, 0x00}, {0x0f, 0x01, 0x89, 0x00},
+        {0x18, 0x01, 0x89, 0x00}, {0x1f, 0x01, 0x89, 0x00},
+        {0x29, 0x01, 0x89, 0x00}, {0x38, 0x01, 0x89, 0x01},
+        {0x03, 0x01, 0x8a, 0x00}, {0x06, 0x01, 0x8a, 0x00},
+        {0x0a, 0x01, 0x8a, 0x00}, {0x0f, 0x01, 0x8a, 0x00},
+        {0x18, 0x01, 0x8a, 0x00}, {0x1f, 0x01, 0x8a, 0x00},
+        {0x29, 0x01, 0x8a, 0x00}, {0x38, 0x01, 0x8a, 0x01}
+    },
+    /* 150 */
+    {
+        {0x02, 0x01, 0x8b, 0x00}, {0x09, 0x01, 0x8b, 0x00},
+        {0x17, 0x01, 0x8b, 0x00}, {0x28, 0x01, 0x8b, 0x01},
+        {0x02, 0x01, 0x8c, 0x00}, {0x09, 0x01, 0x8c, 0x00},
+        {0x17, 0x01, 0x8c, 0x00}, {0x28, 0x01, 0x8c, 0x01},
+        {0x02, 0x01, 0x8d, 0x00}, {0x09, 0x01, 0x8d, 0x00},
+        {0x17, 0x01, 0x8d, 0x00}, {0x28, 0x01, 0x8d, 0x01},
+        {0x02, 0x01, 0x8f, 0x00}, {0x09, 0x01, 0x8f, 0x00},
+        {0x17, 0x01, 0x8f, 0x00}, {0x28, 0x01, 0x8f, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x8b, 0x00}, {0x06, 0x01, 0x8b, 0x00},
+        {0x0a, 0x01, 0x8b, 0x00}, {0x0f, 0x01, 0x8b, 0x00},
+        {0x18, 0x01, 0x8b, 0x00}, {0x1f, 0x01, 0x8b, 0x00},
+        {0x29, 0x01, 0x8b, 0x00}, {0x38, 0x01, 0x8b, 0x01},
+        {0x03, 0x01, 0x8c, 0x00}, {0x06, 0x01, 0x8c, 0x00},
+        {0x0a, 0x01, 0x8c, 0x00}, {0x0f, 0x01, 0x8c, 0x00},
+        {0x18, 0x01, 0x8c, 0x00}, {0x1f, 0x01, 0x8c, 0x00},
+        {0x29, 0x01, 0x8c, 0x00}, {0x38, 0x01, 0x8c, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x8d, 0x00}, {0x06, 0x01, 0x8d, 0x00},
+        {0x0a, 0x01, 0x8d, 0x00}, {0x0f, 0x01, 0x8d, 0x00},
+        {0x18, 0x01, 0x8d, 0x00}, {0x1f, 0x01, 0x8d, 0x00},
+        {0x29, 0x01, 0x8d, 0x00}, {0x38, 0x01, 0x8d, 0x01},
+        {0x03, 0x01, 0x8f, 0x00}, {0x06, 0x01, 0x8f, 0x00},
+        {0x0a, 0x01, 0x8f, 0x00}, {0x0f, 0x01, 0x8f, 0x00},
+        {0x18, 0x01, 0x8f, 0x00}, {0x1f, 0x01, 0x8f, 0x00},
+        {0x29, 0x01, 0x8f, 0x00}, {0x38, 0x01, 0x8f, 0x01}
+    },
+    {
+        {0x9d, 0x00, 0x00, 0x00}, {0x9e, 0x00, 0x00, 0x00},
+        {0xa0, 0x00, 0x00, 0x00}, {0xa1, 0x00, 0x00, 0x00},
+        {0xa4, 0x00, 0x00, 0x00}, {0xa5, 0x00, 0x00, 0x00},
+        {0xa7, 0x00, 0x00, 0x00}, {0xa8, 0x00, 0x00, 0x00},
+        {0xac, 0x00, 0x00, 0x00}, {0xad, 0x00, 0x00, 0x00},
+        {0xaf, 0x00, 0x00, 0x00}, {0xb1, 0x00, 0x00, 0x00},
+        {0xb6, 0x00, 0x00, 0x00}, {0xb9, 0x00, 0x00, 0x00},
+        {0xbf, 0x00, 0x00, 0x00}, {0xcf, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x93, 0x01}, {0x00, 0x01, 0x95, 0x01},
+        {0x00, 0x01, 0x96, 0x01}, {0x00, 0x01, 0x97, 0x01},
+        {0x00, 0x01, 0x98, 0x01}, {0x00, 0x01, 0x9b, 0x01},
+        {0x00, 0x01, 0x9d, 0x01}, {0x00, 0x01, 0x9e, 0x01},
+        {0x00, 0x01, 0xa5, 0x01}, {0x00, 0x01, 0xa6, 0x01},
+        {0x00, 0x01, 0xa8, 0x01}, {0x00, 0x01, 0xae, 0x01},
+        {0x00, 0x01, 0xaf, 0x01}, {0x00, 0x01, 0xb4, 0x01},
+        {0x00, 0x01, 0xb6, 0x01}, {0x00, 0x01, 0xb7, 0x01}
+    },
+    /* 155 */
+    {
+        {0x01, 0x01, 0x93, 0x00}, {0x16, 0x01, 0x93, 0x01},
+        {0x01, 0x01, 0x95, 0x00}, {0x16, 0x01, 0x95, 0x01},
+        {0x01, 0x01, 0x96, 0x00}, {0x16, 0x01, 0x96, 0x01},
+        {0x01, 0x01, 0x97, 0x00}, {0x16, 0x01, 0x97, 0x01},
+        {0x01, 0x01, 0x98, 0x00}, {0x16, 0x01, 0x98, 0x01},
+        {0x01, 0x01, 0x9b, 0x00}, {0x16, 0x01, 0x9b, 0x01},
+        {0x01, 0x01, 0x9d, 0x00}, {0x16, 0x01, 0x9d, 0x01},
+        {0x01, 0x01, 0x9e, 0x00}, {0x16, 0x01, 0x9e, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x93, 0x00}, {0x09, 0x01, 0x93, 0x00},
+        {0x17, 0x01, 0x93, 0x00}, {0x28, 0x01, 0x93, 0x01},
+        {0x02, 0x01, 0x95, 0x00}, {0x09, 0x01, 0x95, 0x00},
+        {0x17, 0x01, 0x95, 0x00}, {0x28, 0x01, 0x95, 0x01},
+        {0x02, 0x01, 0x96, 0x00}, {0x09, 0x01, 0x96, 0x00},
+        {0x17, 0x01, 0x96, 0x00}, {0x28, 0x01, 0x96, 0x01},
+        {0x02, 0x01, 0x97, 0x00}, {0x09, 0x01, 0x97, 0x00},
+        {0x17, 0x01, 0x97, 0x00}, {0x28, 0x01, 0x97, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x93, 0x00}, {0x06, 0x01, 0x93, 0x00},
+        {0x0a, 0x01, 0x93, 0x00}, {0x0f, 0x01, 0x93, 0x00},
+        {0x18, 0x01, 0x93, 0x00}, {0x1f, 0x01, 0x93, 0x00},
+        {0x29, 0x01, 0x93, 0x00}, {0x38, 0x01, 0x93, 0x01},
+        {0x03, 0x01, 0x95, 0x00}, {0x06, 0x01, 0x95, 0x00},
+        {0x0a, 0x01, 0x95, 0x00}, {0x0f, 0x01, 0x95, 0x00},
+        {0x18, 0x01, 0x95, 0x00}, {0x1f, 0x01, 0x95, 0x00},
+        {0x29, 0x01, 0x95, 0x00}, {0x38, 0x01, 0x95, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x96, 0x00}, {0x06, 0x01, 0x96, 0x00},
+        {0x0a, 0x01, 0x96, 0x00}, {0x0f, 0x01, 0x96, 0x00},
+        {0x18, 0x01, 0x96, 0x00}, {0x1f, 0x01, 0x96, 0x00},
+        {0x29, 0x01, 0x96, 0x00}, {0x38, 0x01, 0x96, 0x01},
+        {0x03, 0x01, 0x97, 0x00}, {0x06, 0x01, 0x97, 0x00},
+        {0x0a, 0x01, 0x97, 0x00}, {0x0f, 0x01, 0x97, 0x00},
+        {0x18, 0x01, 0x97, 0x00}, {0x1f, 0x01, 0x97, 0x00},
+        {0x29, 0x01, 0x97, 0x00}, {0x38, 0x01, 0x97, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x98, 0x00}, {0x09, 0x01, 0x98, 0x00},
+        {0x17, 0x01, 0x98, 0x00}, {0x28, 0x01, 0x98, 0x01},
+        {0x02, 0x01, 0x9b, 0x00}, {0x09, 0x01, 0x9b, 0x00},
+        {0x17, 0x01, 0x9b, 0x00}, {0x28, 0x01, 0x9b, 0x01},
+        {0x02, 0x01, 0x9d, 0x00}, {0x09, 0x01, 0x9d, 0x00},
+        {0x17, 0x01, 0x9d, 0x00}, {0x28, 0x01, 0x9d, 0x01},
+        {0x02, 0x01, 0x9e, 0x00}, {0x09, 0x01, 0x9e, 0x00},
+        {0x17, 0x01, 0x9e, 0x00}, {0x28, 0x01, 0x9e, 0x01}
+    },
+    /* 160 */
+    {
+        {0x03, 0x01, 0x98, 0x00}, {0x06, 0x01, 0x98, 0x00},
+        {0x0a, 0x01, 0x98, 0x00}, {0x0f, 0x01, 0x98, 0x00},
+        {0x18, 0x01, 0x98, 0x00}, {0x1f, 0x01, 0x98, 0x00},
+        {0x29, 0x01, 0x98, 0x00}, {0x38, 0x01, 0x98, 0x01},
+        {0x03, 0x01, 0x9b, 0x00}, {0x06, 0x01, 0x9b, 0x00},
+        {0x0a, 0x01, 0x9b, 0x00}, {0x0f, 0x01, 0x9b, 0x00},
+        {0x18, 0x01, 0x9b, 0x00}, {0x1f, 0x01, 0x9b, 0x00},
+        {0x29, 0x01, 0x9b, 0x00}, {0x38, 0x01, 0x9b, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x9d, 0x00}, {0x06, 0x01, 0x9d, 0x00},
+        {0x0a, 0x01, 0x9d, 0x00}, {0x0f, 0x01, 0x9d, 0x00},
+        {0x18, 0x01, 0x9d, 0x00}, {0x1f, 0x01, 0x9d, 0x00},
+        {0x29, 0x01, 0x9d, 0x00}, {0x38, 0x01, 0x9d, 0x01},
+        {0x03, 0x01, 0x9e, 0x00}, {0x06, 0x01, 0x9e, 0x00},
+        {0x0a, 0x01, 0x9e, 0x00}, {0x0f, 0x01, 0x9e, 0x00},
+        {0x18, 0x01, 0x9e, 0x00}, {0x1f, 0x01, 0x9e, 0x00},
+        {0x29, 0x01, 0x9e, 0x00}, {0x38, 0x01, 0x9e, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xa5, 0x00}, {0x16, 0x01, 0xa5, 0x01},
+        {0x01, 0x01, 0xa6, 0x00}, {0x16, 0x01, 0xa6, 0x01},
+        {0x01, 0x01, 0xa8, 0x00}, {0x16, 0x01, 0xa8, 0x01},
+        {0x01, 0x01, 0xae, 0x00}, {0x16, 0x01, 0xae, 0x01},
+        {0x01, 0x01, 0xaf, 0x00}, {0x16, 0x01, 0xaf, 0x01},
+        {0x01, 0x01, 0xb4, 0x00}, {0x16, 0x01, 0xb4, 0x01},
+        {0x01, 0x01, 0xb6, 0x00}, {0x16, 0x01, 0xb6, 0x01},
+        {0x01, 0x01, 0xb7, 0x00}, {0x16, 0x01, 0xb7, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xa5, 0x00}, {0x09, 0x01, 0xa5, 0x00},
+        {0x17, 0x01, 0xa5, 0x00}, {0x28, 0x01, 0xa5, 0x01},
+        {0x02, 0x01, 0xa6, 0x00}, {0x09, 0x01, 0xa6, 0x00},
+        {0x17, 0x01, 0xa6, 0x00}, {0x28, 0x01, 0xa6, 0x01},
+        {0x02, 0x01, 0xa8, 0x00}, {0x09, 0x01, 0xa8, 0x00},
+        {0x17, 0x01, 0xa8, 0x00}, {0x28, 0x01, 0xa8, 0x01},
+        {0x02, 0x01, 0xae, 0x00}, {0x09, 0x01, 0xae, 0x00},
+        {0x17, 0x01, 0xae, 0x00}, {0x28, 0x01, 0xae, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xa5, 0x00}, {0x06, 0x01, 0xa5, 0x00},
+        {0x0a, 0x01, 0xa5, 0x00}, {0x0f, 0x01, 0xa5, 0x00},
+        {0x18, 0x01, 0xa5, 0x00}, {0x1f, 0x01, 0xa5, 0x00},
+        {0x29, 0x01, 0xa5, 0x00}, {0x38, 0x01, 0xa5, 0x01},
+        {0x03, 0x01, 0xa6, 0x00}, {0x06, 0x01, 0xa6, 0x00},
+        {0x0a, 0x01, 0xa6, 0x00}, {0x0f, 0x01, 0xa6, 0x00},
+        {0x18, 0x01, 0xa6, 0x00}, {0x1f, 0x01, 0xa6, 0x00},
+        {0x29, 0x01, 0xa6, 0x00}, {0x38, 0x01, 0xa6, 0x01}
+    },
+    /* 165 */
+    {
+        {0x03, 0x01, 0xa8, 0x00}, {0x06, 0x01, 0xa8, 0x00},
+        {0x0a, 0x01, 0xa8, 0x00}, {0x0f, 0x01, 0xa8, 0x00},
+        {0x18, 0x01, 0xa8, 0x00}, {0x1f, 0x01, 0xa8, 0x00},
+        {0x29, 0x01, 0xa8, 0x00}, {0x38, 0x01, 0xa8, 0x01},
+        {0x03, 0x01, 0xae, 0x00}, {0x06, 0x01, 0xae, 0x00},
+        {0x0a, 0x01, 0xae, 0x00}, {0x0f, 0x01, 0xae, 0x00},
+        {0x18, 0x01, 0xae, 0x00}, {0x1f, 0x01, 0xae, 0x00},
+        {0x29, 0x01, 0xae, 0x00}, {0x38, 0x01, 0xae, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xaf, 0x00}, {0x09, 0x01, 0xaf, 0x00},
+        {0x17, 0x01, 0xaf, 0x00}, {0x28, 0x01, 0xaf, 0x01},
+        {0x02, 0x01, 0xb4, 0x00}, {0x09, 0x01, 0xb4, 0x00},
+        {0x17, 0x01, 0xb4, 0x00}, {0x28, 0x01, 0xb4, 0x01},
+        {0x02, 0x01, 0xb6, 0x00}, {0x09, 0x01, 0xb6, 0x00},
+        {0x17, 0x01, 0xb6, 0x00}, {0x28, 0x01, 0xb6, 0x01},
+        {0x02, 0x01, 0xb7, 0x00}, {0x09, 0x01, 0xb7, 0x00},
+        {0x17, 0x01, 0xb7, 0x00}, {0x28, 0x01, 0xb7, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xaf, 0x00}, {0x06, 0x01, 0xaf, 0x00},
+        {0x0a, 0x01, 0xaf, 0x00}, {0x0f, 0x01, 0xaf, 0x00},
+        {0x18, 0x01, 0xaf, 0x00}, {0x1f, 0x01, 0xaf, 0x00},
+        {0x29, 0x01, 0xaf, 0x00}, {0x38, 0x01, 0xaf, 0x01},
+        {0x03, 0x01, 0xb4, 0x00}, {0x06, 0x01, 0xb4, 0x00},
+        {0x0a, 0x01, 0xb4, 0x00}, {0x0f, 0x01, 0xb4, 0x00},
+        {0x18, 0x01, 0xb4, 0x00}, {0x1f, 0x01, 0xb4, 0x00},
+        {0x29, 0x01, 0xb4, 0x00}, {0x38, 0x01, 0xb4, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xb6, 0x00}, {0x06, 0x01, 0xb6, 0x00},
+        {0x0a, 0x01, 0xb6, 0x00}, {0x0f, 0x01, 0xb6, 0x00},
+        {0x18, 0x01, 0xb6, 0x00}, {0x1f, 0x01, 0xb6, 0x00},
+        {0x29, 0x01, 0xb6, 0x00}, {0x38, 0x01, 0xb6, 0x01},
+        {0x03, 0x01, 0xb7, 0x00}, {0x06, 0x01, 0xb7, 0x00},
+        {0x0a, 0x01, 0xb7, 0x00}, {0x0f, 0x01, 0xb7, 0x00},
+        {0x18, 0x01, 0xb7, 0x00}, {0x1f, 0x01, 0xb7, 0x00},
+        {0x29, 0x01, 0xb7, 0x00}, {0x38, 0x01, 0xb7, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xbc, 0x01}, {0x00, 0x01, 0xbf, 0x01},
+        {0x00, 0x01, 0xc5, 0x01}, {0x00, 0x01, 0xe7, 0x01},
+        {0x00, 0x01, 0xef, 0x01}, {0xb0, 0x00, 0x00, 0x00},
+        {0xb2, 0x00, 0x00, 0x00}, {0xb3, 0x00, 0x00, 0x00},
+        {0xb7, 0x00, 0x00, 0x00}, {0xb8, 0x00, 0x00, 0x00},
+        {0xba, 0x00, 0x00, 0x00}, {0xbb, 0x00, 0x00, 0x00},
+        {0xc0, 0x00, 0x00, 0x00}, {0xc7, 0x00, 0x00, 0x00},
+        {0xd0, 0x00, 0x00, 0x00}, {0xdf, 0x00, 0x00, 0x01}
+    },
+    /* 170 */
+    {
+        {0x01, 0x01, 0xbc, 0x00}, {0x16, 0x01, 0xbc, 0x01},
+        {0x01, 0x01, 0xbf, 0x00}, {0x16, 0x01, 0xbf, 0x01},
+        {0x01, 0x01, 0xc5, 0x00}, {0x16, 0x01, 0xc5, 0x01},
+        {0x01, 0x01, 0xe7, 0x00}, {0x16, 0x01, 0xe7, 0x01},
+        {0x01, 0x01, 0xef, 0x00}, {0x16, 0x01, 0xef, 0x01},
+        {0x00, 0x01, 0x09, 0x01}, {0x00, 0x01, 0x8e, 0x01},
+        {0x00, 0x01, 0x90, 0x01}, {0x00, 0x01, 0x91, 0x01},
+        {0x00, 0x01, 0x94, 0x01}, {0x00, 0x01, 0x9f, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xbc, 0x00}, {0x09, 0x01, 0xbc, 0x00},
+        {0x17, 0x01, 0xbc, 0x00}, {0x28, 0x01, 0xbc, 0x01},
+        {0x02, 0x01, 0xbf, 0x00}, {0x09, 0x01, 0xbf, 0x00},
+        {0x17, 0x01, 0xbf, 0x00}, {0x28, 0x01, 0xbf, 0x01},
+        {0x02, 0x01, 0xc5, 0x00}, {0x09, 0x01, 0xc5, 0x00},
+        {0x17, 0x01, 0xc5, 0x00}, {0x28, 0x01, 0xc5, 0x01},
+        {0x02, 0x01, 0xe7, 0x00}, {0x09, 0x01, 0xe7, 0x00},
+        {0x17, 0x01, 0xe7, 0x00}, {0x28, 0x01, 0xe7, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xbc, 0x00}, {0x06, 0x01, 0xbc, 0x00},
+        {0x0a, 0x01, 0xbc, 0x00}, {0x0f, 0x01, 0xbc, 0x00},
+        {0x18, 0x01, 0xbc, 0x00}, {0x1f, 0x01, 0xbc, 0x00},
+        {0x29, 0x01, 0xbc, 0x00}, {0x38, 0x01, 0xbc, 0x01},
+        {0x03, 0x01, 0xbf, 0x00}, {0x06, 0x01, 0xbf, 0x00},
+        {0x0a, 0x01, 0xbf, 0x00}, {0x0f, 0x01, 0xbf, 0x00},
+        {0x18, 0x01, 0xbf, 0x00}, {0x1f, 0x01, 0xbf, 0x00},
+        {0x29, 0x01, 0xbf, 0x00}, {0x38, 0x01, 0xbf, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xc5, 0x00}, {0x06, 0x01, 0xc5, 0x00},
+        {0x0a, 0x01, 0xc5, 0x00}, {0x0f, 0x01, 0xc5, 0x00},
+        {0x18, 0x01, 0xc5, 0x00}, {0x1f, 0x01, 0xc5, 0x00},
+        {0x29, 0x01, 0xc5, 0x00}, {0x38, 0x01, 0xc5, 0x01},
+        {0x03, 0x01, 0xe7, 0x00}, {0x06, 0x01, 0xe7, 0x00},
+        {0x0a, 0x01, 0xe7, 0x00}, {0x0f, 0x01, 0xe7, 0x00},
+        {0x18, 0x01, 0xe7, 0x00}, {0x1f, 0x01, 0xe7, 0x00},
+        {0x29, 0x01, 0xe7, 0x00}, {0x38, 0x01, 0xe7, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xef, 0x00}, {0x09, 0x01, 0xef, 0x00},
+        {0x17, 0x01, 0xef, 0x00}, {0x28, 0x01, 0xef, 0x01},
+        {0x01, 0x01, 0x09, 0x00}, {0x16, 0x01, 0x09, 0x01},
+        {0x01, 0x01, 0x8e, 0x00}, {0x16, 0x01, 0x8e, 0x01},
+        {0x01, 0x01, 0x90, 0x00}, {0x16, 0x01, 0x90, 0x01},
+        {0x01, 0x01, 0x91, 0x00}, {0x16, 0x01, 0x91, 0x01},
+        {0x01, 0x01, 0x94, 0x00}, {0x16, 0x01, 0x94, 0x01},
+        {0x01, 0x01, 0x9f, 0x00}, {0x16, 0x01, 0x9f, 0x01}
+    },
+    /* 175 */
+    {
+        {0x03, 0x01, 0xef, 0x00}, {0x06, 0x01, 0xef, 0x00},
+        {0x0a, 0x01, 0xef, 0x00}, {0x0f, 0x01, 0xef, 0x00},
+        {0x18, 0x01, 0xef, 0x00}, {0x1f, 0x01, 0xef, 0x00},
+        {0x29, 0x01, 0xef, 0x00}, {0x38, 0x01, 0xef, 0x01},
+        {0x02, 0x01, 0x09, 0x00}, {0x09, 0x01, 0x09, 0x00},
+        {0x17, 0x01, 0x09, 0x00}, {0x28, 0x01, 0x09, 0x01},
+        {0x02, 0x01, 0x8e, 0x00}, {0x09, 0x01, 0x8e, 0x00},
+        {0x17, 0x01, 0x8e, 0x00}, {0x28, 0x01, 0x8e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x09, 0x00}, {0x06, 0x01, 0x09, 0x00},
+        {0x0a, 0x01, 0x09, 0x00}, {0x0f, 0x01, 0x09, 0x00},
+        {0x18, 0x01, 0x09, 0x00}, {0x1f, 0x01, 0x09, 0x00},
+        {0x29, 0x01, 0x09, 0x00}, {0x38, 0x01, 0x09, 0x01},
+        {0x03, 0x01, 0x8e, 0x00}, {0x06, 0x01, 0x8e, 0x00},
+        {0x0a, 0x01, 0x8e, 0x00}, {0x0f, 0x01, 0x8e, 0x00},
+        {0x18, 0x01, 0x8e, 0x00}, {0x1f, 0x01, 0x8e, 0x00},
+        {0x29, 0x01, 0x8e, 0x00}, {0x38, 0x01, 0x8e, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x90, 0x00}, {0x09, 0x01, 0x90, 0x00},
+        {0x17, 0x01, 0x90, 0x00}, {0x28, 0x01, 0x90, 0x01},
+        {0x02, 0x01, 0x91, 0x00}, {0x09, 0x01, 0x91, 0x00},
+        {0x17, 0x01, 0x91, 0x00}, {0x28, 0x01, 0x91, 0x01},
+        {0x02, 0x01, 0x94, 0x00}, {0x09, 0x01, 0x94, 0x00},
+        {0x17, 0x01, 0x94, 0x00}, {0x28, 0x01, 0x94, 0x01},
+        {0x02, 0x01, 0x9f, 0x00}, {0x09, 0x01, 0x9f, 0x00},
+        {0x17, 0x01, 0x9f, 0x00}, {0x28, 0x01, 0x9f, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x90, 0x00}, {0x06, 0x01, 0x90, 0x00},
+        {0x0a, 0x01, 0x90, 0x00}, {0x0f, 0x01, 0x90, 0x00},
+        {0x18, 0x01, 0x90, 0x00}, {0x1f, 0x01, 0x90, 0x00},
+        {0x29, 0x01, 0x90, 0x00}, {0x38, 0x01, 0x90, 0x01},
+        {0x03, 0x01, 0x91, 0x00}, {0x06, 0x01, 0x91, 0x00},
+        {0x0a, 0x01, 0x91, 0x00}, {0x0f, 0x01, 0x91, 0x00},
+        {0x18, 0x01, 0x91, 0x00}, {0x1f, 0x01, 0x91, 0x00},
+        {0x29, 0x01, 0x91, 0x00}, {0x38, 0x01, 0x91, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x94, 0x00}, {0x06, 0x01, 0x94, 0x00},
+        {0x0a, 0x01, 0x94, 0x00}, {0x0f, 0x01, 0x94, 0x00},
+        {0x18, 0x01, 0x94, 0x00}, {0x1f, 0x01, 0x94, 0x00},
+        {0x29, 0x01, 0x94, 0x00}, {0x38, 0x01, 0x94, 0x01},
+        {0x03, 0x01, 0x9f, 0x00}, {0x06, 0x01, 0x9f, 0x00},
+        {0x0a, 0x01, 0x9f, 0x00}, {0x0f, 0x01, 0x9f, 0x00},
+        {0x18, 0x01, 0x9f, 0x00}, {0x1f, 0x01, 0x9f, 0x00},
+        {0x29, 0x01, 0x9f, 0x00}, {0x38, 0x01, 0x9f, 0x01}
+    },
+    /* 180 */
+    {
+        {0x00, 0x01, 0xab, 0x01}, {0x00, 0x01, 0xce, 0x01},
+        {0x00, 0x01, 0xd7, 0x01}, {0x00, 0x01, 0xe1, 0x01},
+        {0x00, 0x01, 0xec, 0x01}, {0x00, 0x01, 0xed, 0x01},
+        {0xbc, 0x00, 0x00, 0x00}, {0xbd, 0x00, 0x00, 0x00},
+        {0xc1, 0x00, 0x00, 0x00}, {0xc4, 0x00, 0x00, 0x00},
+        {0xc8, 0x00, 0x00, 0x00}, {0xcb, 0x00, 0x00, 0x00},
+        {0xd1, 0x00, 0x00, 0x00}, {0xd8, 0x00, 0x00, 0x00},
+        {0xe0, 0x00, 0x00, 0x00}, {0xee, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xab, 0x00}, {0x16, 0x01, 0xab, 0x01},
+        {0x01, 0x01, 0xce, 0x00}, {0x16, 0x01, 0xce, 0x01},
+        {0x01, 0x01, 0xd7, 0x00}, {0x16, 0x01, 0xd7, 0x01},
+        {0x01, 0x01, 0xe1, 0x00}, {0x16, 0x01, 0xe1, 0x01},
+        {0x01, 0x01, 0xec, 0x00}, {0x16, 0x01, 0xec, 0x01},
+        {0x01, 0x01, 0xed, 0x00}, {0x16, 0x01, 0xed, 0x01},
+        {0x00, 0x01, 0xc7, 0x01}, {0x00, 0x01, 0xcf, 0x01},
+        {0x00, 0x01, 0xea, 0x01}, {0x00, 0x01, 0xeb, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xab, 0x00}, {0x09, 0x01, 0xab, 0x00},
+        {0x17, 0x01, 0xab, 0x00}, {0x28, 0x01, 0xab, 0x01},
+        {0x02, 0x01, 0xce, 0x00}, {0x09, 0x01, 0xce, 0x00},
+        {0x17, 0x01, 0xce, 0x00}, {0x28, 0x01, 0xce, 0x01},
+        {0x02, 0x01, 0xd7, 0x00}, {0x09, 0x01, 0xd7, 0x00},
+        {0x17, 0x01, 0xd7, 0x00}, {0x28, 0x01, 0xd7, 0x01},
+        {0x02, 0x01, 0xe1, 0x00}, {0x09, 0x01, 0xe1, 0x00},
+        {0x17, 0x01, 0xe1, 0x00}, {0x28, 0x01, 0xe1, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xab, 0x00}, {0x06, 0x01, 0xab, 0x00},
+        {0x0a, 0x01, 0xab, 0x00}, {0x0f, 0x01, 0xab, 0x00},
+        {0x18, 0x01, 0xab, 0x00}, {0x1f, 0x01, 0xab, 0x00},
+        {0x29, 0x01, 0xab, 0x00}, {0x38, 0x01, 0xab, 0x01},
+        {0x03, 0x01, 0xce, 0x00}, {0x06, 0x01, 0xce, 0x00},
+        {0x0a, 0x01, 0xce, 0x00}, {0x0f, 0x01, 0xce, 0x00},
+        {0x18, 0x01, 0xce, 0x00}, {0x1f, 0x01, 0xce, 0x00},
+        {0x29, 0x01, 0xce, 0x00}, {0x38, 0x01, 0xce, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd7, 0x00}, {0x06, 0x01, 0xd7, 0x00},
+        {0x0a, 0x01, 0xd7, 0x00}, {0x0f, 0x01, 0xd7, 0x00},
+        {0x18, 0x01, 0xd7, 0x00}, {0x1f, 0x01, 0xd7, 0x00},
+        {0x29, 0x01, 0xd7, 0x00}, {0x38, 0x01, 0xd7, 0x01},
+        {0x03, 0x01, 0xe1, 0x00}, {0x06, 0x01, 0xe1, 0x00},
+        {0x0a, 0x01, 0xe1, 0x00}, {0x0f, 0x01, 0xe1, 0x00},
+        {0x18, 0x01, 0xe1, 0x00}, {0x1f, 0x01, 0xe1, 0x00},
+        {0x29, 0x01, 0xe1, 0x00}, {0x38, 0x01, 0xe1, 0x01}
+    },
+    /* 185 */
+    {
+        {0x02, 0x01, 0xec, 0x00}, {0x09, 0x01, 0xec, 0x00},
+        {0x17, 0x01, 0xec, 0x00}, {0x28, 0x01, 0xec, 0x01},
+        {0x02, 0x01, 0xed, 0x00}, {0x09, 0x01, 0xed, 0x00},
+        {0x17, 0x01, 0xed, 0x00}, {0x28, 0x01, 0xed, 0x01},
+        {0x01, 0x01, 0xc7, 0x00}, {0x16, 0x01, 0xc7, 0x01},
+        {0x01, 0x01, 0xcf, 0x00}, {0x16, 0x01, 0xcf, 0x01},
+        {0x01, 0x01, 0xea, 0x00}, {0x16, 0x01, 0xea, 0x01},
+        {0x01, 0x01, 0xeb, 0x00}, {0x16, 0x01, 0xeb, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xec, 0x00}, {0x06, 0x01, 0xec, 0x00},
+        {0x0a, 0x01, 0xec, 0x00}, {0x0f, 0x01, 0xec, 0x00},
+        {0x18, 0x01, 0xec, 0x00}, {0x1f, 0x01, 0xec, 0x00},
+        {0x29, 0x01, 0xec, 0x00}, {0x38, 0x01, 0xec, 0x01},
+        {0x03, 0x01, 0xed, 0x00}, {0x06, 0x01, 0xed, 0x00},
+        {0x0a, 0x01, 0xed, 0x00}, {0x0f, 0x01, 0xed, 0x00},
+        {0x18, 0x01, 0xed, 0x00}, {0x1f, 0x01, 0xed, 0x00},
+        {0x29, 0x01, 0xed, 0x00}, {0x38, 0x01, 0xed, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xc7, 0x00}, {0x09, 0x01, 0xc7, 0x00},
+        {0x17, 0x01, 0xc7, 0x00}, {0x28, 0x01, 0xc7, 0x01},
+        {0x02, 0x01, 0xcf, 0x00}, {0x09, 0x01, 0xcf, 0x00},
+        {0x17, 0x01, 0xcf, 0x00}, {0x28, 0x01, 0xcf, 0x01},
+        {0x02, 0x01, 0xea, 0x00}, {0x09, 0x01, 0xea, 0x00},
+        {0x17, 0x01, 0xea, 0x00}, {0x28, 0x01, 0xea, 0x01},
+        {0x02, 0x01, 0xeb, 0x00}, {0x09, 0x01, 0xeb, 0x00},
+        {0x17, 0x01, 0xeb, 0x00}, {0x28, 0x01, 0xeb, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xc7, 0x00}, {0x06, 0x01, 0xc7, 0x00},
+        {0x0a, 0x01, 0xc7, 0x00}, {0x0f, 0x01, 0xc7, 0x00},
+        {0x18, 0x01, 0xc7, 0x00}, {0x1f, 0x01, 0xc7, 0x00},
+        {0x29, 0x01, 0xc7, 0x00}, {0x38, 0x01, 0xc7, 0x01},
+        {0x03, 0x01, 0xcf, 0x00}, {0x06, 0x01, 0xcf, 0x00},
+        {0x0a, 0x01, 0xcf, 0x00}, {0x0f, 0x01, 0xcf, 0x00},
+        {0x18, 0x01, 0xcf, 0x00}, {0x1f, 0x01, 0xcf, 0x00},
+        {0x29, 0x01, 0xcf, 0x00}, {0x38, 0x01, 0xcf, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xea, 0x00}, {0x06, 0x01, 0xea, 0x00},
+        {0x0a, 0x01, 0xea, 0x00}, {0x0f, 0x01, 0xea, 0x00},
+        {0x18, 0x01, 0xea, 0x00}, {0x1f, 0x01, 0xea, 0x00},
+        {0x29, 0x01, 0xea, 0x00}, {0x38, 0x01, 0xea, 0x01},
+        {0x03, 0x01, 0xeb, 0x00}, {0x06, 0x01, 0xeb, 0x00},
+        {0x0a, 0x01, 0xeb, 0x00}, {0x0f, 0x01, 0xeb, 0x00},
+        {0x18, 0x01, 0xeb, 0x00}, {0x1f, 0x01, 0xeb, 0x00},
+        {0x29, 0x01, 0xeb, 0x00}, {0x38, 0x01, 0xeb, 0x01}
+    },
+    /* 190 */
+    {
+        {0xc2, 0x00, 0x00, 0x00}, {0xc3, 0x00, 0x00, 0x00},
+        {0xc5, 0x00, 0x00, 0x00}, {0xc6, 0x00, 0x00, 0x00},
+        {0xc9, 0x00, 0x00, 0x00}, {0xca, 0x00, 0x00, 0x00},
+        {0xcc, 0x00, 0x00, 0x00}, {0xcd, 0x00, 0x00, 0x00},
+        {0xd2, 0x00, 0x00, 0x00}, {0xd5, 0x00, 0x00, 0x00},
+        {0xd9, 0x00, 0x00, 0x00}, {0xdc, 0x00, 0x00, 0x00},
+        {0xe1, 0x00, 0x00, 0x00}, {0xe7, 0x00, 0x00, 0x00},
+        {0xef, 0x00, 0x00, 0x00}, {0xf6, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xc0, 0x01}, {0x00, 0x01, 0xc1, 0x01},
+        {0x00, 0x01, 0xc8, 0x01}, {0x00, 0x01, 0xc9, 0x01},
+        {0x00, 0x01, 0xca, 0x01}, {0x00, 0x01, 0xcd, 0x01},
+        {0x00, 0x01, 0xd2, 0x01}, {0x00, 0x01, 0xd5, 0x01},
+        {0x00, 0x01, 0xda, 0x01}, {0x00, 0x01, 0xdb, 0x01},
+        {0x00, 0x01, 0xee, 0x01}, {0x00, 0x01, 0xf0, 0x01},
+        {0x00, 0x01, 0xf2, 0x01}, {0x00, 0x01, 0xf3, 0x01},
+        {0x00, 0x01, 0xff, 0x01}, {0xce, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x01, 0x01, 0xc0, 0x00}, {0x16, 0x01, 0xc0, 0x01},
+        {0x01, 0x01, 0xc1, 0x00}, {0x16, 0x01, 0xc1, 0x01},
+        {0x01, 0x01, 0xc8, 0x00}, {0x16, 0x01, 0xc8, 0x01},
+        {0x01, 0x01, 0xc9, 0x00}, {0x16, 0x01, 0xc9, 0x01},
+        {0x01, 0x01, 0xca, 0x00}, {0x16, 0x01, 0xca, 0x01},
+        {0x01, 0x01, 0xcd, 0x00}, {0x16, 0x01, 0xcd, 0x01},
+        {0x01, 0x01, 0xd2, 0x00}, {0x16, 0x01, 0xd2, 0x01},
+        {0x01, 0x01, 0xd5, 0x00}, {0x16, 0x01, 0xd5, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xc0, 0x00}, {0x09, 0x01, 0xc0, 0x00},
+        {0x17, 0x01, 0xc0, 0x00}, {0x28, 0x01, 0xc0, 0x01},
+        {0x02, 0x01, 0xc1, 0x00}, {0x09, 0x01, 0xc1, 0x00},
+        {0x17, 0x01, 0xc1, 0x00}, {0x28, 0x01, 0xc1, 0x01},
+        {0x02, 0x01, 0xc8, 0x00}, {0x09, 0x01, 0xc8, 0x00},
+        {0x17, 0x01, 0xc8, 0x00}, {0x28, 0x01, 0xc8, 0x01},
+        {0x02, 0x01, 0xc9, 0x00}, {0x09, 0x01, 0xc9, 0x00},
+        {0x17, 0x01, 0xc9, 0x00}, {0x28, 0x01, 0xc9, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xc0, 0x00}, {0x06, 0x01, 0xc0, 0x00},
+        {0x0a, 0x01, 0xc0, 0x00}, {0x0f, 0x01, 0xc0, 0x00},
+        {0x18, 0x01, 0xc0, 0x00}, {0x1f, 0x01, 0xc0, 0x00},
+        {0x29, 0x01, 0xc0, 0x00}, {0x38, 0x01, 0xc0, 0x01},
+        {0x03, 0x01, 0xc1, 0x00}, {0x06, 0x01, 0xc1, 0x00},
+        {0x0a, 0x01, 0xc1, 0x00}, {0x0f, 0x01, 0xc1, 0x00},
+        {0x18, 0x01, 0xc1, 0x00}, {0x1f, 0x01, 0xc1, 0x00},
+        {0x29, 0x01, 0xc1, 0x00}, {0x38, 0x01, 0xc1, 0x01}
+    },
+    /* 195 */
+    {
+        {0x03, 0x01, 0xc8, 0x00}, {0x06, 0x01, 0xc8, 0x00},
+        {0x0a, 0x01, 0xc8, 0x00}, {0x0f, 0x01, 0xc8, 0x00},
+        {0x18, 0x01, 0xc8, 0x00}, {0x1f, 0x01, 0xc8, 0x00},
+        {0x29, 0x01, 0xc8, 0x00}, {0x38, 0x01, 0xc8, 0x01},
+        {0x03, 0x01, 0xc9, 0x00}, {0x06, 0x01, 0xc9, 0x00},
+        {0x0a, 0x01, 0xc9, 0x00}, {0x0f, 0x01, 0xc9, 0x00},
+        {0x18, 0x01, 0xc9, 0x00}, {0x1f, 0x01, 0xc9, 0x00},
+        {0x29, 0x01, 0xc9, 0x00}, {0x38, 0x01, 0xc9, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xca, 0x00}, {0x09, 0x01, 0xca, 0x00},
+        {0x17, 0x01, 0xca, 0x00}, {0x28, 0x01, 0xca, 0x01},
+        {0x02, 0x01, 0xcd, 0x00}, {0x09, 0x01, 0xcd, 0x00},
+        {0x17, 0x01, 0xcd, 0x00}, {0x28, 0x01, 0xcd, 0x01},
+        {0x02, 0x01, 0xd2, 0x00}, {0x09, 0x01, 0xd2, 0x00},
+        {0x17, 0x01, 0xd2, 0x00}, {0x28, 0x01, 0xd2, 0x01},
+        {0x02, 0x01, 0xd5, 0x00}, {0x09, 0x01, 0xd5, 0x00},
+        {0x17, 0x01, 0xd5, 0x00}, {0x28, 0x01, 0xd5, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xca, 0x00}, {0x06, 0x01, 0xca, 0x00},
+        {0x0a, 0x01, 0xca, 0x00}, {0x0f, 0x01, 0xca, 0x00},
+        {0x18, 0x01, 0xca, 0x00}, {0x1f, 0x01, 0xca, 0x00},
+        {0x29, 0x01, 0xca, 0x00}, {0x38, 0x01, 0xca, 0x01},
+        {0x03, 0x01, 0xcd, 0x00}, {0x06, 0x01, 0xcd, 0x00},
+        {0x0a, 0x01, 0xcd, 0x00}, {0x0f, 0x01, 0xcd, 0x00},
+        {0x18, 0x01, 0xcd, 0x00}, {0x1f, 0x01, 0xcd, 0x00},
+        {0x29, 0x01, 0xcd, 0x00}, {0x38, 0x01, 0xcd, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd2, 0x00}, {0x06, 0x01, 0xd2, 0x00},
+        {0x0a, 0x01, 0xd2, 0x00}, {0x0f, 0x01, 0xd2, 0x00},
+        {0x18, 0x01, 0xd2, 0x00}, {0x1f, 0x01, 0xd2, 0x00},
+        {0x29, 0x01, 0xd2, 0x00}, {0x38, 0x01, 0xd2, 0x01},
+        {0x03, 0x01, 0xd5, 0x00}, {0x06, 0x01, 0xd5, 0x00},
+        {0x0a, 0x01, 0xd5, 0x00}, {0x0f, 0x01, 0xd5, 0x00},
+        {0x18, 0x01, 0xd5, 0x00}, {0x1f, 0x01, 0xd5, 0x00},
+        {0x29, 0x01, 0xd5, 0x00}, {0x38, 0x01, 0xd5, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xda, 0x00}, {0x16, 0x01, 0xda, 0x01},
+        {0x01, 0x01, 0xdb, 0x00}, {0x16, 0x01, 0xdb, 0x01},
+        {0x01, 0x01, 0xee, 0x00}, {0x16, 0x01, 0xee, 0x01},
+        {0x01, 0x01, 0xf0, 0x00}, {0x16, 0x01, 0xf0, 0x01},
+        {0x01, 0x01, 0xf2, 0x00}, {0x16, 0x01, 0xf2, 0x01},
+        {0x01, 0x01, 0xf3, 0x00}, {0x16, 0x01, 0xf3, 0x01},
+        {0x01, 0x01, 0xff, 0x00}, {0x16, 0x01, 0xff, 0x01},
+        {0x00, 0x01, 0xcb, 0x01}, {0x00, 0x01, 0xcc, 0x01}
+    },
+    /* 200 */
+    {
+        {0x02, 0x01, 0xda, 0x00}, {0x09, 0x01, 0xda, 0x00},
+        {0x17, 0x01, 0xda, 0x00}, {0x28, 0x01, 0xda, 0x01},
+        {0x02, 0x01, 0xdb, 0x00}, {0x09, 0x01, 0xdb, 0x00},
+        {0x17, 0x01, 0xdb, 0x00}, {0x28, 0x01, 0xdb, 0x01},
+        {0x02, 0x01, 0xee, 0x00}, {0x09, 0x01, 0xee, 0x00},
+        {0x17, 0x01, 0xee, 0x00}, {0x28, 0x01, 0xee, 0x01},
+        {0x02, 0x01, 0xf0, 0x00}, {0x09, 0x01, 0xf0, 0x00},
+        {0x17, 0x01, 0xf0, 0x00}, {0x28, 0x01, 0xf0, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xda, 0x00}, {0x06, 0x01, 0xda, 0x00},
+        {0x0a, 0x01, 0xda, 0x00}, {0x0f, 0x01, 0xda, 0x00},
+        {0x18, 0x01, 0xda, 0x00}, {0x1f, 0x01, 0xda, 0x00},
+        {0x29, 0x01, 0xda, 0x00}, {0x38, 0x01, 0xda, 0x01},
+        {0x03, 0x01, 0xdb, 0x00}, {0x06, 0x01, 0xdb, 0x00},
+        {0x0a, 0x01, 0xdb, 0x00}, {0x0f, 0x01, 0xdb, 0x00},
+        {0x18, 0x01, 0xdb, 0x00}, {0x1f, 0x01, 0xdb, 0x00},
+        {0x29, 0x01, 0xdb, 0x00}, {0x38, 0x01, 0xdb, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xee, 0x00}, {0x06, 0x01, 0xee, 0x00},
+        {0x0a, 0x01, 0xee, 0x00}, {0x0f, 0x01, 0xee, 0x00},
+        {0x18, 0x01, 0xee, 0x00}, {0x1f, 0x01, 0xee, 0x00},
+        {0x29, 0x01, 0xee, 0x00}, {0x38, 0x01, 0xee, 0x01},
+        {0x03, 0x01, 0xf0, 0x00}, {0x06, 0x01, 0xf0, 0x00},
+        {0x0a, 0x01, 0xf0, 0x00}, {0x0f, 0x01, 0xf0, 0x00},
+        {0x18, 0x01, 0xf0, 0x00}, {0x1f, 0x01, 0xf0, 0x00},
+        {0x29, 0x01, 0xf0, 0x00}, {0x38, 0x01, 0xf0, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xf2, 0x00}, {0x09, 0x01, 0xf2, 0x00},
+        {0x17, 0x01, 0xf2, 0x00}, {0x28, 0x01, 0xf2, 0x01},
+        {0x02, 0x01, 0xf3, 0x00}, {0x09, 0x01, 0xf3, 0x00},
+        {0x17, 0x01, 0xf3, 0x00}, {0x28, 0x01, 0xf3, 0x01},
+        {0x02, 0x01, 0xff, 0x00}, {0x09, 0x01, 0xff, 0x00},
+        {0x17, 0x01, 0xff, 0x00}, {0x28, 0x01, 0xff, 0x01},
+        {0x01, 0x01, 0xcb, 0x00}, {0x16, 0x01, 0xcb, 0x01},
+        {0x01, 0x01, 0xcc, 0x00}, {0x16, 0x01, 0xcc, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xf2, 0x00}, {0x06, 0x01, 0xf2, 0x00},
+        {0x0a, 0x01, 0xf2, 0x00}, {0x0f, 0x01, 0xf2, 0x00},
+        {0x18, 0x01, 0xf2, 0x00}, {0x1f, 0x01, 0xf2, 0x00},
+        {0x29, 0x01, 0xf2, 0x00}, {0x38, 0x01, 0xf2, 0x01},
+        {0x03, 0x01, 0xf3, 0x00}, {0x06, 0x01, 0xf3, 0x00},
+        {0x0a, 0x01, 0xf3, 0x00}, {0x0f, 0x01, 0xf3, 0x00},
+        {0x18, 0x01, 0xf3, 0x00}, {0x1f, 0x01, 0xf3, 0x00},
+        {0x29, 0x01, 0xf3, 0x00}, {0x38, 0x01, 0xf3, 0x01}
+    },
+    /* 205 */
+    {
+        {0x03, 0x01, 0xff, 0x00}, {0x06, 0x01, 0xff, 0x00},
+        {0x0a, 0x01, 0xff, 0x00}, {0x0f, 0x01, 0xff, 0x00},
+        {0x18, 0x01, 0xff, 0x00}, {0x1f, 0x01, 0xff, 0x00},
+        {0x29, 0x01, 0xff, 0x00}, {0x38, 0x01, 0xff, 0x01},
+        {0x02, 0x01, 0xcb, 0x00}, {0x09, 0x01, 0xcb, 0x00},
+        {0x17, 0x01, 0xcb, 0x00}, {0x28, 0x01, 0xcb, 0x01},
+        {0x02, 0x01, 0xcc, 0x00}, {0x09, 0x01, 0xcc, 0x00},
+        {0x17, 0x01, 0xcc, 0x00}, {0x28, 0x01, 0xcc, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xcb, 0x00}, {0x06, 0x01, 0xcb, 0x00},
+        {0x0a, 0x01, 0xcb, 0x00}, {0x0f, 0x01, 0xcb, 0x00},
+        {0x18, 0x01, 0xcb, 0x00}, {0x1f, 0x01, 0xcb, 0x00},
+        {0x29, 0x01, 0xcb, 0x00}, {0x38, 0x01, 0xcb, 0x01},
+        {0x03, 0x01, 0xcc, 0x00}, {0x06, 0x01, 0xcc, 0x00},
+        {0x0a, 0x01, 0xcc, 0x00}, {0x0f, 0x01, 0xcc, 0x00},
+        {0x18, 0x01, 0xcc, 0x00}, {0x1f, 0x01, 0xcc, 0x00},
+        {0x29, 0x01, 0xcc, 0x00}, {0x38, 0x01, 0xcc, 0x01}
+    },
+    {
+        {0xd3, 0x00, 0x00, 0x00}, {0xd4, 0x00, 0x00, 0x00},
+        {0xd6, 0x00, 0x00, 0x00}, {0xd7, 0x00, 0x00, 0x00},
+        {0xda, 0x00, 0x00, 0x00}, {0xdb, 0x00, 0x00, 0x00},
+        {0xdd, 0x00, 0x00, 0x00}, {0xde, 0x00, 0x00, 0x00},
+        {0xe2, 0x00, 0x00, 0x00}, {0xe4, 0x00, 0x00, 0x00},
+        {0xe8, 0x00, 0x00, 0x00}, {0xeb, 0x00, 0x00, 0x00},
+        {0xf0, 0x00, 0x00, 0x00}, {0xf3, 0x00, 0x00, 0x00},
+        {0xf7, 0x00, 0x00, 0x00}, {0xfa, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xd3, 0x01}, {0x00, 0x01, 0xd4, 0x01},
+        {0x00, 0x01, 0xd6, 0x01}, {0x00, 0x01, 0xdd, 0x01},
+        {0x00, 0x01, 0xde, 0x01}, {0x00, 0x01, 0xdf, 0x01},
+        {0x00, 0x01, 0xf1, 0x01}, {0x00, 0x01, 0xf4, 0x01},
+        {0x00, 0x01, 0xf5, 0x01}, {0x00, 0x01, 0xf6, 0x01},
+        {0x00, 0x01, 0xf7, 0x01}, {0x00, 0x01, 0xf8, 0x01},
+        {0x00, 0x01, 0xfa, 0x01}, {0x00, 0x01, 0xfb, 0x01},
+        {0x00, 0x01, 0xfc, 0x01}, {0x00, 0x01, 0xfd, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xd3, 0x00}, {0x16, 0x01, 0xd3, 0x01},
+        {0x01, 0x01, 0xd4, 0x00}, {0x16, 0x01, 0xd4, 0x01},
+        {0x01, 0x01, 0xd6, 0x00}, {0x16, 0x01, 0xd6, 0x01},
+        {0x01, 0x01, 0xdd, 0x00}, {0x16, 0x01, 0xdd, 0x01},
+        {0x01, 0x01, 0xde, 0x00}, {0x16, 0x01, 0xde, 0x01},
+        {0x01, 0x01, 0xdf, 0x00}, {0x16, 0x01, 0xdf, 0x01},
+        {0x01, 0x01, 0xf1, 0x00}, {0x16, 0x01, 0xf1, 0x01},
+        {0x01, 0x01, 0xf4, 0x00}, {0x16, 0x01, 0xf4, 0x01}
+    },
+    /* 210 */
+    {
+        {0x02, 0x01, 0xd3, 0x00}, {0x09, 0x01, 0xd3, 0x00},
+        {0x17, 0x01, 0xd3, 0x00}, {0x28, 0x01, 0xd3, 0x01},
+        {0x02, 0x01, 0xd4, 0x00}, {0x09, 0x01, 0xd4, 0x00},
+        {0x17, 0x01, 0xd4, 0x00}, {0x28, 0x01, 0xd4, 0x01},
+        {0x02, 0x01, 0xd6, 0x00}, {0x09, 0x01, 0xd6, 0x00},
+        {0x17, 0x01, 0xd6, 0x00}, {0x28, 0x01, 0xd6, 0x01},
+        {0x02, 0x01, 0xdd, 0x00}, {0x09, 0x01, 0xdd, 0x00},
+        {0x17, 0x01, 0xdd, 0x00}, {0x28, 0x01, 0xdd, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd3, 0x00}, {0x06, 0x01, 0xd3, 0x00},
+        {0x0a, 0x01, 0xd3, 0x00}, {0x0f, 0x01, 0xd3, 0x00},
+        {0x18, 0x01, 0xd3, 0x00}, {0x1f, 0x01, 0xd3, 0x00},
+        {0x29, 0x01, 0xd3, 0x00}, {0x38, 0x01, 0xd3, 0x01},
+        {0x03, 0x01, 0xd4, 0x00}, {0x06, 0x01, 0xd4, 0x00},
+        {0x0a, 0x01, 0xd4, 0x00}, {0x0f, 0x01, 0xd4, 0x00},
+        {0x18, 0x01, 0xd4, 0x00}, {0x1f, 0x01, 0xd4, 0x00},
+        {0x29, 0x01, 0xd4, 0x00}, {0x38, 0x01, 0xd4, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xd6, 0x00}, {0x06, 0x01, 0xd6, 0x00},
+        {0x0a, 0x01, 0xd6, 0x00}, {0x0f, 0x01, 0xd6, 0x00},
+        {0x18, 0x01, 0xd6, 0x00}, {0x1f, 0x01, 0xd6, 0x00},
+        {0x29, 0x01, 0xd6, 0x00}, {0x38, 0x01, 0xd6, 0x01},
+        {0x03, 0x01, 0xdd, 0x00}, {0x06, 0x01, 0xdd, 0x00},
+        {0x0a, 0x01, 0xdd, 0x00}, {0x0f, 0x01, 0xdd, 0x00},
+        {0x18, 0x01, 0xdd, 0x00}, {0x1f, 0x01, 0xdd, 0x00},
+        {0x29, 0x01, 0xdd, 0x00}, {0x38, 0x01, 0xdd, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xde, 0x00}, {0x09, 0x01, 0xde, 0x00},
+        {0x17, 0x01, 0xde, 0x00}, {0x28, 0x01, 0xde, 0x01},
+        {0x02, 0x01, 0xdf, 0x00}, {0x09, 0x01, 0xdf, 0x00},
+        {0x17, 0x01, 0xdf, 0x00}, {0x28, 0x01, 0xdf, 0x01},
+        {0x02, 0x01, 0xf1, 0x00}, {0x09, 0x01, 0xf1, 0x00},
+        {0x17, 0x01, 0xf1, 0x00}, {0x28, 0x01, 0xf1, 0x01},
+        {0x02, 0x01, 0xf4, 0x00}, {0x09, 0x01, 0xf4, 0x00},
+        {0x17, 0x01, 0xf4, 0x00}, {0x28, 0x01, 0xf4, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xde, 0x00}, {0x06, 0x01, 0xde, 0x00},
+        {0x0a, 0x01, 0xde, 0x00}, {0x0f, 0x01, 0xde, 0x00},
+        {0x18, 0x01, 0xde, 0x00}, {0x1f, 0x01, 0xde, 0x00},
+        {0x29, 0x01, 0xde, 0x00}, {0x38, 0x01, 0xde, 0x01},
+        {0x03, 0x01, 0xdf, 0x00}, {0x06, 0x01, 0xdf, 0x00},
+        {0x0a, 0x01, 0xdf, 0x00}, {0x0f, 0x01, 0xdf, 0x00},
+        {0x18, 0x01, 0xdf, 0x00}, {0x1f, 0x01, 0xdf, 0x00},
+        {0x29, 0x01, 0xdf, 0x00}, {0x38, 0x01, 0xdf, 0x01}
+    },
+    /* 215 */
+    {
+        {0x03, 0x01, 0xf1, 0x00}, {0x06, 0x01, 0xf1, 0x00},
+        {0x0a, 0x01, 0xf1, 0x00}, {0x0f, 0x01, 0xf1, 0x00},
+        {0x18, 0x01, 0xf1, 0x00}, {0x1f, 0x01, 0xf1, 0x00},
+        {0x29, 0x01, 0xf1, 0x00}, {0x38, 0x01, 0xf1, 0x01},
+        {0x03, 0x01, 0xf4, 0x00}, {0x06, 0x01, 0xf4, 0x00},
+        {0x0a, 0x01, 0xf4, 0x00}, {0x0f, 0x01, 0xf4, 0x00},
+        {0x18, 0x01, 0xf4, 0x00}, {0x1f, 0x01, 0xf4, 0x00},
+        {0x29, 0x01, 0xf4, 0x00}, {0x38, 0x01, 0xf4, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xf5, 0x00}, {0x16, 0x01, 0xf5, 0x01},
+        {0x01, 0x01, 0xf6, 0x00}, {0x16, 0x01, 0xf6, 0x01},
+        {0x01, 0x01, 0xf7, 0x00}, {0x16, 0x01, 0xf7, 0x01},
+        {0x01, 0x01, 0xf8, 0x00}, {0x16, 0x01, 0xf8, 0x01},
+        {0x01, 0x01, 0xfa, 0x00}, {0x16, 0x01, 0xfa, 0x01},
+        {0x01, 0x01, 0xfb, 0x00}, {0x16, 0x01, 0xfb, 0x01},
+        {0x01, 0x01, 0xfc, 0x00}, {0x16, 0x01, 0xfc, 0x01},
+        {0x01, 0x01, 0xfd, 0x00}, {0x16, 0x01, 0xfd, 0x01}
+    },
+    {
+        {0x02, 0x01, 0xf5, 0x00}, {0x09, 0x01, 0xf5, 0x00},
+        {0x17, 0x01, 0xf5, 0x00}, {0x28, 0x01, 0xf5, 0x01},
+        {0x02, 0x01, 0xf6, 0x00}, {0x09, 0x01, 0xf6, 0x00},
+        {0x17, 0x01, 0xf6, 0x00}, {0x28, 0x01, 0xf6, 0x01},
+        {0x02, 0x01, 0xf7, 0x00}, {0x09, 0x01, 0xf7, 0x00},
+        {0x17, 0x01, 0xf7, 0x00}, {0x28, 0x01, 0xf7, 0x01},
+        {0x02, 0x01, 0xf8, 0x00}, {0x09, 0x01, 0xf8, 0x00},
+        {0x17, 0x01, 0xf8, 0x00}, {0x28, 0x01, 0xf8, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xf5, 0x00}, {0x06, 0x01, 0xf5, 0x00},
+        {0x0a, 0x01, 0xf5, 0x00}, {0x0f, 0x01, 0xf5, 0x00},
+        {0x18, 0x01, 0xf5, 0x00}, {0x1f, 0x01, 0xf5, 0x00},
+        {0x29, 0x01, 0xf5, 0x00}, {0x38, 0x01, 0xf5, 0x01},
+        {0x03, 0x01, 0xf6, 0x00}, {0x06, 0x01, 0xf6, 0x00},
+        {0x0a, 0x01, 0xf6, 0x00}, {0x0f, 0x01, 0xf6, 0x00},
+        {0x18, 0x01, 0xf6, 0x00}, {0x1f, 0x01, 0xf6, 0x00},
+        {0x29, 0x01, 0xf6, 0x00}, {0x38, 0x01, 0xf6, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xf7, 0x00}, {0x06, 0x01, 0xf7, 0x00},
+        {0x0a, 0x01, 0xf7, 0x00}, {0x0f, 0x01, 0xf7, 0x00},
+        {0x18, 0x01, 0xf7, 0x00}, {0x1f, 0x01, 0xf7, 0x00},
+        {0x29, 0x01, 0xf7, 0x00}, {0x38, 0x01, 0xf7, 0x01},
+        {0x03, 0x01, 0xf8, 0x00}, {0x06, 0x01, 0xf8, 0x00},
+        {0x0a, 0x01, 0xf8, 0x00}, {0x0f, 0x01, 0xf8, 0x00},
+        {0x18, 0x01, 0xf8, 0x00}, {0x1f, 0x01, 0xf8, 0x00},
+        {0x29, 0x01, 0xf8, 0x00}, {0x38, 0x01, 0xf8, 0x01}
+    },
+    /* 220 */
+    {
+        {0x02, 0x01, 0xfa, 0x00}, {0x09, 0x01, 0xfa, 0x00},
+        {0x17, 0x01, 0xfa, 0x00}, {0x28, 0x01, 0xfa, 0x01},
+        {0x02, 0x01, 0xfb, 0x00}, {0x09, 0x01, 0xfb, 0x00},
+        {0x17, 0x01, 0xfb, 0x00}, {0x28, 0x01, 0xfb, 0x01},
+        {0x02, 0x01, 0xfc, 0x00}, {0x09, 0x01, 0xfc, 0x00},
+        {0x17, 0x01, 0xfc, 0x00}, {0x28, 0x01, 0xfc, 0x01},
+        {0x02, 0x01, 0xfd, 0x00}, {0x09, 0x01, 0xfd, 0x00},
+        {0x17, 0x01, 0xfd, 0x00}, {0x28, 0x01, 0xfd, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xfa, 0x00}, {0x06, 0x01, 0xfa, 0x00},
+        {0x0a, 0x01, 0xfa, 0x00}, {0x0f, 0x01, 0xfa, 0x00},
+        {0x18, 0x01, 0xfa, 0x00}, {0x1f, 0x01, 0xfa, 0x00},
+        {0x29, 0x01, 0xfa, 0x00}, {0x38, 0x01, 0xfa, 0x01},
+        {0x03, 0x01, 0xfb, 0x00}, {0x06, 0x01, 0xfb, 0x00},
+        {0x0a, 0x01, 0xfb, 0x00}, {0x0f, 0x01, 0xfb, 0x00},
+        {0x18, 0x01, 0xfb, 0x00}, {0x1f, 0x01, 0xfb, 0x00},
+        {0x29, 0x01, 0xfb, 0x00}, {0x38, 0x01, 0xfb, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xfc, 0x00}, {0x06, 0x01, 0xfc, 0x00},
+        {0x0a, 0x01, 0xfc, 0x00}, {0x0f, 0x01, 0xfc, 0x00},
+        {0x18, 0x01, 0xfc, 0x00}, {0x1f, 0x01, 0xfc, 0x00},
+        {0x29, 0x01, 0xfc, 0x00}, {0x38, 0x01, 0xfc, 0x01},
+        {0x03, 0x01, 0xfd, 0x00}, {0x06, 0x01, 0xfd, 0x00},
+        {0x0a, 0x01, 0xfd, 0x00}, {0x0f, 0x01, 0xfd, 0x00},
+        {0x18, 0x01, 0xfd, 0x00}, {0x1f, 0x01, 0xfd, 0x00},
+        {0x29, 0x01, 0xfd, 0x00}, {0x38, 0x01, 0xfd, 0x01}
+    },
+    {
+        {0x00, 0x01, 0xfe, 0x01}, {0xe3, 0x00, 0x00, 0x00},
+        {0xe5, 0x00, 0x00, 0x00}, {0xe6, 0x00, 0x00, 0x00},
+        {0xe9, 0x00, 0x00, 0x00}, {0xea, 0x00, 0x00, 0x00},
+        {0xec, 0x00, 0x00, 0x00}, {0xed, 0x00, 0x00, 0x00},
+        {0xf1, 0x00, 0x00, 0x00}, {0xf2, 0x00, 0x00, 0x00},
+        {0xf4, 0x00, 0x00, 0x00}, {0xf5, 0x00, 0x00, 0x00},
+        {0xf8, 0x00, 0x00, 0x00}, {0xf9, 0x00, 0x00, 0x00},
+        {0xfb, 0x00, 0x00, 0x00}, {0xfc, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x01, 0x01, 0xfe, 0x00}, {0x16, 0x01, 0xfe, 0x01},
+        {0x00, 0x01, 0x02, 0x01}, {0x00, 0x01, 0x03, 0x01},
+        {0x00, 0x01, 0x04, 0x01}, {0x00, 0x01, 0x05, 0x01},
+        {0x00, 0x01, 0x06, 0x01}, {0x00, 0x01, 0x07, 0x01},
+        {0x00, 0x01, 0x08, 0x01}, {0x00, 0x01, 0x0b, 0x01},
+        {0x00, 0x01, 0x0c, 0x01}, {0x00, 0x01, 0x0e, 0x01},
+        {0x00, 0x01, 0x0f, 0x01}, {0x00, 0x01, 0x10, 0x01},
+        {0x00, 0x01, 0x11, 0x01}, {0x00, 0x01, 0x12, 0x01}
+    },
+    /* 225 */
+    {
+        {0x02, 0x01, 0xfe, 0x00}, {0x09, 0x01, 0xfe, 0x00},
+        {0x17, 0x01, 0xfe, 0x00}, {0x28, 0x01, 0xfe, 0x01},
+        {0x01, 0x01, 0x02, 0x00}, {0x16, 0x01, 0x02, 0x01},
+        {0x01, 0x01, 0x03, 0x00}, {0x16, 0x01, 0x03, 0x01},
+        {0x01, 0x01, 0x04, 0x00}, {0x16, 0x01, 0x04, 0x01},
+        {0x01, 0x01, 0x05, 0x00}, {0x16, 0x01, 0x05, 0x01},
+        {0x01, 0x01, 0x06, 0x00}, {0x16, 0x01, 0x06, 0x01},
+        {0x01, 0x01, 0x07, 0x00}, {0x16, 0x01, 0x07, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xfe, 0x00}, {0x06, 0x01, 0xfe, 0x00},
+        {0x0a, 0x01, 0xfe, 0x00}, {0x0f, 0x01, 0xfe, 0x00},
+        {0x18, 0x01, 0xfe, 0x00}, {0x1f, 0x01, 0xfe, 0x00},
+        {0x29, 0x01, 0xfe, 0x00}, {0x38, 0x01, 0xfe, 0x01},
+        {0x02, 0x01, 0x02, 0x00}, {0x09, 0x01, 0x02, 0x00},
+        {0x17, 0x01, 0x02, 0x00}, {0x28, 0x01, 0x02, 0x01},
+        {0x02, 0x01, 0x03, 0x00}, {0x09, 0x01, 0x03, 0x00},
+        {0x17, 0x01, 0x03, 0x00}, {0x28, 0x01, 0x03, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x02, 0x00}, {0x06, 0x01, 0x02, 0x00},
+        {0x0a, 0x01, 0x02, 0x00}, {0x0f, 0x01, 0x02, 0x00},
+        {0x18, 0x01, 0x02, 0x00}, {0x1f, 0x01, 0x02, 0x00},
+        {0x29, 0x01, 0x02, 0x00}, {0x38, 0x01, 0x02, 0x01},
+        {0x03, 0x01, 0x03, 0x00}, {0x06, 0x01, 0x03, 0x00},
+        {0x0a, 0x01, 0x03, 0x00}, {0x0f, 0x01, 0x03, 0x00},
+        {0x18, 0x01, 0x03, 0x00}, {0x1f, 0x01, 0x03, 0x00},
+        {0x29, 0x01, 0x03, 0x00}, {0x38, 0x01, 0x03, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x04, 0x00}, {0x09, 0x01, 0x04, 0x00},
+        {0x17, 0x01, 0x04, 0x00}, {0x28, 0x01, 0x04, 0x01},
+        {0x02, 0x01, 0x05, 0x00}, {0x09, 0x01, 0x05, 0x00},
+        {0x17, 0x01, 0x05, 0x00}, {0x28, 0x01, 0x05, 0x01},
+        {0x02, 0x01, 0x06, 0x00}, {0x09, 0x01, 0x06, 0x00},
+        {0x17, 0x01, 0x06, 0x00}, {0x28, 0x01, 0x06, 0x01},
+        {0x02, 0x01, 0x07, 0x00}, {0x09, 0x01, 0x07, 0x00},
+        {0x17, 0x01, 0x07, 0x00}, {0x28, 0x01, 0x07, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x04, 0x00}, {0x06, 0x01, 0x04, 0x00},
+        {0x0a, 0x01, 0x04, 0x00}, {0x0f, 0x01, 0x04, 0x00},
+        {0x18, 0x01, 0x04, 0x00}, {0x1f, 0x01, 0x04, 0x00},
+        {0x29, 0x01, 0x04, 0x00}, {0x38, 0x01, 0x04, 0x01},
+        {0x03, 0x01, 0x05, 0x00}, {0x06, 0x01, 0x05, 0x00},
+        {0x0a, 0x01, 0x05, 0x00}, {0x0f, 0x01, 0x05, 0x00},
+        {0x18, 0x01, 0x05, 0x00}, {0x1f, 0x01, 0x05, 0x00},
+        {0x29, 0x01, 0x05, 0x00}, {0x38, 0x01, 0x05, 0x01}
+    },
+    /* 230 */
+    {
+        {0x03, 0x01, 0x06, 0x00}, {0x06, 0x01, 0x06, 0x00},
+        {0x0a, 0x01, 0x06, 0x00}, {0x0f, 0x01, 0x06, 0x00},
+        {0x18, 0x01, 0x06, 0x00}, {0x1f, 0x01, 0x06, 0x00},
+        {0x29, 0x01, 0x06, 0x00}, {0x38, 0x01, 0x06, 0x01},
+        {0x03, 0x01, 0x07, 0x00}, {0x06, 0x01, 0x07, 0x00},
+        {0x0a, 0x01, 0x07, 0x00}, {0x0f, 0x01, 0x07, 0x00},
+        {0x18, 0x01, 0x07, 0x00}, {0x1f, 0x01, 0x07, 0x00},
+        {0x29, 0x01, 0x07, 0x00}, {0x38, 0x01, 0x07, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x08, 0x00}, {0x16, 0x01, 0x08, 0x01},
+        {0x01, 0x01, 0x0b, 0x00}, {0x16, 0x01, 0x0b, 0x01},
+        {0x01, 0x01, 0x0c, 0x00}, {0x16, 0x01, 0x0c, 0x01},
+        {0x01, 0x01, 0x0e, 0x00}, {0x16, 0x01, 0x0e, 0x01},
+        {0x01, 0x01, 0x0f, 0x00}, {0x16, 0x01, 0x0f, 0x01},
+        {0x01, 0x01, 0x10, 0x00}, {0x16, 0x01, 0x10, 0x01},
+        {0x01, 0x01, 0x11, 0x00}, {0x16, 0x01, 0x11, 0x01},
+        {0x01, 0x01, 0x12, 0x00}, {0x16, 0x01, 0x12, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x08, 0x00}, {0x09, 0x01, 0x08, 0x00},
+        {0x17, 0x01, 0x08, 0x00}, {0x28, 0x01, 0x08, 0x01},
+        {0x02, 0x01, 0x0b, 0x00}, {0x09, 0x01, 0x0b, 0x00},
+        {0x17, 0x01, 0x0b, 0x00}, {0x28, 0x01, 0x0b, 0x01},
+        {0x02, 0x01, 0x0c, 0x00}, {0x09, 0x01, 0x0c, 0x00},
+        {0x17, 0x01, 0x0c, 0x00}, {0x28, 0x01, 0x0c, 0x01},
+        {0x02, 0x01, 0x0e, 0x00}, {0x09, 0x01, 0x0e, 0x00},
+        {0x17, 0x01, 0x0e, 0x00}, {0x28, 0x01, 0x0e, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x08, 0x00}, {0x06, 0x01, 0x08, 0x00},
+        {0x0a, 0x01, 0x08, 0x00}, {0x0f, 0x01, 0x08, 0x00},
+        {0x18, 0x01, 0x08, 0x00}, {0x1f, 0x01, 0x08, 0x00},
+        {0x29, 0x01, 0x08, 0x00}, {0x38, 0x01, 0x08, 0x01},
+        {0x03, 0x01, 0x0b, 0x00}, {0x06, 0x01, 0x0b, 0x00},
+        {0x0a, 0x01, 0x0b, 0x00}, {0x0f, 0x01, 0x0b, 0x00},
+        {0x18, 0x01, 0x0b, 0x00}, {0x1f, 0x01, 0x0b, 0x00},
+        {0x29, 0x01, 0x0b, 0x00}, {0x38, 0x01, 0x0b, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x0c, 0x00}, {0x06, 0x01, 0x0c, 0x00},
+        {0x0a, 0x01, 0x0c, 0x00}, {0x0f, 0x01, 0x0c, 0x00},
+        {0x18, 0x01, 0x0c, 0x00}, {0x1f, 0x01, 0x0c, 0x00},
+        {0x29, 0x01, 0x0c, 0x00}, {0x38, 0x01, 0x0c, 0x01},
+        {0x03, 0x01, 0x0e, 0x00}, {0x06, 0x01, 0x0e, 0x00},
+        {0x0a, 0x01, 0x0e, 0x00}, {0x0f, 0x01, 0x0e, 0x00},
+        {0x18, 0x01, 0x0e, 0x00}, {0x1f, 0x01, 0x0e, 0x00},
+        {0x29, 0x01, 0x0e, 0x00}, {0x38, 0x01, 0x0e, 0x01}
+    },
+    /* 235 */
+    {
+        {0x02, 0x01, 0x0f, 0x00}, {0x09, 0x01, 0x0f, 0x00},
+        {0x17, 0x01, 0x0f, 0x00}, {0x28, 0x01, 0x0f, 0x01},
+        {0x02, 0x01, 0x10, 0x00}, {0x09, 0x01, 0x10, 0x00},
+        {0x17, 0x01, 0x10, 0x00}, {0x28, 0x01, 0x10, 0x01},
+        {0x02, 0x01, 0x11, 0x00}, {0x09, 0x01, 0x11, 0x00},
+        {0x17, 0x01, 0x11, 0x00}, {0x28, 0x01, 0x11, 0x01},
+        {0x02, 0x01, 0x12, 0x00}, {0x09, 0x01, 0x12, 0x00},
+        {0x17, 0x01, 0x12, 0x00}, {0x28, 0x01, 0x12, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x0f, 0x00}, {0x06, 0x01, 0x0f, 0x00},
+        {0x0a, 0x01, 0x0f, 0x00}, {0x0f, 0x01, 0x0f, 0x00},
+        {0x18, 0x01, 0x0f, 0x00}, {0x1f, 0x01, 0x0f, 0x00},
+        {0x29, 0x01, 0x0f, 0x00}, {0x38, 0x01, 0x0f, 0x01},
+        {0x03, 0x01, 0x10, 0x00}, {0x06, 0x01, 0x10, 0x00},
+        {0x0a, 0x01, 0x10, 0x00}, {0x0f, 0x01, 0x10, 0x00},
+        {0x18, 0x01, 0x10, 0x00}, {0x1f, 0x01, 0x10, 0x00},
+        {0x29, 0x01, 0x10, 0x00}, {0x38, 0x01, 0x10, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x11, 0x00}, {0x06, 0x01, 0x11, 0x00},
+        {0x0a, 0x01, 0x11, 0x00}, {0x0f, 0x01, 0x11, 0x00},
+        {0x18, 0x01, 0x11, 0x00}, {0x1f, 0x01, 0x11, 0x00},
+        {0x29, 0x01, 0x11, 0x00}, {0x38, 0x01, 0x11, 0x01},
+        {0x03, 0x01, 0x12, 0x00}, {0x06, 0x01, 0x12, 0x00},
+        {0x0a, 0x01, 0x12, 0x00}, {0x0f, 0x01, 0x12, 0x00},
+        {0x18, 0x01, 0x12, 0x00}, {0x1f, 0x01, 0x12, 0x00},
+        {0x29, 0x01, 0x12, 0x00}, {0x38, 0x01, 0x12, 0x01}
+    },
+    {
+        {0x00, 0x01, 0x13, 0x01}, {0x00, 0x01, 0x14, 0x01},
+        {0x00, 0x01, 0x15, 0x01}, {0x00, 0x01, 0x17, 0x01},
+        {0x00, 0x01, 0x18, 0x01}, {0x00, 0x01, 0x19, 0x01},
+        {0x00, 0x01, 0x1a, 0x01}, {0x00, 0x01, 0x1b, 0x01},
+        {0x00, 0x01, 0x1c, 0x01}, {0x00, 0x01, 0x1d, 0x01},
+        {0x00, 0x01, 0x1e, 0x01}, {0x00, 0x01, 0x1f, 0x01},
+        {0x00, 0x01, 0x7f, 0x01}, {0x00, 0x01, 0xdc, 0x01},
+        {0x00, 0x01, 0xf9, 0x01}, {0xfd, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x13, 0x00}, {0x16, 0x01, 0x13, 0x01},
+        {0x01, 0x01, 0x14, 0x00}, {0x16, 0x01, 0x14, 0x01},
+        {0x01, 0x01, 0x15, 0x00}, {0x16, 0x01, 0x15, 0x01},
+        {0x01, 0x01, 0x17, 0x00}, {0x16, 0x01, 0x17, 0x01},
+        {0x01, 0x01, 0x18, 0x00}, {0x16, 0x01, 0x18, 0x01},
+        {0x01, 0x01, 0x19, 0x00}, {0x16, 0x01, 0x19, 0x01},
+        {0x01, 0x01, 0x1a, 0x00}, {0x16, 0x01, 0x1a, 0x01},
+        {0x01, 0x01, 0x1b, 0x00}, {0x16, 0x01, 0x1b, 0x01}
+    },
+    /* 240 */
+    {
+        {0x02, 0x01, 0x13, 0x00}, {0x09, 0x01, 0x13, 0x00},
+        {0x17, 0x01, 0x13, 0x00}, {0x28, 0x01, 0x13, 0x01},
+        {0x02, 0x01, 0x14, 0x00}, {0x09, 0x01, 0x14, 0x00},
+        {0x17, 0x01, 0x14, 0x00}, {0x28, 0x01, 0x14, 0x01},
+        {0x02, 0x01, 0x15, 0x00}, {0x09, 0x01, 0x15, 0x00},
+        {0x17, 0x01, 0x15, 0x00}, {0x28, 0x01, 0x15, 0x01},
+        {0x02, 0x01, 0x17, 0x00}, {0x09, 0x01, 0x17, 0x00},
+        {0x17, 0x01, 0x17, 0x00}, {0x28, 0x01, 0x17, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x13, 0x00}, {0x06, 0x01, 0x13, 0x00},
+        {0x0a, 0x01, 0x13, 0x00}, {0x0f, 0x01, 0x13, 0x00},
+        {0x18, 0x01, 0x13, 0x00}, {0x1f, 0x01, 0x13, 0x00},
+        {0x29, 0x01, 0x13, 0x00}, {0x38, 0x01, 0x13, 0x01},
+        {0x03, 0x01, 0x14, 0x00}, {0x06, 0x01, 0x14, 0x00},
+        {0x0a, 0x01, 0x14, 0x00}, {0x0f, 0x01, 0x14, 0x00},
+        {0x18, 0x01, 0x14, 0x00}, {0x1f, 0x01, 0x14, 0x00},
+        {0x29, 0x01, 0x14, 0x00}, {0x38, 0x01, 0x14, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x15, 0x00}, {0x06, 0x01, 0x15, 0x00},
+        {0x0a, 0x01, 0x15, 0x00}, {0x0f, 0x01, 0x15, 0x00},
+        {0x18, 0x01, 0x15, 0x00}, {0x1f, 0x01, 0x15, 0x00},
+        {0x29, 0x01, 0x15, 0x00}, {0x38, 0x01, 0x15, 0x01},
+        {0x03, 0x01, 0x17, 0x00}, {0x06, 0x01, 0x17, 0x00},
+        {0x0a, 0x01, 0x17, 0x00}, {0x0f, 0x01, 0x17, 0x00},
+        {0x18, 0x01, 0x17, 0x00}, {0x1f, 0x01, 0x17, 0x00},
+        {0x29, 0x01, 0x17, 0x00}, {0x38, 0x01, 0x17, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x18, 0x00}, {0x09, 0x01, 0x18, 0x00},
+        {0x17, 0x01, 0x18, 0x00}, {0x28, 0x01, 0x18, 0x01},
+        {0x02, 0x01, 0x19, 0x00}, {0x09, 0x01, 0x19, 0x00},
+        {0x17, 0x01, 0x19, 0x00}, {0x28, 0x01, 0x19, 0x01},
+        {0x02, 0x01, 0x1a, 0x00}, {0x09, 0x01, 0x1a, 0x00},
+        {0x17, 0x01, 0x1a, 0x00}, {0x28, 0x01, 0x1a, 0x01},
+        {0x02, 0x01, 0x1b, 0x00}, {0x09, 0x01, 0x1b, 0x00},
+        {0x17, 0x01, 0x1b, 0x00}, {0x28, 0x01, 0x1b, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x18, 0x00}, {0x06, 0x01, 0x18, 0x00},
+        {0x0a, 0x01, 0x18, 0x00}, {0x0f, 0x01, 0x18, 0x00},
+        {0x18, 0x01, 0x18, 0x00}, {0x1f, 0x01, 0x18, 0x00},
+        {0x29, 0x01, 0x18, 0x00}, {0x38, 0x01, 0x18, 0x01},
+        {0x03, 0x01, 0x19, 0x00}, {0x06, 0x01, 0x19, 0x00},
+        {0x0a, 0x01, 0x19, 0x00}, {0x0f, 0x01, 0x19, 0x00},
+        {0x18, 0x01, 0x19, 0x00}, {0x1f, 0x01, 0x19, 0x00},
+        {0x29, 0x01, 0x19, 0x00}, {0x38, 0x01, 0x19, 0x01}
+    },
+    /* 245 */
+    {
+        {0x03, 0x01, 0x1a, 0x00}, {0x06, 0x01, 0x1a, 0x00},
+        {0x0a, 0x01, 0x1a, 0x00}, {0x0f, 0x01, 0x1a, 0x00},
+        {0x18, 0x01, 0x1a, 0x00}, {0x1f, 0x01, 0x1a, 0x00},
+        {0x29, 0x01, 0x1a, 0x00}, {0x38, 0x01, 0x1a, 0x01},
+        {0x03, 0x01, 0x1b, 0x00}, {0x06, 0x01, 0x1b, 0x00},
+        {0x0a, 0x01, 0x1b, 0x00}, {0x0f, 0x01, 0x1b, 0x00},
+        {0x18, 0x01, 0x1b, 0x00}, {0x1f, 0x01, 0x1b, 0x00},
+        {0x29, 0x01, 0x1b, 0x00}, {0x38, 0x01, 0x1b, 0x01}
+    },
+    {
+        {0x01, 0x01, 0x1c, 0x00}, {0x16, 0x01, 0x1c, 0x01},
+        {0x01, 0x01, 0x1d, 0x00}, {0x16, 0x01, 0x1d, 0x01},
+        {0x01, 0x01, 0x1e, 0x00}, {0x16, 0x01, 0x1e, 0x01},
+        {0x01, 0x01, 0x1f, 0x00}, {0x16, 0x01, 0x1f, 0x01},
+        {0x01, 0x01, 0x7f, 0x00}, {0x16, 0x01, 0x7f, 0x01},
+        {0x01, 0x01, 0xdc, 0x00}, {0x16, 0x01, 0xdc, 0x01},
+        {0x01, 0x01, 0xf9, 0x00}, {0x16, 0x01, 0xf9, 0x01},
+        {0xfe, 0x00, 0x00, 0x00}, {0xff, 0x00, 0x00, 0x01}
+    },
+    {
+        {0x02, 0x01, 0x1c, 0x00}, {0x09, 0x01, 0x1c, 0x00},
+        {0x17, 0x01, 0x1c, 0x00}, {0x28, 0x01, 0x1c, 0x01},
+        {0x02, 0x01, 0x1d, 0x00}, {0x09, 0x01, 0x1d, 0x00},
+        {0x17, 0x01, 0x1d, 0x00}, {0x28, 0x01, 0x1d, 0x01},
+        {0x02, 0x01, 0x1e, 0x00}, {0x09, 0x01, 0x1e, 0x00},
+        {0x17, 0x01, 0x1e, 0x00}, {0x28, 0x01, 0x1e, 0x01},
+        {0x02, 0x01, 0x1f, 0x00}, {0x09, 0x01, 0x1f, 0x00},
+        {0x17, 0x01, 0x1f, 0x00}, {0x28, 0x01, 0x1f, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x1c, 0x00}, {0x06, 0x01, 0x1c, 0x00},
+        {0x0a, 0x01, 0x1c, 0x00}, {0x0f, 0x01, 0x1c, 0x00},
+        {0x18, 0x01, 0x1c, 0x00}, {0x1f, 0x01, 0x1c, 0x00},
+        {0x29, 0x01, 0x1c, 0x00}, {0x38, 0x01, 0x1c, 0x01},
+        {0x03, 0x01, 0x1d, 0x00}, {0x06, 0x01, 0x1d, 0x00},
+        {0x0a, 0x01, 0x1d, 0x00}, {0x0f, 0x01, 0x1d, 0x00},
+        {0x18, 0x01, 0x1d, 0x00}, {0x1f, 0x01, 0x1d, 0x00},
+        {0x29, 0x01, 0x1d, 0x00}, {0x38, 0x01, 0x1d, 0x01}
+    },
+    {
+        {0x03, 0x01, 0x1e, 0x00}, {0x06, 0x01, 0x1e, 0x00},
+        {0x0a, 0x01, 0x1e, 0x00}, {0x0f, 0x01, 0x1e, 0x00},
+        {0x18, 0x01, 0x1e, 0x00}, {0x1f, 0x01, 0x1e, 0x00},
+        {0x29, 0x01, 0x1e, 0x00}, {0x38, 0x01, 0x1e, 0x01},
+        {0x03, 0x01, 0x1f, 0x00}, {0x06, 0x01, 0x1f, 0x00},
+        {0x0a, 0x01, 0x1f, 0x00}, {0x0f, 0x01, 0x1f, 0x00},
+        {0x18, 0x01, 0x1f, 0x00}, {0x1f, 0x01, 0x1f, 0x00},
+        {0x29, 0x01, 0x1f, 0x00}, {0x38, 0x01, 0x1f, 0x01}
+    },
+    /* 250 */
+    {
+        {0x02, 0x01, 0x7f, 0x00}, {0x09, 0x01, 0x7f, 0x00},
+        {0x17, 0x01, 0x7f, 0x00}, {0x28, 0x01, 0x7f, 0x01},
+        {0x02, 0x01, 0xdc, 0x00}, {0x09, 0x01, 0xdc, 0x00},
+        {0x17, 0x01, 0xdc, 0x00}, {0x28, 0x01, 0xdc, 0x01},
+        {0x02, 0x01, 0xf9, 0x00}, {0x09, 0x01, 0xf9, 0x00},
+        {0x17, 0x01, 0xf9, 0x00}, {0x28, 0x01, 0xf9, 0x01},
+        {0x00, 0x01, 0x0a, 0x01}, {0x00, 0x01, 0x0d, 0x01},
+        {0x00, 0x01, 0x16, 0x01}, {0xfa, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x03, 0x01, 0x7f, 0x00}, {0x06, 0x01, 0x7f, 0x00},
+        {0x0a, 0x01, 0x7f, 0x00}, {0x0f, 0x01, 0x7f, 0x00},
+        {0x18, 0x01, 0x7f, 0x00}, {0x1f, 0x01, 0x7f, 0x00},
+        {0x29, 0x01, 0x7f, 0x00}, {0x38, 0x01, 0x7f, 0x01},
+        {0x03, 0x01, 0xdc, 0x00}, {0x06, 0x01, 0xdc, 0x00},
+        {0x0a, 0x01, 0xdc, 0x00}, {0x0f, 0x01, 0xdc, 0x00},
+        {0x18, 0x01, 0xdc, 0x00}, {0x1f, 0x01, 0xdc, 0x00},
+        {0x29, 0x01, 0xdc, 0x00}, {0x38, 0x01, 0xdc, 0x01}
+    },
+    {
+        {0x03, 0x01, 0xf9, 0x00}, {0x06, 0x01, 0xf9, 0x00},
+        {0x0a, 0x01, 0xf9, 0x00}, {0x0f, 0x01, 0xf9, 0x00},
+        {0x18, 0x01, 0xf9, 0x00}, {0x1f, 0x01, 0xf9, 0x00},
+        {0x29, 0x01, 0xf9, 0x00}, {0x38, 0x01, 0xf9, 0x01},
+        {0x01, 0x01, 0x0a, 0x00}, {0x16, 0x01, 0x0a, 0x01},
+        {0x01, 0x01, 0x0d, 0x00}, {0x16, 0x01, 0x0d, 0x01},
+        {0x01, 0x01, 0x16, 0x00}, {0x16, 0x01, 0x16, 0x01},
+        {0xfc, 0x00, 0x00, 0x00}, {0xfc, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x02, 0x01, 0x0a, 0x00}, {0x09, 0x01, 0x0a, 0x00},
+        {0x17, 0x01, 0x0a, 0x00}, {0x28, 0x01, 0x0a, 0x01},
+        {0x02, 0x01, 0x0d, 0x00}, {0x09, 0x01, 0x0d, 0x00},
+        {0x17, 0x01, 0x0d, 0x00}, {0x28, 0x01, 0x0d, 0x01},
+        {0x02, 0x01, 0x16, 0x00}, {0x09, 0x01, 0x16, 0x00},
+        {0x17, 0x01, 0x16, 0x00}, {0x28, 0x01, 0x16, 0x01},
+        {0xfd, 0x00, 0x00, 0x00}, {0xfd, 0x00, 0x00, 0x00},
+        {0xfd, 0x00, 0x00, 0x00}, {0xfd, 0x00, 0x00, 0x00}
+    },
+    {
+        {0x03, 0x01, 0x0a, 0x00}, {0x06, 0x01, 0x0a, 0x00},
+        {0x0a, 0x01, 0x0a, 0x00}, {0x0f, 0x01, 0x0a, 0x00},
+        {0x18, 0x01, 0x0a, 0x00}, {0x1f, 0x01, 0x0a, 0x00},
+        {0x29, 0x01, 0x0a, 0x00}, {0x38, 0x01, 0x0a, 0x01},
+        {0x03, 0x01, 0x0d, 0x00}, {0x06, 0x01, 0x0d, 0x00},
+        {0x0a, 0x01, 0x0d, 0x00}, {0x0f, 0x01, 0x0d, 0x00},
+        {0x18, 0x01, 0x0d, 0x00}, {0x1f, 0x01, 0x0d, 0x00},
+        {0x29, 0x01, 0x0d, 0x00}, {0x38, 0x01, 0x0d, 0x01}
+    },
+    /* 255 */
+    {
+        {0x03, 0x01, 0x16, 0x00}, {0x06, 0x01, 0x16, 0x00},
+        {0x0a, 0x01, 0x16, 0x00}, {0x0f, 0x01, 0x16, 0x00},
+        {0x18, 0x01, 0x16, 0x00}, {0x1f, 0x01, 0x16, 0x00},
+        {0x29, 0x01, 0x16, 0x00}, {0x38, 0x01, 0x16, 0x01},
+        {0xff, 0x00, 0x00, 0x00}, {0xff, 0x00, 0x00, 0x00},
+        {0xff, 0x00, 0x00, 0x00}, {0xff, 0x00, 0x00, 0x00},
+        {0xff, 0x00, 0x00, 0x00}, {0xff, 0x00, 0x00, 0x00},
+        {0xff, 0x00, 0x00, 0x00}, {0xff, 0x00, 0x00, 0x00}
+    }
+};
+
+
+ngx_int_t
+ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,
+    ngx_uint_t last, ngx_log_t *log)
+{
+    u_char  *end, ch, ending;
+
+    ch = 0;
+    ending = 1;
+
+    end = src + len;
+
+    while (src != end) {
+        ch = *src++;
+
+        if (ngx_http_v2_huff_decode_bits(state, &ending, ch >> 4, dst)
+            != NGX_OK)
+        {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
+                           "http2 huffman decoding error at state %d: "
+                           "bad code 0x%Xd", *state, ch >> 4);
+
+            return NGX_ERROR;
+        }
+
+        if (ngx_http_v2_huff_decode_bits(state, &ending, ch & 0xf, dst)
+            != NGX_OK)
+        {
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,
+                           "http2 huffman decoding error at state %d: "
+                           "bad code 0x%Xd", *state, ch & 0xf);
+
+            return NGX_ERROR;
+        }
+    }
+
+    if (last) {
+        if (!ending) {
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+                           "http2 huffman decoding error: "
+                           "incomplete code 0x%Xd", ch);
+
+            return NGX_ERROR;
+        }
+
+        *state = 0;
+    }
+
+    return NGX_OK;
+}
+
+
+
+static ngx_inline ngx_int_t
+ngx_http_v2_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,
+    u_char **dst)
+{
+    ngx_http_v2_huff_decode_code_t  code;
+
+    code = ngx_http_v2_huff_decode_codes[*state][bits];
+
+    if (code.next == *state) {
+        return NGX_ERROR;
+    }
+
+    if (code.emit) {
+        *(*dst)++ = code.sym;
+    }
+
+    *ending = code.ending;
+    *state = code.next;
+
+    return NGX_OK;
+}
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_huff_encode.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_huff_encode.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,10 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_module.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_module.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,466 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <ngx_http_v2_module.h>
+
+
+static ngx_int_t ngx_http_v2_add_variables(ngx_conf_t *cf);
+
+static ngx_int_t ngx_http_v2_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+
+static ngx_int_t ngx_http_v2_module_init(ngx_cycle_t *cycle);
+
+static void *ngx_http_v2_create_main_conf(ngx_conf_t *cf);
+static char *ngx_http_v2_init_main_conf(ngx_conf_t *cf, void *conf);
+static void *ngx_http_v2_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+static void *ngx_http_v2_create_loc_conf(ngx_conf_t *cf);
+static char *ngx_http_v2_merge_loc_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+
+static char *ngx_http_v2_recv_buffer_size(ngx_conf_t *cf, void *post,
+    void *data);
+static char *ngx_http_v2_pool_size(ngx_conf_t *cf, void *post, void *data);
+static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,
+    void *data);
+static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);
+static char *ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =
+    { ngx_http_v2_recv_buffer_size };
+static ngx_conf_post_t  ngx_http_v2_pool_size_post =
+    { ngx_http_v2_pool_size };
+static ngx_conf_post_t  ngx_http_v2_streams_index_mask_post =
+    { ngx_http_v2_streams_index_mask };
+static ngx_conf_post_t  ngx_http_v2_chunk_size_post =
+    { ngx_http_v2_chunk_size };
+
+
+static ngx_command_t  ngx_http_v2_commands[] = {
+
+    { ngx_string("http2_recv_buffer_size"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      offsetof(ngx_http_v2_main_conf_t, recv_buffer_size),
+      &ngx_http_v2_recv_buffer_size_post },
+
+    { ngx_string("http2_pool_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, pool_size),
+      &ngx_http_v2_pool_size_post },
+
+    { ngx_string("http2_max_concurrent_streams"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, concurrent_streams),
+      NULL },
+
+    { ngx_string("http2_max_field_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, max_field_size),
+      NULL },
+
+    { ngx_string("http2_max_header_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, max_header_size),
+      NULL },
+
+    { ngx_string("http2_streams_index_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, streams_index_mask),
+      &ngx_http_v2_streams_index_mask_post },
+
+    { ngx_string("http2_recv_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, recv_timeout),
+      NULL },
+
+    { ngx_string("http2_idle_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_v2_srv_conf_t, idle_timeout),
+      NULL },
+
+    { ngx_string("http2_chunk_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_v2_loc_conf_t, chunk_size),
+      &ngx_http_v2_chunk_size_post },
+
+    { ngx_string("spdy_recv_buffer_size"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_MAIN_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_pool_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_max_concurrent_streams"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_streams_index_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_recv_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_keepalive_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_headers_comp"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("spdy_chunk_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_v2_spdy_deprecated,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_http_module_t  ngx_http_v2_module_ctx = {
+    ngx_http_v2_add_variables,             /* preconfiguration */
+    NULL,                                  /* postconfiguration */
+
+    ngx_http_v2_create_main_conf,          /* create main configuration */
+    ngx_http_v2_init_main_conf,            /* init main configuration */
+
+    ngx_http_v2_create_srv_conf,           /* create server configuration */
+    ngx_http_v2_merge_srv_conf,            /* merge server configuration */
+
+    ngx_http_v2_create_loc_conf,           /* create location configuration */
+    ngx_http_v2_merge_loc_conf             /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_http_v2_module = {
+    NGX_MODULE_V1,
+    &ngx_http_v2_module_ctx,               /* module context */
+    ngx_http_v2_commands,                  /* module directives */
+    NGX_HTTP_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    ngx_http_v2_module_init,               /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_http_variable_t  ngx_http_v2_vars[] = {
+
+    { ngx_string("http2"), NULL,
+      ngx_http_v2_variable, 0, 0, 0 },
+
+    { ngx_null_string, NULL, NULL, 0, 0, 0 }
+};
+
+
+static ngx_int_t
+ngx_http_v2_add_variables(ngx_conf_t *cf)
+{
+   ngx_http_variable_t  *var, *v;
+
+    for (v = ngx_http_v2_vars; v->name.len; v++) {
+        var = ngx_http_add_variable(cf, &v->name, v->flags);
+        if (var == NULL) {
+            return NGX_ERROR;
+        }
+
+        var->get_handler = v->get_handler;
+        var->data = v->data;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data)
+{
+
+    if (r->stream) {
+#if (NGX_HTTP_SSL)
+
+        if (r->connection->ssl) {
+            v->len = sizeof("h2") - 1;
+            v->valid = 1;
+            v->no_cacheable = 0;
+            v->not_found = 0;
+            v->data = (u_char *) "h2";
+
+            return NGX_OK;
+        }
+
+#endif
+        v->len = sizeof("h2c") - 1;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+        v->data = (u_char *) "h2c";
+
+        return NGX_OK;
+    }
+
+    *v = ngx_http_variable_null_value;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_module_init(ngx_cycle_t *cycle)
+{
+    return NGX_OK;
+}
+
+
+static void *
+ngx_http_v2_create_main_conf(ngx_conf_t *cf)
+{
+    ngx_http_v2_main_conf_t  *h2mcf;
+
+    h2mcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_main_conf_t));
+    if (h2mcf == NULL) {
+        return NULL;
+    }
+
+    h2mcf->recv_buffer_size = NGX_CONF_UNSET_SIZE;
+
+    return h2mcf;
+}
+
+
+static char *
+ngx_http_v2_init_main_conf(ngx_conf_t *cf, void *conf)
+{
+    ngx_http_v2_main_conf_t *h2mcf = conf;
+
+    ngx_conf_init_size_value(h2mcf->recv_buffer_size, 256 * 1024);
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_http_v2_create_srv_conf(ngx_conf_t *cf)
+{
+    ngx_http_v2_srv_conf_t  *h2scf;
+
+    h2scf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_srv_conf_t));
+    if (h2scf == NULL) {
+        return NULL;
+    }
+
+    h2scf->pool_size = NGX_CONF_UNSET_SIZE;
+
+    h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;
+
+    h2scf->max_field_size = NGX_CONF_UNSET_SIZE;
+    h2scf->max_header_size = NGX_CONF_UNSET_SIZE;
+
+    h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;
+
+    h2scf->recv_timeout = NGX_CONF_UNSET_MSEC;
+    h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;
+
+    return h2scf;
+}
+
+
+static char *
+ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_v2_srv_conf_t *prev = parent;
+    ngx_http_v2_srv_conf_t *conf = child;
+
+    ngx_conf_merge_size_value(conf->pool_size, prev->pool_size, 4096);
+
+    ngx_conf_merge_uint_value(conf->concurrent_streams,
+                              prev->concurrent_streams, 128);
+
+    ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,
+                              4096);
+    ngx_conf_merge_size_value(conf->max_header_size, prev->max_header_size,
+                              16384);
+
+    ngx_conf_merge_uint_value(conf->streams_index_mask,
+                              prev->streams_index_mask, 32 - 1);
+
+    ngx_conf_merge_msec_value(conf->recv_timeout,
+                              prev->recv_timeout, 30000);
+    ngx_conf_merge_msec_value(conf->idle_timeout,
+                              prev->idle_timeout, 180000);
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_http_v2_create_loc_conf(ngx_conf_t *cf)
+{
+    ngx_http_v2_loc_conf_t  *h2lcf;
+
+    h2lcf = ngx_pcalloc(cf->pool, sizeof(ngx_http_v2_loc_conf_t));
+    if (h2lcf == NULL) {
+        return NULL;
+    }
+
+    h2lcf->chunk_size = NGX_CONF_UNSET_SIZE;
+
+    return h2lcf;
+}
+
+
+static char *
+ngx_http_v2_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_v2_loc_conf_t *prev = parent;
+    ngx_http_v2_loc_conf_t *conf = child;
+
+    ngx_conf_merge_size_value(conf->chunk_size, prev->chunk_size, 8 * 1024);
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_v2_recv_buffer_size(ngx_conf_t *cf, void *post, void *data)
+{
+    size_t *sp = data;
+
+    if (*sp <= 2 * NGX_HTTP_V2_STATE_BUFFER_SIZE) {
+        return "value is too small";
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_v2_pool_size(ngx_conf_t *cf, void *post, void *data)
+{
+    size_t *sp = data;
+
+    if (*sp < NGX_MIN_POOL_SIZE) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "the pool size must be no less than %uz",
+                           NGX_MIN_POOL_SIZE);
+
+        return NGX_CONF_ERROR;
+    }
+
+    if (*sp % NGX_POOL_ALIGNMENT) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "the pool size must be a multiple of %uz",
+                           NGX_POOL_ALIGNMENT);
+
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post, void *data)
+{
+    ngx_uint_t *np = data;
+
+    ngx_uint_t  mask;
+
+    mask = *np - 1;
+
+    if (*np == 0 || (*np & mask)) {
+        return "must be a power of two";
+    }
+
+    *np = mask;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)
+{
+    size_t *sp = data;
+
+    if (*sp == 0) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "the http2 chunk size cannot be zero");
+
+        return NGX_CONF_ERROR;
+    }
+
+    if (*sp > NGX_HTTP_V2_MAX_FRAME_SIZE) {
+        *sp = NGX_HTTP_V2_MAX_FRAME_SIZE;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    return "is invalid: the SPDY module was deprecated, "
+           "use the HTTP/2 module instead";
+}
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_module.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_module.h	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,42 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#ifndef _NGX_HTTP_V2_MODULE_H_INCLUDED_
+#define _NGX_HTTP_V2_MODULE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+typedef struct {
+    size_t                          recv_buffer_size;
+    u_char                         *recv_buffer;
+} ngx_http_v2_main_conf_t;
+
+
+typedef struct {
+    size_t                          pool_size;
+    ngx_uint_t                      concurrent_streams;
+    size_t                          max_field_size;
+    size_t                          max_header_size;
+    ngx_uint_t                      streams_index_mask;
+    ngx_msec_t                      recv_timeout;
+    ngx_msec_t                      idle_timeout;
+} ngx_http_v2_srv_conf_t;
+
+
+typedef struct {
+    size_t                          chunk_size;
+} ngx_http_v2_loc_conf_t;
+
+
+extern ngx_module_t  ngx_http_v2_module;
+
+
+#endif /* _NGX_HTTP_V2_MODULE_H_INCLUDED_ */
diff -r 5cb7e2eed203 -r 461095b235ef src/http/v2/ngx_http_v2_table.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/http/v2/ngx_http_v2_table.c	Fri Sep 11 20:13:06 2015 +0300
@@ -0,0 +1,349 @@
+
+/*
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Valentin V. Bartenev
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+#define NGX_HTTP_V2_TABLE_SIZE  4096
+
+
+static ngx_int_t ngx_http_v2_table_account(ngx_http_v2_connection_t *h2c,
+    size_t size);
+
+
+static ngx_http_v2_header_t  ngx_http_v2_static_table[] = {
+    { ngx_string(":authority"), ngx_string("") },
+    { ngx_string(":method"), ngx_string("GET") },
+    { ngx_string(":method"), ngx_string("POST") },
+    { ngx_string(":path"), ngx_string("/") },
+    { ngx_string(":path"), ngx_string("/index.html") },
+    { ngx_string(":scheme"), ngx_string("http") },
+    { ngx_string(":scheme"), ngx_string("https") },
+    { ngx_string(":status"), ngx_string("200") },
+    { ngx_string(":status"), ngx_string("204") },
+    { ngx_string(":status"), ngx_string("206") },
+    { ngx_string(":status"), ngx_string("304") },
+    { ngx_string(":status"), ngx_string("400") },
+    { ngx_string(":status"), ngx_string("404") },
+    { ngx_string(":status"), ngx_string("500") },
+    { ngx_string("accept-charset"), ngx_string("") },
+    { ngx_string("accept-encoding"), ngx_string("gzip, deflate") },
+    { ngx_string("accept-language"), ngx_string("") },
+    { ngx_string("accept-ranges"), ngx_string("") },
+    { ngx_string("accept"), ngx_string("") },
+    { ngx_string("access-control-allow-origin"), ngx_string("") },
+    { ngx_string("age"), ngx_string("") },
+    { ngx_string("allow"), ngx_string("") },
+    { ngx_string("authorization"), ngx_string("") },
+    { ngx_string("cache-control"), ngx_string("") },
+    { ngx_string("content-disposition"), ngx_string("") },
+    { ngx_string("content-encoding"), ngx_string("") },
+    { ngx_string("content-language"), ngx_string("") },
+    { ngx_string("content-length"), ngx_string("") },
+    { ngx_string("content-location"), ngx_string("") },
+    { ngx_string("content-range"), ngx_string("") },
+    { ngx_string("content-type"), ngx_string("") },
+    { ngx_string("cookie"), ngx_string("") },
+    { ngx_string("date"), ngx_string("") },
+    { ngx_string("etag"), ngx_string("") },
+    { ngx_string("expect"), ngx_string("") },
+    { ngx_string("expires"), ngx_string("") },
+    { ngx_string("from"), ngx_string("") },
+    { ngx_string("host"), ngx_string("") },
+    { ngx_string("if-match"), ngx_string("") },
+    { ngx_string("if-modified-since"), ngx_string("") },
+    { ngx_string("if-none-match"), ngx_string("") },
+    { ngx_string("if-range"), ngx_string("") },
+    { ngx_string("if-unmodified-since"), ngx_string("") },
+    { ngx_string("last-modified"), ngx_string("") },
+    { ngx_string("link"), ngx_string("") },
+    { ngx_string("location"), ngx_string("") },
+    { ngx_string("max-forwards"), ngx_string("") },
+    { ngx_string("proxy-authenticate"), ngx_string("") },
+    { ngx_string("proxy-authorization"), ngx_string("") },
+    { ngx_string("range"), ngx_string("") },
+    { ngx_string("referer"), ngx_string("") },
+    { ngx_string("refresh"), ngx_string("") },
+    { ngx_string("retry-after"), ngx_string("") },
+    { ngx_string("server"), ngx_string("") },
+    { ngx_string("set-cookie"), ngx_string("") },
+    { ngx_string("strict-transport-security"), ngx_string("") },
+    { ngx_string("transfer-encoding"), ngx_string("") },
+    { ngx_string("user-agent"), ngx_string("") },
+    { ngx_string("vary"), ngx_string("") },
+    { ngx_string("via"), ngx_string("") },
+    { ngx_string("www-authenticate"), ngx_string("") },
+};
+
+#define NGX_HTTP_V2_STATIC_TABLE_ENTRIES                                      \
+    (sizeof(ngx_http_v2_static_table)                                         \
+     / sizeof(ngx_http_v2_header_t))
+
+
+ngx_int_t
+ngx_http_v2_get_indexed_header(ngx_http_v2_connection_t *h2c, ngx_uint_t index,
+    ngx_uint_t name_only)
+{
+    u_char                *p;
+    size_t                 rest;
+    ngx_http_v2_header_t  *entry;
+
+    if (index == 0) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent invalid hpack table index 0");
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 get indexed %s: %ui",
+                   name_only ? "header" : "header name", index);
+
+    index--;
+
+    if (index < NGX_HTTP_V2_STATIC_TABLE_ENTRIES) {
+        h2c->state.header = ngx_http_v2_static_table[index];
+        return NGX_OK;
+    }
+
+    index -= NGX_HTTP_V2_STATIC_TABLE_ENTRIES;
+
+    if (index < h2c->hpack.added - h2c->hpack.deleted) {
+        index = (h2c->hpack.added - index - 1) % h2c->hpack.allocated;
+        entry = h2c->hpack.entries[index];
+
+        p = ngx_pnalloc(h2c->state.pool, entry->name.len + 1);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        h2c->state.header.name.len = entry->name.len;
+        h2c->state.header.name.data = p;
+
+        rest = h2c->hpack.storage + NGX_HTTP_V2_TABLE_SIZE - entry->name.data;
+
+        if (entry->name.len > rest) {
+            p = ngx_cpymem(p, entry->name.data, rest);
+            p = ngx_cpymem(p, h2c->hpack.storage, entry->name.len - rest);
+
+        } else {
+            p = ngx_cpymem(p, entry->name.data, entry->name.len);
+        }
+
+        *p = '\0';
+
+        if (name_only) {
+            return NGX_OK;
+        }
+
+        p = ngx_pnalloc(h2c->state.pool, entry->value.len + 1);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        h2c->state.header.value.len = entry->value.len;
+        h2c->state.header.value.data = p;
+
+        rest = h2c->hpack.storage + NGX_HTTP_V2_TABLE_SIZE - entry->value.data;
+
+        if (entry->value.len > rest) {
+            p = ngx_cpymem(p, entry->value.data, rest);
+            p = ngx_cpymem(p, h2c->hpack.storage, entry->value.len - rest);
+
+        } else {
+            p = ngx_cpymem(p, entry->value.data, entry->value.len);
+        }
+
+        *p = '\0';
+
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                  "client sent out of bound hpack table index: %ui", index);
+
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,
+    ngx_http_v2_header_t *header)
+{
+    size_t                 avail;
+    ngx_uint_t             index;
+    ngx_http_v2_header_t  *entry, **entries;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 add header to hpack table: \"%V: %V\"",
+                   &header->name, &header->value);
+
+    if (h2c->hpack.entries == NULL) {
+        h2c->hpack.allocated = 64;
+        h2c->hpack.size = NGX_HTTP_V2_TABLE_SIZE;
+        h2c->hpack.free = NGX_HTTP_V2_TABLE_SIZE;
+
+        h2c->hpack.entries = ngx_palloc(h2c->connection->pool,
+                                        sizeof(ngx_http_v2_header_t *)
+                                        * h2c->hpack.allocated);
+        if (h2c->hpack.entries == NULL) {
+            return NGX_ERROR;
+        }
+
+        h2c->hpack.storage = ngx_palloc(h2c->connection->pool,
+                                        h2c->hpack.free);
+        if (h2c->hpack.storage == NULL) {
+            return NGX_ERROR;
+        }
+
+        h2c->hpack.pos = h2c->hpack.storage;
+    }
+
+    if (ngx_http_v2_table_account(h2c, header->name.len + header->value.len)
+        != NGX_OK)
+    {
+        return NGX_OK;
+    }
+
+    if (h2c->hpack.reused == h2c->hpack.deleted) {
+        entry = ngx_palloc(h2c->connection->pool, sizeof(ngx_http_v2_header_t));
+        if (entry == NULL) {
+            return NGX_ERROR;
+        }
+
+    } else {
+        entry = h2c->hpack.entries[h2c->hpack.reused++ % h2c->hpack.allocated];
+    }
+
+    avail = h2c->hpack.storage + NGX_HTTP_V2_TABLE_SIZE - h2c->hpack.pos;
+
+    entry->name.len = header->name.len;
+    entry->name.data = h2c->hpack.pos;
+
+    if (avail >= header->name.len) {
+        h2c->hpack.pos = ngx_cpymem(h2c->hpack.pos, header->name.data,
+                                    header->name.len);
+    } else {
+        ngx_memcpy(h2c->hpack.pos, header->name.data, avail);
+        h2c->hpack.pos = ngx_cpymem(h2c->hpack.storage,
+                                    header->name.data + avail,
+                                    header->name.len - avail);
+        avail = NGX_HTTP_V2_TABLE_SIZE;
+    }
+
+    avail -= header->name.len;
+
+    entry->value.len = header->value.len;
+    entry->value.data = h2c->hpack.pos;
+
+    if (avail >= header->value.len) {
+        h2c->hpack.pos = ngx_cpymem(h2c->hpack.pos, header->value.data,
+                                    header->value.len);
+    } else {
+        ngx_memcpy(h2c->hpack.pos, header->value.data, avail);
+        h2c->hpack.pos = ngx_cpymem(h2c->hpack.storage,
+                                    header->value.data + avail,
+                                    header->value.len - avail);
+    }
+
+    if (h2c->hpack.allocated == h2c->hpack.added - h2c->hpack.deleted) {
+
+        entries = ngx_palloc(h2c->connection->pool,
+                             sizeof(ngx_http_v2_header_t *)
+                             * (h2c->hpack.allocated + 64));
+        if (entries == NULL) {
+            return NGX_ERROR;
+        }
+
+        index = h2c->hpack.deleted % h2c->hpack.allocated;
+
+        ngx_memcpy(entries, &h2c->hpack.entries[index],
+                   (h2c->hpack.allocated - index)
+                   * sizeof(ngx_http_v2_header_t *));
+
+        ngx_memcpy(&entries[h2c->hpack.allocated - index], h2c->hpack.entries,
+                   index * sizeof(ngx_http_v2_header_t *));
+
+        (void) ngx_pfree(h2c->connection->pool, h2c->hpack.entries);
+
+        h2c->hpack.entries = entries;
+
+        h2c->hpack.added = h2c->hpack.allocated;
+        h2c->hpack.deleted = 0;
+        h2c->hpack.reused = 0;
+        h2c->hpack.allocated += 64;
+    }
+
+    h2c->hpack.entries[h2c->hpack.added++ % h2c->hpack.allocated] = entry;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_v2_table_account(ngx_http_v2_connection_t *h2c, size_t size)
+{
+    ngx_http_v2_header_t  *entry;
+
+    size += 32;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 hpack table account: %uz free:%uz",
+                   size, h2c->hpack.free);
+
+    if (size <= h2c->hpack.free) {
+        h2c->hpack.free -= size;
+        return NGX_OK;
+    }
+
+    if (size > h2c->hpack.size) {
+        h2c->hpack.deleted = h2c->hpack.added;
+        h2c->hpack.free = h2c->hpack.size;
+        return NGX_DECLINED;
+    }
+
+    do {
+        entry = h2c->hpack.entries[h2c->hpack.deleted++ % h2c->hpack.allocated];
+        h2c->hpack.free += 32 + entry->name.len + entry->value.len;
+    } while (size > h2c->hpack.free);
+
+    h2c->hpack.free -= size;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size)
+{
+    ssize_t                needed;
+    ngx_http_v2_header_t  *entry;
+
+    if (size > NGX_HTTP_V2_TABLE_SIZE) {
+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,
+                      "client sent invalid table size update: %uz", size);
+
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,
+                   "http2 new hpack table size: %uz was:%uz",
+                   size, h2c->hpack.size);
+
+    needed = h2c->hpack.size - size;
+
+    while (needed > (ssize_t) h2c->hpack.free) {
+        entry = h2c->hpack.entries[h2c->hpack.deleted++ % h2c->hpack.allocated];
+        h2c->hpack.free += 32 + entry->name.len + entry->value.len;
+    }
+
+    h2c->hpack.size = size;
+    h2c->hpack.free -= needed;
+
+    return NGX_OK;
+}
