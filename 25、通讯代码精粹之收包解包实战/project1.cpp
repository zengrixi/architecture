// project1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <stdarg.h>
#include <stdio.h>
#include <vector>
#include <list>

using namespace std;
#pragma warning(disable : 4996)


int main()
{	
	//一：收包分析及包头结构定义
	//发包：采用 包头+包体，其中包头中记录着整个包【包头—+包体】的长度；
	//包头：就是一个结构；
	//a)一个包的长度不能超过30000个字节，必须要有最大值；
	 //伪造恶意数据包，他规定这里300亿，我这个规定能够确保服务器程序不会处于非常危险的境地；
	//b)开始定义包头结构：COMM_PKG_HEADER
	//c)********************大家千万注意这个问题，不然会大错特错；
	  //结构字节对齐问题；为了防止出现字节问题，所有在网络上传输的这种结构，必须都采用1字节对齐方式***********

	//二：收包状态宏定义
	//收包：粘包，缺包；
	//收包思路：先手包头->根据包头中的内容确定包体长度并收包体，收包状态（状态机）；
	//定义几种收包的状态, 4种：0,1,2,3

	//三：收包实战代码
	//聚焦在ngx_wait_request_handler()函数；
	//同时设置好各种收包的状态：c->curStat = _PKG_HD_INIT;    c->precvbuf = c->dataHeadInfo;  c->irecvlen = sizeof(COMM_PKG_HEADER); 
	//我们要求，客户端连入到服务器后，要主动地【客户端有义务】给服务器先发送数据包；服务器要主动收客户端的数据包；
	//服务器按照 包头 + 包体的格式来收包；

	//引入一个消息头【结构】STRUC_MSG_HEADER，用来记录一些额外信息
	//服务器 收包时，  收到： 包头+包体  ，我再额外附加一个消息头 ===》  消息头 + 包头 + 包体
	//再介绍一个分配和释放内存类CMemory；
	//本项目中不考虑内存池； 内存池：对于提高程序运行效率帮助有效；new非常快；
	//    内存池主要功能就是 频繁的分配小块内存时 内存池可以节省额外内存开销【代价就是代码更复杂】；

	//四：遗留问题处理
	//inMsgRecvQueue，tmpoutMsgRecvQueue，clearMsgRecvQueue
	
	//五：测试服务器收包避免推诿扯皮
	//验证ngx_wait_request_handler()函数是否正常工作,准备写一个客户端程序；
	//windows vs2017 ，mfc程序
	//老师强制大家要写测试程序来测试；你可以写linux平台下的测试程序；
	//觉悟：服务器主程序员【重担压肩】；
	//防止扯皮，所以服务器端有必要自己书写一个客户端测试程序；
	//说明：windows vs2017 客户端测试代码，非常简陋，只用于演示目的，不具备商业代码质量；
	//客户端的 SendData()函数值得学习；
	//核心代码;MFCApplication3Dlg.cpp

	   	  	
}


